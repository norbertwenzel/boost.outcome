<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>boost.outcome: Tutorial</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_md_03-tutorial.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#c-style">C style error handling: integer returns</a></li>
<li class="level1"><a href="#cpp98-style">C++ 98 style error handling: throwing exceptions</a></li>
<li class="level1"><a href="#cpp11-style">C++ 11 style error handling: error_code and noexcept</a><ul><li class="level2"><a href="#sea-of-noexcept">The "Islands of exception throw in a sea of noexcept" design pattern</a></li>
</ul>
</li>
<li class="level1"><a href="#cpp17-style">C++ 17 style error handling: outcome<T>, result<T> and option<T></a><ul><li class="level2"><a href="#exceptions-are-exceptional">The "Exceptions are exceptional, errors are not failure" design pattern</a></li>
<li class="level2"><a href="#try">Propagating errors up the call stack: The BOOST_OUTCOME_TRY(var, expression) macro</a></li>
</ul>
</li>
<li class="level1"><a href="#conclusion">Conclusion</a><ul><li class="level2"><a href="#basic_monad">What you need to know about basic_monad</a></li>
<li class="level2"><a href="#error_codes">What you need to know about error_code_extended</a></li>
<li class="level2"><a href="#optimal">A demonstration of how optimally tuned code using Outcome becomes</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="tutorial"></a></p>
<p>Outcome's utility cannot be fully understood without understanding how C++ does error handling. Due to C++'s maturity, error handling takes many forms which we will need to recap first.</p>
<h1><a class="anchor" id="c-style"></a>
C style error handling: integer returns</h1>
<p>Historically C++ 98 code has taken one of two design patterns when returning errors from functions. This pattern is taken from C, and indeed is pure C:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line"><span class="keyword">enum</span> errors</div>
<div class="line">{</div>
<div class="line">  SUCCESS=0,</div>
<div class="line">  NOMEM,</div>
<div class="line">  NOTFOUND,</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line">...</div>
<div class="line">int openfile(<span class="keyword">struct</span> handle **outh, <span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  *outh = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> handle));</div>
<div class="line">  <span class="keywordflow">if</span>(!*outh)</div>
<div class="line">    <span class="keywordflow">return</span> NOMEM;</div>
<div class="line">  (*outh)-&gt;fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>((*outh)-&gt;fd == -1)</div>
<div class="line">  {</div>
<div class="line">    free(*outh);</div>
<div class="line">    *outh = NULL;</div>
<div class="line">    <span class="keywordflow">return</span> NOTFOUND;</div>
<div class="line">  }</div>
<div class="line">  ...</div>
<div class="line">  <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Almost certainly anyone reading this has seen this error handling design umpteen times in their career. Variations on the same pattern are returning the enum type directly, returning a boolean and using a thread locally stored global variable such as <code>errno</code> and so on.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="cpp98-style"></a>
C++ 98 style error handling: throwing exceptions</h1>
<p>The second C++ 98 design pattern ought to also be very familiar to readers:</p>
<div class="fragment"><div class="line"><span class="comment">// Abstract base class for some handle implementation</span></div>
<div class="line"><span class="keyword">struct </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  ...</div>
<div class="line">  <span class="keyword">virtual</span> ~handle()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(fd != -1)</div>
<div class="line">    {</div>
<div class="line">      close(fd);</div>
<div class="line">      fd = -1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>handle_ref;  <span class="comment">// Some sort of smart pointer managing a handle *</span></div>
<div class="line">handle_ref openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;File not found&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Could throw std::bad_alloc or any other kind of exception during construction</span></div>
<div class="line">    <span class="keywordflow">return</span> handle_ref(<span class="keyword">new</span> some_derived_handle_implementation(fd));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(...)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="keywordflow">throw</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Experts will quite correctly chafe at the use of <code>std::runtime_error</code> to report a file not found, but nevertheless such a design pattern is very common in the wild, especially in older C++ which went a bit mad on using exception throws for control flow.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="cpp11-style"></a>
C++ 11 style error handling: error_code and noexcept</h1>
<p>C++ 11 brought in two new features to help bridge the gap between the over use of exception throws to report routine failures and C error handling: (i) <code>noexcept</code> and (ii) the standardisation of <code>error_code</code> from Boost. <code>noexcept</code> lets you mark functions with the guarantee that they shall <b>never</b> throw exceptions. This is commonly described as a feature enabling the compiler and standard library to use faster algorithms which can assume that operations never need to be rolled back part way through, however it also enables a whole new way of writing C++ which we shall call <em>"islands of exception throw in a sea
of noexcept"</em> which will be described later.</p>
<p>Both the Boost and C++ 11 <code>error_code</code> consists of an integer and a reference to an <code>error_category</code> instance. This allows one to set a <em>domain</em> for an integer error code such that <code>NOTFOUND</code> in library A can have a different integer value to <code>NOTFOUND</code> in library B. Because the reference to the domain of the error code is transported with the error code, integer error codes can be propagated <em>without losing information</em> into other code which need have no knowledge whatsover of libraries A nor B. <code>error_code</code> and the other machinery in <code>&lt;system_error&gt;</code> lets you handle errors from unknown libraries via <code>error_condition</code> which lets you inspect unknown third party <code>error_code</code>'s for whether they have semantic equivalence to the standard POSIX errors, and therefore handle a file-not-found situation based on semantic equivalence rather than losing information from the original source by doing an error code conversion. Therefore as with exception types deriving from <code>std::exception</code>, a central error handling routine can understand just enough of unknown third party error codes to act appropriately.</p>
<p>The C++ 11 standard library makes very limited use of <code>error_code</code> for reporting errors, however the Filesystem TS and Networking TS as indeed much of Boost uses this error handling design pattern extensively:</p>
<div class="fragment"><div class="line"><span class="comment">// Abstract base class for some handle implementation</span></div>
<div class="line"><span class="keyword">struct </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  ...</div>
<div class="line">  <span class="keyword">virtual</span> ~handle()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(fd != -1)</div>
<div class="line">    {</div>
<div class="line">      close(fd);</div>
<div class="line">      fd = -1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>handle_ref;  <span class="comment">// Some sort of smart pointer managing a handle *</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Non-throwing overload</span></div>
<div class="line">handle_ref openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, std::error_code &amp;ec) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Construct an error code in the OS errors domain</span></div>
<div class="line">    ec = std::error_code(errno, std::system_category());</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">auto</span> *p = <span class="keyword">new</span>(std::nothrow) some_derived_handle_implementation(fd, ec);</div>
<div class="line">  <span class="keywordflow">if</span>(p == <span class="keyword">nullptr</span>)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="comment">// Construct an error code matching the generic OS error equivalent</span></div>
<div class="line">    <span class="comment">// to the ENOMEM error condition</span></div>
<div class="line">    ec = <a class="code" href="group__monad.html#gab6204dd7620b0e495220e76988359589">std::make_error_code</a>(std::errc::not_enough_memory);</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">delete</span> p;</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> handle_ref(p);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Throwing overload</span></div>
<div class="line">handle_ref openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  std::error_code ec;</div>
<div class="line">  handle_ref ret(openfile(path, ec));</div>
<div class="line">  <span class="keywordflow">if</span>(ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">throw</span> std::system_error(ec);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This third error handling design pattern has two big advantages:</p>
<ol type="1">
<li>You only pay for what you use, so if you call the non-throwing overload you are guaranteed by the <code>noexcept</code> that execution flow will not unexpectedly invert. This makes writing correct exception safe code much easier, plus unpredictable execution times due to exception throws cannot occur. The compiler can also reduce executable bloat by not generating stack unwind tables around that call which is useful for some C++ users.</li>
<li>Simple usage of the API will default to the throwing (i.e. abort this operation) overload which is probably what most users <em>think</em> they want. This does have the advantage that the error won't be lost, however in practice aborting partially completed operations can lose other people's data just as easily as ignoring errors and proceeding regardless.</li>
</ol>
<p>Once you've been programming using the non-throwing API form for a while, some disadvantages begin to become obvious (which upcoming C++ 17/20 library additions will address):</p>
<ol type="1">
<li>It is clunky for callers of your function to have to create a <code>std::error_code</code> on the stack before calling the function passing in a lvalue ref. There is a temptation for programmers to reuse the <code>error_code &amp;ec</code> instance passed to their function, and this can become a source of unintended lost errors because errors already written there get overwritten or reset during error handling.</li>
<li>It is annoying having to type more boilerplate and remembering to check return codes just like in C. The compiler should be telling me when I forget to check an error, but the C++ 17 nodiscard attribute can't work with the lvalue ref passing pattern. This design pattern therefore suffers from the same problem as C style error codes, errors "get lost" or ignored inadvertently.</li>
<li>It might not seem a big thing until you see it in a large program, but having throwing and non-throwing variants of every API means doubling your API count. That means more maintenance, more testing, more documentation, more clutter.</li>
</ol>
<p>Summarising this section into a design pattern:</p>
<h2><a class="anchor" id="sea-of-noexcept"></a>
The "Islands of exception throw in a sea of noexcept" design pattern</h2>
<p>This design pattern was intended by the committee in C++ 11 to be the method by which that large minority of C++ users who disable RTTI and exceptions entirely could be brought back into ISO standard C++. The pattern is easy:</p>
<ol type="1">
<li>Every <code>extern</code> API in your translation unit is marked <code>noexcept</code> and uses a non-throwing mechanism such as <code>std::error_code</code> or even a C-style integer to return errors.</li>
<li>Functions within a translation unit not called from outside are generally not marked <code>noexcept</code>, or indeed may throw and catch exceptions before returning out of an extern <code>noexcept</code> API.</li>
<li>Because all <code>extern</code> function calls are <code>noexcept</code> throughout the entire codebase, from any given translation unit it is never the case that implementation code will ever call a potentially throwing function (C APIs are assumed to never throw on most C++ compilers). Because no calls to unknown code will ever throw, the compiler's optimiser <em>ought</em> to elide emission of stack unwind code and all other exception throw handling overhead in any sequence of code inside the translation unit <em>as if</em> exceptions had been globally disabled at the command line.</li>
<li>Where code inside a translation unit does call something which could throw e.g. much of the STL, exception handling overhead <em>ought</em> to be confined to the containing <code>try</code> ... <code>catch</code> <b>island</b> at best, at worst to that given translation unit.</li>
<li>Consumers of your <code>extern</code> API need not care how that API is internally implemented as they shall never see an exception thrown out of that API, and the compiler will optimise your code which uses that <code>extern</code> API in its <b>sea</b> of <code>noexcept</code> accordingly.</li>
</ol>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="cpp17-style"></a>
C++ 17 style error handling: outcome&lt;T&gt;, result&lt;T&gt; and option&lt;T&gt;</h1>
<p>We are finally onto Outcome. Outcome provides three simple utility classes: </p>
<dl>
<dt><code>option&lt;T&gt;</code> </dt>
<dd>Either empty, or an instance of type <code>T</code>. </dd>
<dt><code>result&lt;T&gt;</code> </dt>
<dd>One of empty, an instance of type <code>T</code> or a <code>std::error_code</code>. </dd>
<dt><code>outcome&lt;T&gt;</code> </dt>
<dd>One of empty, an instance of type <code>T</code>, a <code>std::error_code</code> or a <code>std::exception_ptr</code>. </dd>
</dl>
<p>All three of these are actually the same <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">basic_monad&lt;&gt;</a> class specialised with a policy which very closely matches <code>basic_monad&lt;&gt;</code>'s semantics to the C++ 17/20 utility classes <code>std::optional&lt;T&gt;</code> and <code>std::experimental::expected&lt;T, E&gt;</code> (this hasn't been approved yet by ISO WG21, but it's very close, likely later in 2017). In addition you gain a much more comprehensive monadic programming interface, and ultra low runtime overheads. But we will come back to that later. We won't labour the point, but you can absolutely substitute in most code an <code>option&lt;T&gt;</code> for a <code>std::optional&lt;T&gt;</code> and a <code>result&lt;T&gt;</code> for a <code>std::experimental::expected&lt;T, std::error_code&gt;</code> and this is intentional in the design of Outcome. There is no easy (planned) STL equivalent for <code>outcome&lt;T&gt;</code>.</p>
<p>Each of <code>option&lt;T&gt;</code>, <code>result&lt;T&gt;</code> and <code>outcome&lt;T&gt;</code> being actually a <code>basic_monad&lt;&gt;</code> instance have a very straightforward API, and less expressive monads implicitly convert into more expressive forms on demand. We will call the type <code>T</code> the value type, the error type will be any <code>std::error_code</code>-ish present and the exception type will be any <code>std::exception_ptr</code>-ish present.</p>
<ul>
<li>You retrieve a value type using the <code><a class="el" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316" title="Variable of type value_t. ">value()</a></code> or <code>get()</code> member functions. These come with const lvalue ref, lvalue ref and rvalue ref overloads, so you can directly modify or move from a contained value.<ul>
<li>Note that <code>void</code> is an entirely legal value type, and is considered always less expressive than any other value type i.e. an <code>outcome&lt;void&gt;</code> will implicitly convert into an <code>outcome&lt;int&gt;</code> preserving any empty, errored or excepted state. A valued state converts into default initialisation. Void monads are used very extensively internally to convert between different value typed monads.</li>
</ul>
</li>
<li>You retrieve an error type using the <code><a class="el" href="group__monad.html#ga1a1a8470c4efc3a52412f3ecc79a0060" title="Variable of type error_t. ">error()</a></code> or <code>get_error()</code> member functions.</li>
<li>You retrieve an exception type using the <code>exception()</code> or <code>get_exception()</code> member functions.</li>
<li>There are also state inspection member functions which have the entirely unsurprising STL nomenclature <code><a class="el" href="group__monad.html#ga68770961e182715930ad64ca244b645e" title="Variable of type empty_t. ">empty()</a></code>, <code>has_value()</code>, <code>has_error()</code> and <code>has_exception()</code>.</li>
<li>Semantics of things like <code>emplace()</code>, <code>operator*()</code> and <code>operator-&gt;()</code> all behave exactly the same as <code>std::optional&lt;T&gt;</code> and <code>std::experimental::expected&lt;T, E&gt;</code>, and indeed exactly as you would intutively guess as they behave the same as anywhere in the STL.</li>
<li><code>if(monad)</code> is true if and only if the monad contains an instance of <code>T</code>, again exactly the same as anywhere else in the STL.</li>
</ul>
<p>What happens if you try retrieving a value from a monad not containing a value?</p>
<ul>
<li>If it is empty, the macro <code><a class="el" href="config_8hpp.html#a10f1ea9f0f1205c24e106fb77cee19c3">BOOST_OUTCOME_THROW_MONAD_ERROR(monad_error(monad_errc::no_state))</a></code> is executed. This can be user redefined to do anything, but the default implementation throws a C++ exception of type <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1monad__error.html">monad_error</a> with code <a class="el" href="group__monad.html#gaf5abc43f8d09588556c4c65b53485c0d">monad_errc::no_state</a> if C++ exceptions are enabled by the compiler. If they are not, it prints a stack backtrace to stderr and aborts the process.</li>
<li>If it is errored, the macro <code><a class="el" href="config_8hpp.html#af1d540bfb21e8b45eaeb3ec60686e91f" title="Predefine to have something else occur when Outcome throws a system_error with an error_code from the...">BOOST_OUTCOME_THROW_SYSTEM_ERROR(std::system_error(ec))</a></code> is executed where <code>ec</code> is the <code>std::error_code</code> contained by the monad. Similarly to before, this can be redefined by the user to do anything, and its default implementation is exactly as earlier.</li>
<li>If it is excepted, the macro <code><a class="el" href="config_8hpp.html#a9f8f080f5049032b6d49faf0fd637140" title="Predefine to have something else occur when Outcome rethrows an exception_ptr from the monad...">BOOST_OUTCOME_RETHROW_EXCEPTION(e)</a></code> is executed where <code>e</code> is the <code>std::exception_ptr</code> contained by the monad.</li>
</ul>
<p>What happens if you try retrieving an error from a monad not containing an error?</p>
<ul>
<li>If it is empty, same as for the retrieving a value from not a valued monad.</li>
<li>If it is valued, returns a default constructed (i.e. null) error code.</li>
<li>If it is excepted, returns an error code of <code><a class="el" href="group__monad.html#ga13e71a6619b46ebe84986aecb270ffa2" title="Returns a reference to a monad error category. Note the address of one of these may not be constant t...">monad_category()</a></code> with code <code>monad_errc::exception_present</code>.</li>
</ul>
<p>What happens if you try retrieving an exception from a monad not containing an exception?</p>
<ul>
<li>If it is empty, same as for the retrieving a value from not a valued monad.</li>
<li>If it is valued, returns a default constructed (i.e. null) exception ptr.</li>
<li>If it is errored, returns an exception ptr to a <code>std::system_error</code> instance containing the monad's error code.</li>
</ul>
<p>And finally, if your compiler is in C++ 17 mode or later, monads are marked with the <a href="http://en.cppreference.com/w/cpp/language/attributes"><code>[[nodiscard]]</code></a> attribute. This means the compiler ought to warn if you forget to examine monads returned by functions. If you really mean to throw away a returned monad, make sure you cast it to <code>void</code> to tell the compiler you specifically intend to throw it away.</p>
<p>Reusing the same <code>openfile()</code> example from the earlier examples, this is it written using Outcome's <code>result&lt;T&gt;</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="group__config.html#gab113de43db2cd2a4cf1e33b54294944a">BOOST_OUTCOME_V1_NAMESPACE</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Returns the expected opened handle on success, or an unexpected cause of failure</span></div>
<div class="line">result&lt;handle_ref&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Normally make_errored_result&lt;&gt;() would take a std::error_code, but for convenience</span></div>
<div class="line">    <span class="comment">// if make_errored_result&lt;&gt;() is given an int, we assume this means a POSIX error</span></div>
<div class="line">    <span class="comment">// code. An additional overload exists on Windows for DWORDs so GetLastError() can be</span></div>
<div class="line">    <span class="comment">// passed directly to make_errored_result&lt;&gt;().</span></div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> make_errored_result&lt;&gt;(errno);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> handle_ref(<span class="keyword">new</span> some_derived_handle_implementation(fd));  <span class="comment">// result&lt;&gt; implicitly constructs from its `T`</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(...)</div>
<div class="line">    {</div>
<div class="line">      close(fd);</div>
<div class="line">      <span class="keywordflow">throw</span>;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">/* This macro is a long series of catch(const std::exception_type &amp;) clauses</span></div>
<div class="line"><span class="comment">  converting the STL exception types into their corresponding std::error_code with</span></div>
<div class="line"><span class="comment">  std::generic_category. At the end a catch all clause converts to EAGAIN.</span></div>
<div class="line"><span class="comment">  The error code is then returned via make_errored_result&lt;&gt;. </span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">  BOOST_OUTCOME_CATCH_EXCEPTION_TO_RESULT</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">...</span></div>
<div class="line"><span class="comment">auto fh_ = openfile(&quot;foo&quot;);</span></div>
<div class="line"><span class="comment">// We don&#39;t mind file not found errors, but anything else is serious</span></div>
<div class="line"><span class="comment">if(!fh_ &amp;&amp; fh_.error() != std::errc::no_such_file_or_directory)</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  // If the error code was not file not found, abort the current operation by</span></div>
<div class="line"><span class="comment">  // throwing the special exception type the STL reserves for transporting an</span></div>
<div class="line"><span class="comment">  // error code</span></div>
<div class="line"><span class="comment">  (void) fh_.value();  // does throw std::system_error(std::move(fh_.error())) for you</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">if(fh_)  // outcomes are boolean true if and only if they contain a value type</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  handle_ref fh = std::move(fh_.value());  // extract via move the value type</span></div>
<div class="line"><span class="comment">  fh-&gt;read(... etc</span></div>
<div class="line"><span class="comment">}</span></div>
</div><!-- fragment --><p>Some may feel that the potential loss of information caused by throwing away unmatched C++ exception throws is unacceptable. This of course depends on your particular code base, if you are really sure that you never will throw anything but STL exception types, then you need not worry. Still, if your code may well throw a custom exception type then this is what <code>outcome&lt;T&gt;</code> is for:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="group__config.html#gab113de43db2cd2a4cf1e33b54294944a">BOOST_OUTCOME_V1_NAMESPACE</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Returns the expected opened handle on success, a cause of not success (error_code),</span></div>
<div class="line"><span class="comment">// or why there was an unexpected and probably catastrophic failure (exception_ptr)</span></div>
<div class="line">outcome&lt;handle_ref&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// result&lt;&gt; is less expressive than outcome&lt;&gt; and so implicitly converts into outcome&lt;&gt;</span></div>
<div class="line">    <span class="keywordflow">return</span> make_errored_result&lt;&gt;(errno);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> handle_ref(<span class="keyword">new</span> some_derived_handle_implementation(fd));  <span class="comment">// outcome&lt;&gt; implicitly constructs from its `T`</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(...)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="keywordflow">return</span> make_exceptional_outcome&lt;&gt;();  <span class="comment">// defaults to using std::current_exception()</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">auto fh_ = openfile(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(!fh_)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// If the error code was not file not found, abort by rethrowing the</span></div>
<div class="line">  <span class="comment">// exact error or exception which occurred</span></div>
<div class="line">  <span class="keywordflow">if</span>(!fh_.has_error() || fh_.error() != std::errc::no_such_file_or_directory)</div>
<div class="line">  {</div>
<div class="line">    (void) fh_.value();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span>(fh_)</div>
<div class="line">{</div>
<div class="line">  handle_ref fh = std::move(fh_.value());  <span class="comment">// extract via move the value type</span></div>
<div class="line">  fh-&gt;read(... etc</div>
<div class="line">}</div>
</div><!-- fragment --><p>I think you'll agree that this is a really elegant expression of error handling in C++ and is a nice improvement over having to stack allocate error codes to be passed in by lvalue ref into APIs. Catastrophic errors are returned as exception ptrs which can be rethrown without loss of information, non serious errors are returned as error codes which can be from any arbitrary third party library's error code domain. All public APIs are <code>noexcept</code> and therefore calling them never causes an unexpected inversion of control flow. If this aesthetic appeals to you, then you need to be using Outcome in your code!</p>
<p>You might wonder why one would ever use <code>result&lt;&gt;</code> instead of <code>outcome&lt;&gt;</code> seeing as it leads to simpler, more elegant and expressive code? The reason why is that the compiler's optimiser is required to treat a potential use of <code>exception_ptr</code> as a synchronisation event because like <code>shared_ptr</code>, it is implemented using an atomically incremented and decremented reference count. By "synchronisation event" I mean that the compiler is <em>required</em> to emit changes visible to other threads, and therefore <em>must</em> emit assembler to read-modify-write the globally visible state rather than elide it. In addition to this, monads only have trivial destructors if everything they could contain also has a trivial destructor, and an exception ptr has a non-trivial destructor. In other words, the compiler can entirely elide and fuse long sequences of <code>result&lt;&gt;</code> to a much greater extent than it can <code>outcome&lt;&gt;</code> because the only globally visible effects of potentially creating an error code is the effect on global state of instantiating its error category. Therefore the compiler can emit exactly one call of the error category function, and thereafter assume subsequent calls to it will not affect globally visible state.</p>
<dl class="section note"><dt>Note</dt><dd>The Dinkumware STL supplied with Visual Studio makes any fetch of an error category an operation with globally visible consequences. Compilers using this STL therefore must emit a lot more assembler than with other STL implementations. This is part of the reason why MSVC generates additional code bloat above that of GCC or clang.</dd></dl>
<p>So, to sum up, try to use <code>option&lt;T&gt;</code> where that's appropriate. <code>option&lt;T&gt;</code> is constexpr available and very often vanishes entirely from the assembler generated. Try to use <code>result&lt;T&gt;</code> where you don't need a full <code>outcome&lt;T&gt;</code> where that's appropriate. And remember a less expressive form always implicitly converts into a more expressive form, so you can always feed options into results or outcomes, or results into outcomes.</p>
<p>Let's summarise all this into another new error handling design pattern:</p>
<h2><a class="anchor" id="exceptions-are-exceptional"></a>
The "Exceptions are exceptional, errors are not failure" design pattern</h2>
<p>In addition to the pure "sea of noexcept" for low latency users mentioned earlier, there is one other new error handling design pattern to mention made possible by Outcomes which combines "sea of noexcept" with exception throws. The idea is that ordinarily speaking code never throws an exception, and returns all failures anticipated by the programmer through <code>result&lt;T&gt;</code> as an error_code. If however something very unexpected occurs, a truly <em>exceptional</em> event, we exclusively use exception throws to abort the current operation entirely. For anyone familiar with Rust, this is <b>exactly</b> the Rust error handling model: Rust's <code>Result&lt;T&gt;</code> and <code>Option&lt;T&gt;</code> return errors expected by the programmer whereas a stack unwinding panic of the current thread is how exceptional, programmer unanticipated events are handled.</p>
<h2><a class="anchor" id="try"></a>
Propagating errors up the call stack: The BOOST_OUTCOME_TRY(var, expression) macro</h2>
<p>A very common operation with monadic transports is the <code>try</code> operation which means this boilerplate:</p>
<div class="fragment"><div class="line"><span class="comment">// Some other function returning a monad</span></div>
<div class="line">outcome&lt;handle_ref&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept;</div>
<div class="line"><span class="comment">// This is the function we are in, it must be returning a monad too</span></div>
<div class="line"><span class="comment">// and sometype is not going to be handle_ref</span></div>
<div class="line">outcome&lt;sometype&gt; another_function()</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">  <span class="comment">// This is the &quot;try&quot; operation common in Rust or Swift</span></div>
<div class="line">  <span class="comment">// It takes the form try! var = openfile(...);</span></div>
<div class="line">  outcome&lt;handle_ref&gt; unique_temporary = openfile(...);</div>
<div class="line">  <span class="keywordflow">if</span>(unique_temporary.has_error())</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> make_errored_outcome&lt;void&gt;(std::move(unique_temporary.error());</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(unique_temporary.has_exception())</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> make_exceptional_outcome&lt;void&gt;(std::move(unique_temporary.exception());</div>
<div class="line">  }</div>
<div class="line">  handle_ref var(std::move(unique_temporary.value()));</div>
<div class="line">}</div>
</div><!-- fragment --><p>In other words, the <code>try var = openfile(...)</code> operation examines the monad returned from calling <code>openfile(...)</code> to see if it is errored in some way. If it is, it extracts the error value, constructs a monad of the return type of the calling function and sets it to be errored to the same error value, returning immediately. If it is not errored, it extracts/unwraps the contained value in the monad into the <code>var</code> variable which is of the contained value type.</p>
<p>Because of the limitations of C++, Outcome cannot provide a nice syntax like <code>try var = openfile(...)</code>. The best it can do is <code>BOOST_OUTCOME_TRY(var, openfile(...))</code> which will declare <code>var</code> using <code>auto</code> onto the stack initialised to the moved contents of any valued monad returned by the expression, else it will convert the returned monad to its <code>&lt;void&gt;</code> form and return that immediately which ought to implicitly convert to whatever the return monad type of the enclosing function is.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="conclusion"></a>
Conclusion</h1>
<p>This tutorial has been kept deliberately as simple as possible after valuable feedback from the Boost developers' mailing list, and it has intentionally not covered a large chunk of Outcome's detail. A "single page cheat sheet" can be found at <a class="el" href="md_doc_md_02-quickstart.html#quickstart">Quick start for the expert</a>. Further documentation includes <a class="el" href="md_doc_md_05-advanced.html#advanced">Advanced usage: Outcome as a Monad</a> and <a class="el" href="md_doc_md_06-std_expected.html#std-expected">Outcome and the upcoming std::expected&lt;T, E&gt;</a>.</p>
<h2><a class="anchor" id="basic_monad"></a>
What you need to know about basic_monad</h2>
<p>There is some detail which you do need to know if you are to use Outcome in your own code though. During debugging sessions with code using Outcome you will find much reference <code>basic_monad&lt;&gt;</code> and you ought to understand the signature of its policy so you can read compiler warnings or debug prints: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;</div>
<div class="line">  <span class="keyword">class </span>monad_storage,</div>
<div class="line">  <span class="keyword">class </span>value_type,</div>
<div class="line">  <span class="keyword">class </span>error_type,</div>
<div class="line">  <span class="keyword">class </span>exception_type&gt;</div>
<div class="line"><span class="keyword">struct </span>BOOST_OUTCOME_MONAD_POLICY_BASE_NAME : <span class="keyword">public</span> monad_storage</div>
<div class="line">{ ... };</div>
</div><!-- fragment --><p> Any of <code>value_type</code>, <code>error_type</code> and <code>exception_type</code> can be <code>void</code>, in which case they are not in use in this instance. If you are using Microsoft Visual Studio, Outcome provides a debugging visualiser such that any <code>basic_monad&lt;&gt;</code> displays itself without any internal clutter. Just link into your final binary the <code>monad.natvis</code> file. Contributions of a GDB debugging visualiser would be welcome (open a pull request).</p>
<h2><a class="anchor" id="error_codes"></a>
What you need to know about error_code_extended</h2>
<p>Earlier in this tutorial we referred to <code>std::error_code</code>-ish. Outcome's <code>option&lt;T&gt;</code>, <code>result&lt;T&gt;</code> and <code>outcome&lt;T&gt;</code> are actually bound to use <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> rather than <code>std::error_code</code>. <code>error_code_extended</code> inherits publicly from <code>std::error_code</code>, adding two new member functions: <code>extended_message()</code> and <code>backtrace()</code>. These <em>may</em> provide additional information about the error code like any <code>what()</code> message from the C++ exception the error code was constructed from (if any), or the stack backtrace of the point at which the <code>error_code_extended</code> was constructed. It is absolutely safe to type slice an <code>error_code_extended</code> into a <code>std::error_code</code> at any time, the extended error code contains nothing needing destructing. You can therefore feed the extended error code to anything accepting a <code>std::error_code</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Note to Boost peer reviewers: You cannot currently implicitly construct an extended error code from a standard error code. This is to prevent accidental extended =&gt; normal =&gt; extended conversions which would lose the extended data. Please do say in any review if you think this a bad idea.</dd></dl>
<h2><a class="anchor" id="optimal"></a>
A demonstration of how optimally tuned code using Outcome becomes</h2>
<p>We shall end this tutorial with a demonstration of how little runtime overhead Outcome produces which was achieved after investing a lot of trial and error effort by the author with the optimisers of the three big compilers. Unlike many libraries which claim to care about runtime overhead, Outcome's CIs actually run per-commit a test suite which compiles various sequences of code using outcomes and counts the assembler instructions emitted. This ensures changes do not ruin Outcome's laboriously implemented tuning for current compiler optimisers to make sure they generate minimum runtime overhead. Here is a small program written using <a class="el" href="md_doc_md_05-advanced.html#advanced">Outcome's monadic operators</a> and lambda bind:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span><a class="code" href="group__monad.html#gaab2ff6220205017226794529c863b336">boost::outcome</a>;</div>
<div class="line">  result&lt;int&gt; f(5);</div>
<div class="line">  <span class="keyword">auto</span> g = (f &amp; 6) &gt;&gt; [](<span class="keyword">auto</span> v) -&gt; <span class="keywordtype">int</span> { <span class="keywordflow">return</span> v==5 ? 2 : 8; } | 2; </div>
<div class="line">  <span class="keywordflow">return</span> g.value();</div>
<div class="line">}</div>
</div><!-- fragment --><p> So this program will test if f is valued via the AND operator and if so returns a new <code>result&lt;int&gt;</code> containing a 6, that is then bound to the generic lambda which compares the value to 5, and because it is not returns 8, creating another new <code>result&lt;int&gt;</code> (because the lambda returned an <code>int</code>) containing the returned value. The OR operator creates yet another <code>result&lt;int&gt;</code> replacing the value with 2 if the monad were not valued, but because it is valued g will take on the type <code>result&lt;int&gt;</code> propagated from the front and the value 8. So that is four <code>result&lt;int&gt;</code> instances constructed and destructed above, two copy operations and one move operation.</p>
<p>Compiling this with GCC 6.2 with <code>-std=c++1z -S -O3</code> yields this assembler: </p>
<div class="fragment"><div class="line">  .section  .text.startup,<span class="stringliteral">&quot;ax&quot;</span>,@progbits</div>
<div class="line">  .p2align 4,,15</div>
<div class="line">  .globl  main</div>
<div class="line">  .type main, @<span class="keyword">function</span></div>
<div class="line">main:</div>
<div class="line">  .cfi_startproc</div>
<div class="line">  movl  $8, %eax</div>
<div class="line">  ret</div>
<div class="line">  .cfi_endproc</div>
</div><!-- fragment --><p> Yes, that's exactly one assembler instruction which simply returns 8. The fact you used Outcome has entirely disappeared from runtime overhead because the compiler has completely eliminated the considerable quantities of C++ which could have been executed. Enjoy! </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
