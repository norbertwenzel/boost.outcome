<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>boost.outcome: Configurable lightweight simple monadic value transport with the same semantics and API as a future</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__monad.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Configurable lightweight simple monadic value transport with the same semantics and API as a future</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__macro__helpers"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__macro__helpers.html">Useful preprocessor macros which expand into commonly written boilerplate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1monad__error.html">boost::outcome::v1_xxx::monad_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A monad exception object.  <a href="classboost_1_1outcome_1_1v1__xxx_1_1monad__error.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1is__error__code__enum_3_01boost_1_1outcome_1_1v1__xxx_1_1monad__errc_01_4.html">std::is_error_code_enum&lt; boost::outcome::v1_xxx::monad_errc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the STL this is an error code enum.  <a href="structstd_1_1is__error__code__enum_3_01boost_1_1outcome_1_1v1__xxx_1_1monad__errc_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstd_1_1is__error__condition__enum_3_01boost_1_1outcome_1_1v1__xxx_1_1monad__errc_01_4.html">std::is_error_condition_enum&lt; boost::outcome::v1_xxx::monad_errc &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tells the STL this is an error condition enum.  <a href="structstd_1_1is__error__condition__enum_3_01boost_1_1outcome_1_1v1__xxx_1_1monad__errc_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1empty__t.html">boost::outcome::v1_xxx::empty_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type tag for an empty monad.  <a href="structboost_1_1outcome_1_1v1__xxx_1_1empty__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1value__t.html">boost::outcome::v1_xxx::value_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type tag for a valued monad.  <a href="structboost_1_1outcome_1_1v1__xxx_1_1value__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1error__t.html">boost::outcome::v1_xxx::error_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type tag for an errored monad.  <a href="structboost_1_1outcome_1_1v1__xxx_1_1error__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1exception__t.html">boost::outcome::v1_xxx::exception_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type tag for an excepted monad.  <a href="structboost_1_1outcome_1_1v1__xxx_1_1exception__t.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">boost::outcome::v1_xxx::basic_monad&lt; Impl &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a configurable lightweight simple monadic value transport with the same semantics and API as a future.  <a href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1value__storage.html">boost::outcome::v1_xxx::value_storage&lt; _value_type, _error_type, _exception_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fixed lightweight variant store for monad.This fixed variant list of empty, a type <code>value_type</code>, a lightweight <code>error_type</code> or a heavier <code>exception_type</code> typically has a space cost of <code>max(24, sizeof(R)+8)</code>. If however you specialise <code><a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1enable__single__byte__value__storage.html" title="Specialise to indicate that this type should use the single byte storage layout. You get six bits of ...">enable_single_byte_value_storage</a>&lt;T&gt;</code> with <code>true_type</code>, and both <code>error_type</code> and <code>exception_type</code> are disabled (void), a special single byte storage implementation is enabled. Both <code>bool</code> and <code>void</code> are already specialised.  <a href="classboost_1_1outcome_1_1v1__xxx_1_1value__storage.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaab2ff6220205017226794529c863b336"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaab2ff6220205017226794529c863b336"></a>
template&lt;typename R &gt; </td></tr>
<tr class="memitem:gaab2ff6220205017226794529c863b336"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaab2ff6220205017226794529c863b336">boost::outcome::v1_xxx::outcome</a> = basic_monad&lt; detail::monad_policy&lt; R &gt;&gt;</td></tr>
<tr class="memdesc:gaab2ff6220205017226794529c863b336"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>outcome&lt;R&gt;</code> can hold a fixed variant list of empty, a type <code>R</code>, a lightweight <code>std::error_code</code> or a heavier <code>std::exception_ptr</code> at a space cost of <code>max(24, sizeof(R)+8)</code>. This corresponds to <code>tribool::unknown</code>, <code>tribool::true_</code>, <code>tribool::false_</code> and <code>tribool::false_</code> respectively. <br/></td></tr>
<tr class="separator:gaab2ff6220205017226794529c863b336"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91e1fe11dbebea15458d882d078d6eb5"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga91e1fe11dbebea15458d882d078d6eb5"></a>
template&lt;typename R &gt; </td></tr>
<tr class="memitem:ga91e1fe11dbebea15458d882d078d6eb5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga91e1fe11dbebea15458d882d078d6eb5">boost::outcome::v1_xxx::result</a> = basic_monad&lt; detail::result_policy&lt; R &gt;&gt;</td></tr>
<tr class="memdesc:ga91e1fe11dbebea15458d882d078d6eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>result&lt;R&gt;</code> can hold a fixed variant list of empty, a type <code>R</code> or a lightweight <code>std::error_code</code> at a space cost of <code>max(24, sizeof(R)+8)</code>. This corresponds to <code>tribool::unknown</code>, <code>tribool::true_</code> and <code>tribool::false_</code> respectively. This specialisation looks deliberately like Rust's <code>Result&lt;T&gt;</code>. <br/></td></tr>
<tr class="separator:ga91e1fe11dbebea15458d882d078d6eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d0fd5ca15cb339df9aa8e829a8ea5e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0d0fd5ca15cb339df9aa8e829a8ea5e0"></a>
template&lt;typename R &gt; </td></tr>
<tr class="memitem:ga0d0fd5ca15cb339df9aa8e829a8ea5e0"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga0d0fd5ca15cb339df9aa8e829a8ea5e0">boost::outcome::v1_xxx::option</a> = basic_monad&lt; detail::option_policy&lt; R &gt;&gt;</td></tr>
<tr class="memdesc:ga0d0fd5ca15cb339df9aa8e829a8ea5e0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>option&lt;R&gt;</code> can hold a fixed variant list of empty or a type <code>R</code> at a space cost of <code>sizeof(<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1value__storage.html" title="A fixed lightweight variant store for monad.This fixed variant list of empty, a type value_type...">value_storage</a>&lt;R&gt;)</code> which is usually <code>sizeof(R)+8</code>, but may be smaller if <code><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1value__storage.html" title="A fixed lightweight variant store for monad.This fixed variant list of empty, a type value_type...">value_storage</a>&lt;R&gt;</code> is specialised. This corresponds to <code>tribool::unknown</code> and <code>tribool::true_</code> respectively. This specialisation looks deliberately like Rust's <code>Option&lt;T&gt;</code>. <br/></td></tr>
<tr class="separator:ga0d0fd5ca15cb339df9aa8e829a8ea5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gaf5abc43f8d09588556c4c65b53485c0d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__monad.html#gaf5abc43f8d09588556c4c65b53485c0d">boost::outcome::v1_xxx::monad_errc</a> { <a class="el" href="group__monad.html#ggaf5abc43f8d09588556c4c65b53485c0da25621f93230ec01ef6ead2516f3613ce">boost::outcome::v1_xxx::monad_errc::already_set</a> = 1, 
<a class="el" href="group__monad.html#ggaf5abc43f8d09588556c4c65b53485c0dac537dcef56fd6ff75592c0220fd3dae1">boost::outcome::v1_xxx::monad_errc::no_state</a> = 2, 
<a class="el" href="group__monad.html#ggaf5abc43f8d09588556c4c65b53485c0da621bbc00c646a321b70c18a067da2eb2">boost::outcome::v1_xxx::monad_errc::exception_present</a> = 3
 }</td></tr>
<tr class="memdesc:gaf5abc43f8d09588556c4c65b53485c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the ways in which a monad operation may fail.  <a href="group__monad.html#gaf5abc43f8d09588556c4c65b53485c0d">More...</a><br/></td></tr>
<tr class="separator:gaf5abc43f8d09588556c4c65b53485c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga13e71a6619b46ebe84986aecb270ffa2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga13e71a6619b46ebe84986aecb270ffa2"></a>
const _detail::monad_category &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__monad.html#ga13e71a6619b46ebe84986aecb270ffa2">boost::outcome::v1_xxx::monad_category</a> ()</td></tr>
<tr class="memdesc:ga13e71a6619b46ebe84986aecb270ffa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a monad error category. Note the address of one of these may not be constant throughout the process as per the ISO spec. <br/></td></tr>
<tr class="separator:ga13e71a6619b46ebe84986aecb270ffa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6204dd7620b0e495220e76988359589"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab6204dd7620b0e495220e76988359589"></a>
stl11::error_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__monad.html#gab6204dd7620b0e495220e76988359589">boost::outcome::v1_xxx::make_error_code</a> (monad_errc e)</td></tr>
<tr class="memdesc:gab6204dd7620b0e495220e76988359589"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL looked up by the STL to convert a monad_errc into an error_code. <br/></td></tr>
<tr class="separator:gab6204dd7620b0e495220e76988359589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5824d43d94ed4cb2593cf39b2d0f354d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga5824d43d94ed4cb2593cf39b2d0f354d"></a>
stl11::error_condition&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__monad.html#ga5824d43d94ed4cb2593cf39b2d0f354d">boost::outcome::v1_xxx::make_error_condition</a> (monad_errc e)</td></tr>
<tr class="memdesc:ga5824d43d94ed4cb2593cf39b2d0f354d"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADL looked up by the STL to convert a monad_errc into an error_condition. <br/></td></tr>
<tr class="separator:ga5824d43d94ed4cb2593cf39b2d0f354d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6965ad141b9cf5cc08f26684ea54967d"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6965ad141b9cf5cc08f26684ea54967d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6965ad141b9cf5cc08f26684ea54967d"><td class="memTemplItemLeft" align="right" valign="top">constexpr outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga6965ad141b9cf5cc08f26684ea54967d">boost::outcome::v1_xxx::make_outcome</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:ga6965ad141b9cf5cc08f26684ea54967d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an outcome from the type passed. <br/></td></tr>
<tr class="separator:ga6965ad141b9cf5cc08f26684ea54967d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb38ac1fcaae9fdc019a82d76ffdd9b"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaedb38ac1fcaae9fdc019a82d76ffdd9b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gaedb38ac1fcaae9fdc019a82d76ffdd9b"><td class="memTemplItemLeft" align="right" valign="top">constexpr outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaedb38ac1fcaae9fdc019a82d76ffdd9b">boost::outcome::v1_xxx::make_outcome</a> (const T &amp;v)</td></tr>
<tr class="memdesc:gaedb38ac1fcaae9fdc019a82d76ffdd9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an outcome from the type passed. <br/></td></tr>
<tr class="separator:gaedb38ac1fcaae9fdc019a82d76ffdd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cbada16dcc6af63be3da3910cf991c9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2cbada16dcc6af63be3da3910cf991c9"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga2cbada16dcc6af63be3da3910cf991c9"><td class="memTemplItemLeft" align="right" valign="top">outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga2cbada16dcc6af63be3da3910cf991c9">boost::outcome::v1_xxx::make_outcome</a> (error_code_extended v)</td></tr>
<tr class="memdesc:ga2cbada16dcc6af63be3da3910cf991c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an errored outcome of type T. <br/></td></tr>
<tr class="separator:ga2cbada16dcc6af63be3da3910cf991c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff527de79abd9d31bbd96057ff58f1c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5ff527de79abd9d31bbd96057ff58f1c"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga5ff527de79abd9d31bbd96057ff58f1c"><td class="memTemplItemLeft" align="right" valign="top">outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga5ff527de79abd9d31bbd96057ff58f1c">boost::outcome::v1_xxx::make_outcome</a> (std::exception_ptr v)</td></tr>
<tr class="memdesc:ga5ff527de79abd9d31bbd96057ff58f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an excepted outcome of type T. <br/></td></tr>
<tr class="separator:ga5ff527de79abd9d31bbd96057ff58f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c8a609f3c8813c0908690fefc9f61b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5c8a609f3c8813c0908690fefc9f61b8"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga5c8a609f3c8813c0908690fefc9f61b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga5c8a609f3c8813c0908690fefc9f61b8">boost::outcome::v1_xxx::make_outcome</a> ()</td></tr>
<tr class="memdesc:ga5c8a609f3c8813c0908690fefc9f61b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an empty outcome of type T. <br/></td></tr>
<tr class="separator:ga5c8a609f3c8813c0908690fefc9f61b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfda8cccf3a09f8ee574f3eee65db59e"><td class="memTemplParams" colspan="2"><a class="anchor" id="gadfda8cccf3a09f8ee574f3eee65db59e"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:gadfda8cccf3a09f8ee574f3eee65db59e"><td class="memTemplItemLeft" align="right" valign="top">constexpr outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gadfda8cccf3a09f8ee574f3eee65db59e">boost::outcome::v1_xxx::make_empty_outcome</a> ()</td></tr>
<tr class="memdesc:gadfda8cccf3a09f8ee574f3eee65db59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an empty outcome of type T. <br/></td></tr>
<tr class="separator:gadfda8cccf3a09f8ee574f3eee65db59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddfb03f7b310708ac4e529c5fe24da57"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaddfb03f7b310708ac4e529c5fe24da57"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gaddfb03f7b310708ac4e529c5fe24da57"><td class="memTemplItemLeft" align="right" valign="top">constexpr outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaddfb03f7b310708ac4e529c5fe24da57">boost::outcome::v1_xxx::make_ready_outcome</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:gaddfb03f7b310708ac4e529c5fe24da57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a ready outcome from the type passed. <br/></td></tr>
<tr class="separator:gaddfb03f7b310708ac4e529c5fe24da57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3cd6f5fc64ec44431c9a130368e486f"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa3cd6f5fc64ec44431c9a130368e486f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa3cd6f5fc64ec44431c9a130368e486f"><td class="memTemplItemLeft" align="right" valign="top">constexpr outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaa3cd6f5fc64ec44431c9a130368e486f">boost::outcome::v1_xxx::make_ready_outcome</a> (const T &amp;v)</td></tr>
<tr class="memdesc:gaa3cd6f5fc64ec44431c9a130368e486f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a ready outcome from the type passed. <br/></td></tr>
<tr class="separator:gaa3cd6f5fc64ec44431c9a130368e486f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafac3f1531826af2115f7259e0f993cf"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaafac3f1531826af2115f7259e0f993cf"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:gaafac3f1531826af2115f7259e0f993cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gaafac3f1531826af2115f7259e0f993cf">boost::outcome::v1_xxx::make_ready_outcome</a> ()</td></tr>
<tr class="memdesc:gaafac3f1531826af2115f7259e0f993cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a ready outcome from the type passed. <br/></td></tr>
<tr class="separator:gaafac3f1531826af2115f7259e0f993cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c259d35a71b8a671e062519c2a0465"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga32c259d35a71b8a671e062519c2a0465"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga32c259d35a71b8a671e062519c2a0465"><td class="memTemplItemLeft" align="right" valign="top">outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga32c259d35a71b8a671e062519c2a0465">boost::outcome::v1_xxx::make_errored_outcome</a> (error_code_extended v)</td></tr>
<tr class="memdesc:ga32c259d35a71b8a671e062519c2a0465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an errored outcome from the type passed. <br/></td></tr>
<tr class="separator:ga32c259d35a71b8a671e062519c2a0465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga957407dac2e29027b1de74afba958e35"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga957407dac2e29027b1de74afba958e35"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga957407dac2e29027b1de74afba958e35"><td class="memTemplItemLeft" align="right" valign="top">outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga957407dac2e29027b1de74afba958e35">boost::outcome::v1_xxx::make_errored_outcome</a> (int e, const char *extended=nullptr)</td></tr>
<tr class="memdesc:ga957407dac2e29027b1de74afba958e35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a generic errored outcome from the errno passed. <br/></td></tr>
<tr class="separator:ga957407dac2e29027b1de74afba958e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768281695a2f5e4fcad226c8bdbe4e2a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga768281695a2f5e4fcad226c8bdbe4e2a"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga768281695a2f5e4fcad226c8bdbe4e2a"><td class="memTemplItemLeft" align="right" valign="top">constexpr outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga768281695a2f5e4fcad226c8bdbe4e2a">boost::outcome::v1_xxx::make_errored_outcome</a> (unsigned long e, const char *extended=nullptr)</td></tr>
<tr class="memdesc:ga768281695a2f5e4fcad226c8bdbe4e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a system errored outcome from the code passed. <br/></td></tr>
<tr class="separator:ga768281695a2f5e4fcad226c8bdbe4e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7e203492bd1b5ee6f6ea0ae190a95e"><td class="memTemplParams" colspan="2"><a class="anchor" id="gadc7e203492bd1b5ee6f6ea0ae190a95e"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:gadc7e203492bd1b5ee6f6ea0ae190a95e"><td class="memTemplItemLeft" align="right" valign="top">outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gadc7e203492bd1b5ee6f6ea0ae190a95e">boost::outcome::v1_xxx::make_exceptional_outcome</a> (std::exception_ptr v=std::current_exception())</td></tr>
<tr class="memdesc:gadc7e203492bd1b5ee6f6ea0ae190a95e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an excepted outcome from the type passed. <br/></td></tr>
<tr class="separator:gadc7e203492bd1b5ee6f6ea0ae190a95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga559b5e8efc12ededdc3aeecce0d304de"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga559b5e8efc12ededdc3aeecce0d304de"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga559b5e8efc12ededdc3aeecce0d304de"><td class="memTemplItemLeft" align="right" valign="top">constexpr result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga559b5e8efc12ededdc3aeecce0d304de">boost::outcome::v1_xxx::make_result</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:ga559b5e8efc12ededdc3aeecce0d304de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a result from the type passed. <br/></td></tr>
<tr class="separator:ga559b5e8efc12ededdc3aeecce0d304de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6828dd2254d99a9759229733f52f60a4"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6828dd2254d99a9759229733f52f60a4"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga6828dd2254d99a9759229733f52f60a4"><td class="memTemplItemLeft" align="right" valign="top">constexpr result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga6828dd2254d99a9759229733f52f60a4">boost::outcome::v1_xxx::make_result</a> (const T &amp;v)</td></tr>
<tr class="memdesc:ga6828dd2254d99a9759229733f52f60a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a result from the type passed. <br/></td></tr>
<tr class="separator:ga6828dd2254d99a9759229733f52f60a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00f295e5d9ea903b2477e631e46bea3e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga00f295e5d9ea903b2477e631e46bea3e"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga00f295e5d9ea903b2477e631e46bea3e"><td class="memTemplItemLeft" align="right" valign="top">result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga00f295e5d9ea903b2477e631e46bea3e">boost::outcome::v1_xxx::make_result</a> (error_code_extended v)</td></tr>
<tr class="memdesc:ga00f295e5d9ea903b2477e631e46bea3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an errored result of type T. <br/></td></tr>
<tr class="separator:ga00f295e5d9ea903b2477e631e46bea3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9b39f9a3247cc669105aab8a414fd37"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae9b39f9a3247cc669105aab8a414fd37"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:gae9b39f9a3247cc669105aab8a414fd37"><td class="memTemplItemLeft" align="right" valign="top">constexpr result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gae9b39f9a3247cc669105aab8a414fd37">boost::outcome::v1_xxx::make_result</a> ()</td></tr>
<tr class="memdesc:gae9b39f9a3247cc669105aab8a414fd37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an empty result of type T. <br/></td></tr>
<tr class="separator:gae9b39f9a3247cc669105aab8a414fd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bff5754b64adeb2708ab9bec52aff57"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4bff5754b64adeb2708ab9bec52aff57"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga4bff5754b64adeb2708ab9bec52aff57"><td class="memTemplItemLeft" align="right" valign="top">constexpr result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga4bff5754b64adeb2708ab9bec52aff57">boost::outcome::v1_xxx::make_empty_result</a> ()</td></tr>
<tr class="memdesc:ga4bff5754b64adeb2708ab9bec52aff57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an empty result of type T. <br/></td></tr>
<tr class="separator:ga4bff5754b64adeb2708ab9bec52aff57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a14014596a489c7b9741c4194f1a06f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga8a14014596a489c7b9741c4194f1a06f"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga8a14014596a489c7b9741c4194f1a06f"><td class="memTemplItemLeft" align="right" valign="top">constexpr result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga8a14014596a489c7b9741c4194f1a06f">boost::outcome::v1_xxx::make_ready_result</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:ga8a14014596a489c7b9741c4194f1a06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a result from the type passed. <br/></td></tr>
<tr class="separator:ga8a14014596a489c7b9741c4194f1a06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3860813fcb7c13a46cad332133cfc25"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad3860813fcb7c13a46cad332133cfc25"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gad3860813fcb7c13a46cad332133cfc25"><td class="memTemplItemLeft" align="right" valign="top">constexpr result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gad3860813fcb7c13a46cad332133cfc25">boost::outcome::v1_xxx::make_ready_result</a> (const T &amp;v)</td></tr>
<tr class="memdesc:gad3860813fcb7c13a46cad332133cfc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a result from the type passed. <br/></td></tr>
<tr class="separator:gad3860813fcb7c13a46cad332133cfc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc05b498031064ec9e6ed4cca732c5d3"><td class="memTemplParams" colspan="2"><a class="anchor" id="gabc05b498031064ec9e6ed4cca732c5d3"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:gabc05b498031064ec9e6ed4cca732c5d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gabc05b498031064ec9e6ed4cca732c5d3">boost::outcome::v1_xxx::make_ready_result</a> ()</td></tr>
<tr class="memdesc:gabc05b498031064ec9e6ed4cca732c5d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a result from the type passed. <br/></td></tr>
<tr class="separator:gabc05b498031064ec9e6ed4cca732c5d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6175fc3a5c4bb5ab9f782654e96bb354"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6175fc3a5c4bb5ab9f782654e96bb354"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga6175fc3a5c4bb5ab9f782654e96bb354"><td class="memTemplItemLeft" align="right" valign="top">result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga6175fc3a5c4bb5ab9f782654e96bb354">boost::outcome::v1_xxx::make_errored_result</a> (error_code_extended v)</td></tr>
<tr class="memdesc:ga6175fc3a5c4bb5ab9f782654e96bb354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an errored result from the type passed. <br/></td></tr>
<tr class="separator:ga6175fc3a5c4bb5ab9f782654e96bb354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f57f84218bf0e13f6319609adc7e03c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0f57f84218bf0e13f6319609adc7e03c"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga0f57f84218bf0e13f6319609adc7e03c"><td class="memTemplItemLeft" align="right" valign="top">constexpr result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga0f57f84218bf0e13f6319609adc7e03c">boost::outcome::v1_xxx::make_errored_result</a> (int e, const char *extended=nullptr)</td></tr>
<tr class="memdesc:ga0f57f84218bf0e13f6319609adc7e03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a generic errored outcome from the errno passed. <br/></td></tr>
<tr class="separator:ga0f57f84218bf0e13f6319609adc7e03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee9f3b12c9f643bea51b050836f9115"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0ee9f3b12c9f643bea51b050836f9115"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga0ee9f3b12c9f643bea51b050836f9115"><td class="memTemplItemLeft" align="right" valign="top">constexpr result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga0ee9f3b12c9f643bea51b050836f9115">boost::outcome::v1_xxx::make_errored_result</a> (unsigned long e, const char *extended=nullptr)</td></tr>
<tr class="memdesc:ga0ee9f3b12c9f643bea51b050836f9115"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a system errored outcome from the code passed. <br/></td></tr>
<tr class="separator:ga0ee9f3b12c9f643bea51b050836f9115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7729448d32a8fd9ee4a34fc84152e165"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7729448d32a8fd9ee4a34fc84152e165"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7729448d32a8fd9ee4a34fc84152e165"><td class="memTemplItemLeft" align="right" valign="top">constexpr option&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga7729448d32a8fd9ee4a34fc84152e165">boost::outcome::v1_xxx::make_option</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:ga7729448d32a8fd9ee4a34fc84152e165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a option from the type passed. <br/></td></tr>
<tr class="separator:ga7729448d32a8fd9ee4a34fc84152e165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65efd2af5ed17063df929d7d4d354f3b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga65efd2af5ed17063df929d7d4d354f3b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga65efd2af5ed17063df929d7d4d354f3b"><td class="memTemplItemLeft" align="right" valign="top">constexpr option&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga65efd2af5ed17063df929d7d4d354f3b">boost::outcome::v1_xxx::make_option</a> (const T &amp;v)</td></tr>
<tr class="memdesc:ga65efd2af5ed17063df929d7d4d354f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a option from the type passed. <br/></td></tr>
<tr class="separator:ga65efd2af5ed17063df929d7d4d354f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91bdd5cc02fbeeb47fe28099a0b9a5b8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga91bdd5cc02fbeeb47fe28099a0b9a5b8"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga91bdd5cc02fbeeb47fe28099a0b9a5b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr option&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga91bdd5cc02fbeeb47fe28099a0b9a5b8">boost::outcome::v1_xxx::make_option</a> ()</td></tr>
<tr class="memdesc:ga91bdd5cc02fbeeb47fe28099a0b9a5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an empty option of type T. <br/></td></tr>
<tr class="separator:ga91bdd5cc02fbeeb47fe28099a0b9a5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85a0d8107c763a68a4705ed56d0d5fdf"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga85a0d8107c763a68a4705ed56d0d5fdf"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga85a0d8107c763a68a4705ed56d0d5fdf"><td class="memTemplItemLeft" align="right" valign="top">constexpr option&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga85a0d8107c763a68a4705ed56d0d5fdf">boost::outcome::v1_xxx::make_empty_option</a> ()</td></tr>
<tr class="memdesc:ga85a0d8107c763a68a4705ed56d0d5fdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an empty option of type T. <br/></td></tr>
<tr class="separator:ga85a0d8107c763a68a4705ed56d0d5fdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga770b7101b357cfdaae3929559c70b627"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga770b7101b357cfdaae3929559c70b627"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga770b7101b357cfdaae3929559c70b627"><td class="memTemplItemLeft" align="right" valign="top">constexpr option&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga770b7101b357cfdaae3929559c70b627">boost::outcome::v1_xxx::make_ready_option</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:ga770b7101b357cfdaae3929559c70b627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a option from the type passed. <br/></td></tr>
<tr class="separator:ga770b7101b357cfdaae3929559c70b627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12a691944097d95764a03cf4f498eaee"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga12a691944097d95764a03cf4f498eaee"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga12a691944097d95764a03cf4f498eaee"><td class="memTemplItemLeft" align="right" valign="top">constexpr option&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga12a691944097d95764a03cf4f498eaee">boost::outcome::v1_xxx::make_ready_option</a> (const T &amp;v)</td></tr>
<tr class="memdesc:ga12a691944097d95764a03cf4f498eaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a option from the type passed. <br/></td></tr>
<tr class="separator:ga12a691944097d95764a03cf4f498eaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80952fc111f8ff64dddb86ed7edaa306"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga80952fc111f8ff64dddb86ed7edaa306"></a>
template&lt;class T  = void&gt; </td></tr>
<tr class="memitem:ga80952fc111f8ff64dddb86ed7edaa306"><td class="memTemplItemLeft" align="right" valign="top">constexpr option&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga80952fc111f8ff64dddb86ed7edaa306">boost::outcome::v1_xxx::make_ready_option</a> ()</td></tr>
<tr class="memdesc:ga80952fc111f8ff64dddb86ed7edaa306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a option from the type passed. <br/></td></tr>
<tr class="separator:ga80952fc111f8ff64dddb86ed7edaa306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae530c39aba6722190036aaeb7bf411f7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae530c39aba6722190036aaeb7bf411f7"><td class="memTemplItemLeft" align="right" valign="top">constexpr outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gae530c39aba6722190036aaeb7bf411f7">boost::outcome::v1_xxx::as_outcome</a> (result&lt; T &gt; &amp;&amp;v)</td></tr>
<tr class="memdesc:gae530c39aba6722190036aaeb7bf411f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an outcome from a result.  <a href="#gae530c39aba6722190036aaeb7bf411f7">More...</a><br/></td></tr>
<tr class="separator:gae530c39aba6722190036aaeb7bf411f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e3dc2abb1f8c417f57826c578b5aea6"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga2e3dc2abb1f8c417f57826c578b5aea6"><td class="memTemplItemLeft" align="right" valign="top">constexpr outcome&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga2e3dc2abb1f8c417f57826c578b5aea6">boost::outcome::v1_xxx::as_outcome</a> (const result&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga2e3dc2abb1f8c417f57826c578b5aea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an outcome from a result.  <a href="#ga2e3dc2abb1f8c417f57826c578b5aea6">More...</a><br/></td></tr>
<tr class="separator:ga2e3dc2abb1f8c417f57826c578b5aea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0eff505d8bb5f39bd701be19fbdaac5"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac0eff505d8bb5f39bd701be19fbdaac5"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:gac0eff505d8bb5f39bd701be19fbdaac5"><td class="memTemplItemLeft" align="right" valign="top">constexpr result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gac0eff505d8bb5f39bd701be19fbdaac5">boost::outcome::v1_xxx::as_result</a> (option&lt; T &gt; &amp;&amp;v)</td></tr>
<tr class="memdesc:gac0eff505d8bb5f39bd701be19fbdaac5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a result from an option. <br/></td></tr>
<tr class="separator:gac0eff505d8bb5f39bd701be19fbdaac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45531f0b41d78b899d1f6d286842eb8a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga45531f0b41d78b899d1f6d286842eb8a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga45531f0b41d78b899d1f6d286842eb8a"><td class="memTemplItemLeft" align="right" valign="top">constexpr result&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga45531f0b41d78b899d1f6d286842eb8a">boost::outcome::v1_xxx::as_result</a> (const option&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga45531f0b41d78b899d1f6d286842eb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a result from an option. <br/></td></tr>
<tr class="separator:ga45531f0b41d78b899d1f6d286842eb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31623e855d816d8be8b796107e29d4f7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga31623e855d816d8be8b796107e29d4f7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ga31623e855d816d8be8b796107e29d4f7"><td class="memTemplItemLeft" align="right" valign="top">outcome&lt; void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga31623e855d816d8be8b796107e29d4f7">boost::outcome::v1_xxx::as_void</a> (const outcome&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ga31623e855d816d8be8b796107e29d4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a void outcome from an input outcome, forwarding any emptiness, error or exception. <br/></td></tr>
<tr class="separator:ga31623e855d816d8be8b796107e29d4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ffab91838224f042fe7ed1b108e5ad7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga2ffab91838224f042fe7ed1b108e5ad7"></a>
template&lt;class Impl &gt; </td></tr>
<tr class="memitem:ga2ffab91838224f042fe7ed1b108e5ad7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga2ffab91838224f042fe7ed1b108e5ad7">std::swap</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">boost::outcome::v1_xxx::basic_monad</a>&lt; Impl &gt; &amp;a, <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">boost::outcome::v1_xxx::basic_monad</a>&lt; Impl &gt; &amp;b)</td></tr>
<tr class="memdesc:ga2ffab91838224f042fe7ed1b108e5ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialise swap for basic_monad. <br/></td></tr>
<tr class="separator:ga2ffab91838224f042fe7ed1b108e5ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93fd76af06145e1e6544d9c27bd080d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga93fd76af06145e1e6544d9c27bd080d0"></a>
constexpr exception_t exception&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__monad.html#ga93fd76af06145e1e6544d9c27bd080d0">boost::outcome::v1_xxx::exception_t</a> ()</td></tr>
<tr class="memdesc:ga93fd76af06145e1e6544d9c27bd080d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable of type <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1exception__t.html" title="Type tag for an excepted monad. ">exception_t</a>. <br/></td></tr>
<tr class="separator:ga93fd76af06145e1e6544d9c27bd080d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70474a7831a5c7c7f045043ba554ff5a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga70474a7831a5c7c7f045043ba554ff5a"></a>
template&lt;class _value_type , class _error_type , class _exception_type &gt; </td></tr>
<tr class="memitem:ga70474a7831a5c7c7f045043ba554ff5a"><td class="memTemplItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#ga70474a7831a5c7c7f045043ba554ff5a">std::operator&gt;&gt;</a> (istream &amp;s, <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1value__storage.html">boost::outcome::v1_xxx::value_storage</a>&lt; _value_type, _error_type, _exception_type &gt; &amp;v)</td></tr>
<tr class="memdesc:ga70474a7831a5c7c7f045043ba554ff5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deserialise a value_storage value_type (only value_type) <br/></td></tr>
<tr class="separator:ga70474a7831a5c7c7f045043ba554ff5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6f91d60f7f8d66cc60aec27fd61166a"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab6f91d60f7f8d66cc60aec27fd61166a"></a>
template&lt;class _value_type &gt; </td></tr>
<tr class="memitem:gab6f91d60f7f8d66cc60aec27fd61166a"><td class="memTemplItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__monad.html#gab6f91d60f7f8d66cc60aec27fd61166a">std::operator&lt;&lt;</a> (ostream &amp;s, const <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1value__storage.html">boost::outcome::v1_xxx::value_storage</a>&lt; _value_type, void, void &gt; &amp;v)</td></tr>
<tr class="memdesc:gab6f91d60f7f8d66cc60aec27fd61166a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialise a value_storage. Mostly useful for debug printing. <br/></td></tr>
<tr class="separator:gab6f91d60f7f8d66cc60aec27fd61166a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga68770961e182715930ad64ca244b645e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga68770961e182715930ad64ca244b645e"></a>
constexpr empty_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__monad.html#ga68770961e182715930ad64ca244b645e">boost::outcome::v1_xxx::empty</a> = empty_t()</td></tr>
<tr class="memdesc:ga68770961e182715930ad64ca244b645e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable of type <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1empty__t.html" title="Type tag for an empty monad. ">empty_t</a>. <br/></td></tr>
<tr class="separator:ga68770961e182715930ad64ca244b645e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1740f6220ea9c91b5fd5a9263c6b316"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gab1740f6220ea9c91b5fd5a9263c6b316"></a>
constexpr value_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316">boost::outcome::v1_xxx::value</a> = value_t()</td></tr>
<tr class="memdesc:gab1740f6220ea9c91b5fd5a9263c6b316"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable of type <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1value__t.html" title="Type tag for a valued monad. ">value_t</a>. <br/></td></tr>
<tr class="separator:gab1740f6220ea9c91b5fd5a9263c6b316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a1a8470c4efc3a52412f3ecc79a0060"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1a1a8470c4efc3a52412f3ecc79a0060"></a>
constexpr error_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__monad.html#ga1a1a8470c4efc3a52412f3ecc79a0060">boost::outcome::v1_xxx::error</a> = error_t()</td></tr>
<tr class="memdesc:ga1a1a8470c4efc3a52412f3ecc79a0060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable of type <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1error__t.html" title="Type tag for an errored monad. ">error_t</a>. <br/></td></tr>
<tr class="separator:ga1a1a8470c4efc3a52412f3ecc79a0060"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Predefined basic_monad implementations: </p>
<dl>
<dt><code>outcome&lt;R&gt;</code> </dt>
<dd><p class="startdd">Can hold a fixed variant list of empty, a type <code>R</code>, a lightweight <code>std::error_code</code> or a heavier <code>std::exception_ptr</code> at a space cost of <code>max(24, sizeof(R)+8)</code>. This corresponds to <code>tribool::unknown</code>, <code>tribool::true_</code>, <code>tribool::false_</code> and <code>tribool::false_</code> respectively.</p>
<p><b>Pros:</b> Covers all bases. You can return error codes for normal errors, exception pointers for exceptional events.</p>
<p class="enddd"><b>Cons:</b> Because of the potential <code>exception_ptr</code> which is an atomic fence, compilers tend to generate code bloat especially where the potential states of an outcome are unknown (e.g. it is being returned from an extern function).  </p>
</dd>
<dt><code>result&lt;R&gt;</code> </dt>
<dd><p class="startdd">Can hold a fixed variant list of empty, a type <code>R</code> or a lightweight <code>std::error_code</code> at a space cost of <code>max(24, sizeof(R)+8)</code>. This corresponds to <code>tribool::unknown</code>, <code>tribool::true_</code> and <code>tribool::false_</code> respectively. This specialisation looks deliberately like Rust's <code>Result&lt;T&gt;</code>.</p>
<p><b>Pros:</b> Much lighter weight than an outcome, plus it will have a trivial destructor if <code>R</code> has a trivial destructor (the compiler and STL can shortcut many operations when there is a trivial destructor). Code bloat is minimal except on the Dinkumware STL which makes fetching error categories an atomic fence, however this is usually a one off cost. clang and GCC do an excellent job optimising code using <code>result&lt;R&gt;</code> often down to zero overhead, unless using the Dinkumware STL.</p>
<p class="enddd"><b>Cons:</b> Error code constructors must consume an error category instance which is a runtime only input. <code>result&lt;T&gt;</code> therefore cannot be used in a constexpr evaluation context.  </p>
</dd>
<dt><code>option&lt;R&gt;</code> </dt>
<dd><p class="startdd">Can hold a fixed variant list of empty or a type <code>R</code> at a space cost of <code>sizeof(value_storage&lt;R&gt;)</code> which is usually <code>sizeof(R)+8</code>, but may be smaller if <code>value_storage&lt;R&gt;</code> is specialised e.g. <code>sizeof(option&lt;char&gt;)</code> is just two bytes, and <code>sizeof(option&lt;bool&gt;)</code> and <code>sizeof(option&lt;void&gt;)</code> is just one byte (see note about <code>option&lt;bool&gt;</code> below). This corresponds to <code>tribool::unknown</code> and <code>tribool::true_</code> respectively. This specialisation looks deliberately like Rust's <code>Option&lt;T&gt;</code>.</p>
<p><b>Pros:</b> Can be used in constexpr programming. Compiles down to optimal overhead on all compilers.</p>
<p class="enddd"><b>Cons:</b> Least expressive of the available options.  </p>
</dd>
</dl>
<p>Features:</p>
<ul>
<li>Very lightweight on build times and run times up to the point of zero execution cost and a one to eight byte space overhead. See below for benchmarks. Requires min clang 3.7, GCC 5.0 or VS2015 Update 2.</li>
<li>Just enough monad, nothing more, nothing fancy. Replicates the <code>future&lt;T&gt;</code>, <code>optional&lt;T&gt;</code> and <code>expected&lt;T, E&gt;</code> API, so if you know how to use one of those you already know how to use this.</li>
<li>Enables convenient and easy all-<code>noexcept</code> coding and design, giving you powerful error handling facilities with automatic exception safety.</li>
<li>Works just fine with exceptions and RTTI disabled. You may wish to replace the <code><a class="el" href="config_8hpp.html#a8fefe8516997eb0f7c649834d298044a" title="Redefine to have something else occur when Outcome throws an exception. ">BOOST_OUTCOME_THROW()</a></code> macro with what to do when an exception would have been thrown e.g. trying to get a value from an errored or excepted monad.</li>
<li>Can replace most uses of <code>optional&lt;T&gt;</code> with seamless interop with more expressive forms e.g. <code>outcome&lt;int&gt; != option&lt;int&gt;</code>.</li>
<li>Comprehensive unit testing and validation suite.</li>
<li>Mirrors <code>noexcept</code> and trivial destructiveness of type R.</li>
<li>Type R can have no default constructor, move nor copy.</li>
<li>Works inside a STL container, and type R can be a STL container.</li>
<li>If type R throws during moves, receiving monad is left in empty state having destructing anything it had before. This behaviour, which was considered undesirable for <code>variant&lt;&gt;</code>, is optimal for the compiler's optimiser.</li>
<li>Equivalence and non-equivalence operators provided. These can compare disparate monads.<ul>
<li>Relational operators NOT provided to keep things simple.</li>
</ul>
</li>
<li>You can explicitly cheap convert monads from less expressive to more expressive.</li>
<li>There is a debugging visualiser for basic_monad for VS2015 in doc/boost.outcome.natvis. A visualiser for GDB is forthcoming.</li>
</ul>
<h2>Notes:</h2>
<p>As <code>outcome&lt;R&gt;</code>, <code>result&lt;R&gt;</code> and <code>option&lt;R&gt;</code> are all just <code>basic_monad</code> with different implementation policies, wherever we refer to <code>outcome&lt;R&gt;</code> we mean those three specialisations as well.</p>
<p>Something which might surprise people is that:</p>
<div class="fragment"><div class="line">outcome&lt;std::string&gt; a(<span class="stringliteral">&quot;niall&quot;</span>);</div>
<div class="line">outcome&lt;std::string&gt; b(std::move(a));</div>
<div class="line">BOOST_CHECK(a.has_value());  <span class="comment">// true</span></div>
</div><!-- fragment --><p>Moving an outcome <em>does a move of its underlying contents</em>, so any contents remain at whatever the move constructor for that content leaves things. In other words, a moved from outcome <b>does not</b> become empty, if you want that then call clear().</p>
<p>Be aware that due to packing the bool into the same byte of storage as the empty/value state, <code>option&lt;bool&gt;.get()</code> does not return any reference to the internal store, but provides value returns instead. This also applies to any type enabled for single byte storage using the <code>enable_single_byte_value_storage</code> trait.</p>
<p>So long as you avoid the exception_type code paths (stick with <code>result&lt;R&gt;</code>, <code>option&lt;R&gt;</code>), this implementation will be ideally reduced to as few assembler instructions as possible by most recent compilers [1] which can include exactly zero assembler instructions output. This outcome is therefore identical in terms of execution overhead to using the R type you specify directly - you get the monadic functionality totally free of execution overhead where the compiler is able to reduce it to such.</p>
<p>A similar thing applies to error_type which is a lightweight implementation on most systems. An exception is on VS2015 as the lvalue reference to system_category appears to be constructed via thread safe once routine called "Immortalize", so when you construct an error_type on MSVC you'll force a memory synchronisation during the constructor only. error_types are very cheap to pass around though as they are but an integer and a lvalue ref.</p>
<p>exception_type is also pretty good on anything but MSVC, though never zero assembler instructions. As soon as an exception_type <em>could</em> be created, you'll force out about twenty instructions most of which won't be executed in practice. Unfortunately, MSVC churns out about 2000 assembler instructions as soon as you might touch an exception_type, I've raised this with Microsoft and it looks to be hard for them to fix due to backwards compatibility reasons.</p>
<p>[1]: GCC 5.1 does a perfect job, VS2015 does a good job, clang 3.7 not so great.</p>
<h2>Examples</h2>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> openfile = [](std::string path) noexcept-&gt;outcome&lt;<span class="keywordtype">int</span>&gt;</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> fd;</div>
<div class="line">    <span class="keywordflow">do</span></div>
<div class="line">    {</div>
<div class="line">      fd = BOOST_OUTCOME_POSIX_OPEN(path.c_str(), 0);</div>
<div class="line">    } <span class="keywordflow">while</span>(-1 == fd &amp;&amp; EINTR == errno);</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span>(-1 == fd)</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordtype">int</span> code = errno;</div>
<div class="line">        <span class="comment">// If a temporary failure, this is an expected unexpected outcome</span></div>
<div class="line">        <span class="keywordflow">if</span>(EBUSY == code || EISDIR == code || ELOOP == code || ENOENT == code || ENOTDIR == code || EPERM == code || EACCES == code)</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">return</span> error_code_extended(code, stl11::generic_category());</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// If a non-temporary failure, this is an unexpected outcome</span></div>
<div class="line">        <span class="keywordflow">return</span> std::make_exception_ptr(stl11::system_error(code, stl11::generic_category(), strerror(code)));</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> fd;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span>(...)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Any exception thrown is truly unexpected</span></div>
<div class="line">      <span class="keywordflow">return</span> std::current_exception();</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">  <span class="keyword">auto</span> a = openfile(<span class="stringliteral">&quot;shouldneverexistnotever&quot;</span>);</div>
<div class="line">  BOOST_CHECK(!a);</div>
<div class="line">  BOOST_CHECK(!a.empty());</div>
<div class="line">  BOOST_CHECK(!a.has_value());</div>
<div class="line">  BOOST_CHECK(a.has_exception());</div>
<div class="line">  BOOST_CHECK(a.has_error());</div>
<div class="line">  BOOST_CHECK(a.get_error() == error_code_extended(ENOENT, stl11::generic_category()));</div>
</div><!-- fragment --> <h3>As an alternative to <code>optional&lt;T&gt;</code></h3>
<p>Something not so obvious is that this monad can have an empty state, and therefore can stand in for <code>optional&lt;T&gt;</code> like this:</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span> maybe_getenv = [](<span class="keyword">const</span> <span class="keywordtype">char</span> *n) -&gt; option&lt;const char *&gt; {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *x = std::getenv(n);</div>
<div class="line">    <span class="keywordflow">if</span>(x != <span class="keyword">nullptr</span>)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">return</span> x;</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  };</div>
<div class="line">  <span class="keyword">auto</span> a = maybe_getenv(<span class="stringliteral">&quot;SHOULDNEVEREXIST&quot;</span>);</div>
<div class="line">  BOOST_CHECK(!a);</div>
<div class="line">  BOOST_CHECK_THROW(a.value(), <span class="keyword">const</span> monad_error &amp;);</div>
<div class="line">  BOOST_CHECK(a.value_or(<span class="keyword">nullptr</span>) == <span class="keyword">nullptr</span>);</div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><span class="preprocessor"></span>  <span class="keyword">auto</span> b = maybe_getenv(<span class="stringliteral">&quot;HOMEPATH&quot;</span>);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>  <span class="keyword">auto</span> b = maybe_getenv(<span class="stringliteral">&quot;HOME&quot;</span>);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>  BOOST_CHECK(b);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;$HOME=&quot;</span> &lt;&lt; b.value() &lt;&lt; std::endl;</div>
</div><!-- fragment --><p> The API is actually not too distant from <code>optional&lt;T&gt;</code>, so with a bit of regex find and replace you could use <code>option&lt;T&gt;</code> instead.</p>
<p>The need for <code>basic_monad&lt;T, EC, E&gt;</code> to be able to be empty was to make exception throws by T during copy and move construction lightweight. If that happens, the monad always has empty state afterwards.</p>
<h2>Supplying your own implementations of <code>basic_monad&lt;T, EC, E&gt;</code></h2>
<p>To do this, simply supply a policy type of the following form: </p>
<div class="fragment"><div class="line">  <span class="comment">// An implementation policy for basic_monad</span></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt; <span class="keyword">struct </span>BOOST_OUTCOME_MONAD_POLICY_NAME</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// The final resulting implementation type</span></div>
<div class="line">    <span class="keyword">typedef</span> basic_monad&lt;BOOST_OUTCOME_MONAD_POLICY_NAME&gt; implementation_type;</div>
<div class="line">    <span class="comment">// The value type to use. Can be void to disable.</span></div>
<div class="line">    <span class="keyword">typedef</span> R value_type;</div>
<div class="line"><span class="comment">// The error code type to use. Can be void to disable.</span></div>
<div class="line"><span class="preprocessor">#ifdef BOOST_OUTCOME_MONAD_POLICY_ERROR_TYPE</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keyword">typedef</span> BOOST_OUTCOME_MONAD_POLICY_ERROR_TYPE error_type;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keyword">typedef</span> <span class="keywordtype">void</span> error_type;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span><span class="comment">// The exception pointer type to use. Can be void to disable.</span></div>
<div class="line"><span class="preprocessor">#ifdef BOOST_OUTCOME_MONAD_POLICY_EXCEPTION_TYPE</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keyword">typedef</span> BOOST_OUTCOME_MONAD_POLICY_EXCEPTION_TYPE exception_type;</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="keyword">typedef</span> <span class="keywordtype">void</span> exception_type;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// The base class to use to store state</span></div>
<div class="line">    <span class="keyword">typedef</span> BOOST_OUTCOME_MONAD_POLICY_BASE_NAME&lt;basic_monad_storage&lt;BOOST_OUTCOME_MONAD_POLICY_NAME&gt;, value_type, error_type, exception_type&gt; base;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// The type which basic_monad::rebind&lt;U&gt; should return</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">using</span> rebind = basic_monad&lt;BOOST_OUTCOME_MONAD_POLICY_NAME&lt;U&gt;&gt;;</div>
<div class="line">    <span class="comment">// The type which rebinding myself produces</span></div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt; <span class="keyword">using</span> rebind_policy = BOOST_OUTCOME_MONAD_POLICY_NAME&lt;U&gt;;</div>
<div class="line">  };</div>
</div><!-- fragment --><h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gaf5abc43f8d09588556c4c65b53485c0d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__monad.html#gaf5abc43f8d09588556c4c65b53485c0d">boost::outcome::v1_xxx::monad_errc</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration of the ways in which a monad operation may fail. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggaf5abc43f8d09588556c4c65b53485c0da25621f93230ec01ef6ead2516f3613ce"></a>already_set</em>&#160;</td><td class="fielddoc">
<p>Attempt to store a value into the monad twice. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaf5abc43f8d09588556c4c65b53485c0dac537dcef56fd6ff75592c0220fd3dae1"></a>no_state</em>&#160;</td><td class="fielddoc">
<p>Attempt to use without a state. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggaf5abc43f8d09588556c4c65b53485c0da621bbc00c646a321b70c18a067da2eb2"></a>exception_present</em>&#160;</td><td class="fielddoc">
<p>Attempt to fetch an error state when the monad is in an exceptioned state. </p>
</td></tr>
</table>
<div class="fragment"><div class="line"><a name="l00637"></a><span class="lineno">  637</span>&#160;{</div>
<div class="line"><a name="l00638"></a><span class="lineno">  638</span>&#160;  <a class="code" href="group__monad.html#ggaf5abc43f8d09588556c4c65b53485c0da25621f93230ec01ef6ead2516f3613ce">already_set</a> = 1,        </div>
<div class="line"><a name="l00639"></a><span class="lineno">  639</span>&#160;  <a class="code" href="group__monad.html#ggaf5abc43f8d09588556c4c65b53485c0dac537dcef56fd6ff75592c0220fd3dae1">no_state</a> = 2,           </div>
<div class="line"><a name="l00640"></a><span class="lineno">  640</span>&#160;  <a class="code" href="group__monad.html#ggaf5abc43f8d09588556c4c65b53485c0da621bbc00c646a321b70c18a067da2eb2">exception_present</a> = 3,  </div>
<div class="line"><a name="l00641"></a><span class="lineno">  641</span>&#160;};</div>
<div class="ttc" id="group__monad_html_ggaf5abc43f8d09588556c4c65b53485c0da25621f93230ec01ef6ead2516f3613ce"><div class="ttname"><a href="group__monad.html#ggaf5abc43f8d09588556c4c65b53485c0da25621f93230ec01ef6ead2516f3613ce">boost::outcome::v1_xxx::monad_errc::already_set</a></div><div class="ttdoc">Attempt to store a value into the monad twice. </div></div>
<div class="ttc" id="group__monad_html_ggaf5abc43f8d09588556c4c65b53485c0da621bbc00c646a321b70c18a067da2eb2"><div class="ttname"><a href="group__monad.html#ggaf5abc43f8d09588556c4c65b53485c0da621bbc00c646a321b70c18a067da2eb2">boost::outcome::v1_xxx::monad_errc::exception_present</a></div><div class="ttdoc">Attempt to fetch an error state when the monad is in an exceptioned state. </div></div>
<div class="ttc" id="group__monad_html_ggaf5abc43f8d09588556c4c65b53485c0dac537dcef56fd6ff75592c0220fd3dae1"><div class="ttname"><a href="group__monad.html#ggaf5abc43f8d09588556c4c65b53485c0dac537dcef56fd6ff75592c0220fd3dae1">boost::outcome::v1_xxx::monad_errc::no_state</a></div><div class="ttdoc">Attempt to use without a state. </div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae530c39aba6722190036aaeb7bf411f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr outcome&lt; T &gt; boost::outcome::v1_xxx::as_outcome </td>
          <td>(</td>
          <td class="paramtype">result&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an outcome from a result. </p>
<p>Makes an outcome from an option. </p>
<div class="fragment"><div class="line"><a name="l02172"></a><span class="lineno"> 2172</span>&#160;{</div>
<div class="line"><a name="l02173"></a><span class="lineno"> 2173</span>&#160;  <span class="keywordflow">return</span> outcome&lt;T&gt;(std::move(v));</div>
<div class="line"><a name="l02174"></a><span class="lineno"> 2174</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ga2e3dc2abb1f8c417f57826c578b5aea6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr outcome&lt; T &gt; boost::outcome::v1_xxx::as_outcome </td>
          <td>(</td>
          <td class="paramtype">const result&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an outcome from a result. </p>
<p>Makes an outcome from an option. </p>
<div class="fragment"><div class="line"><a name="l02177"></a><span class="lineno"> 2177</span>&#160;{</div>
<div class="line"><a name="l02178"></a><span class="lineno"> 2178</span>&#160;  <span class="keywordflow">return</span> outcome&lt;T&gt;(v);</div>
<div class="line"><a name="l02179"></a><span class="lineno"> 2179</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
