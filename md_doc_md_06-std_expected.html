<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>boost.outcome: Outcome and the upcoming C++ 20 std::expected&lt;T, E&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_md_06-std_expected.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Outcome and the upcoming C++ 20 std::expected&lt;T, E&gt; </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="std-expected"></a> C++ 17 isn't finished at the time of writing, but we are very sure that at least <a href="http://en.cppreference.com/w/cpp/utility/optional"><code>std::optional&lt;T&gt;</code></a> will be in it. It remains to be seen if LEWG's <code>expected&lt;T, E&gt;</code> will make it, if not then most STL implementations will probably ship an implementation as an experimental and if your STL does not, there is always the reference implementation at <a href="https://github.com/viboes/std-make">https://github.com/viboes/std-make</a> which ought to work on any C++ 14 compiler.</p>
<dl class="section note"><dt>Note</dt><dd>LEWG is the C++ standard committee's Library Evolution Working Group. They work on improving the C++ standard runtime library which will gain <code>std::optional&lt;T&gt;</code> and <code>std::variant&lt;...&gt;</code> in C++ 17 and probably <code>std::expected&lt;T, E&gt;</code> in C++ 20. The following discussion is based on <code>expected&lt;T, E&gt;</code> as detailed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0323r1.pdf">P0323R1</a> which is the latest LEWG proposal paper at the time of writing (Nov 2016) and indeed one where <code>expected&lt;T, E&gt;</code> was pared down significantly from its original proposal. It should be noted that C++ may yet end up adopting something quite different, though given how long <code>expected&lt;T, E&gt;</code> has been around by now, and how well it fits nicely between <code>optional&lt;T&gt;</code> and <code>variant&lt;T, E&gt;</code>, it would seem unlikely. <code>expected&lt;T, E&gt;</code> is intended as a strict superset of <code>optional&lt;T&gt;</code> with aspects of <a href="http://en.cppreference.com/w/cpp/utility/variant"><code>std::variant&lt;T, E&gt;</code></a>, indeed much of LEWG's remaining work on the proposal is on reconciling the small remaining semantic differences between <code>expected&lt;T, nullopt_t&gt;</code> and <code>optional&lt;T&gt;</code>.</dd></dl>
<p>The original prototype Boost.Expected library was a large and very complex beastie - I was fortunate to be employed on a contract in 2015 where I saw it deployed at scale into a large C++ codebase. Indeed, much of what I witnessed there had a big impact in how Outcome ended up being designed. P0323R1 proposes an enormously simplified implementation which ought to fix all of the showstopper problems with the original that I am aware of, and P0323R1's reduced <code>expected&lt;T, E&gt;</code> has ended up having a huge resemblance to Outcome in every day usage. It is heartening that the committee have made most of the changes I also made in Outcome, as that suggests I am on the right track. Outcome's slightly different design still contributes a lot of value for the specific use of error handling in my opinion, as we shall hopefully see next.</p>
<p>LEWG's proposed <code>expected&lt;T, E&gt;</code> as per P0323R1 can hold either an expected value of type <code>T</code> or an unexpected value of type <code>E</code>. Like <code>variant&lt;T, E&gt;</code>, <code>expected&lt;T, E&gt;</code> is a discriminated union storing either <code>T</code> or <code>E</code> in the same storage space, but unlike the variant, expected treats the <code>T</code> as a positive thing (fetchable via a <code>.<a class="el" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316" title="Variable of type value_t. ">value()</a></code>) and <code>E</code> as a negative thing (fetchable via an <code>.<a class="el" href="group__monad.html#ga1a1a8470c4efc3a52412f3ecc79a0060" title="Variable of type error_t. ">error()</a></code>). Because <code>expected&lt;T, E&gt;</code> provides an "almost never empty" guarantee similar to variant, it currently requires type <code>E</code> to be nothrow copy and move constructible and assignable. Expected is a bit less intuitive to use than optional, but its rules are straightforward: <code>expected&lt;T, E&gt;</code> will greedily and implicitly construct from any type from which a <code>T</code> can be constructed, after which it will hold an instance of <code>T</code>. If you wish to construct an <code>expected&lt;T, E&gt;</code> holding an instance of unexpected <code>E</code>, you need to feed it an <code>unexpected&lt;E&gt;</code> which is type sugar to indicate you want an instance of <code>E</code> implicitly converted into an <code>expected&lt;T, E&gt;</code>. As with everything else in C++ 11 onwards, there is a <code>make_expected(T)</code> and a <code>make_unexpected(E)</code> which do any type deduction and conversion for you into the right contents of <code>expected&lt;T, E&gt;</code>.</p>
<p>All this sounds a bit complex, but really it's much easier to use. Here is a non-throwing implementation of the tutorial's <code>openfile()</code> based on <code>expected&lt;T, E&gt;</code></p>
<div class="fragment"><div class="line"><span class="comment">// Returns the expected opened handle on success, or an unexpected cause of failure</span></div>
<div class="line">std::expected&lt;handle_ref, std::error_code&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga03e1e619a559e7f336621b1092e28527">std::make_unexpected</a>(std::error_code(errno, std::system_category());</div>
<div class="line">  }</div>
<div class="line">  std::error_code ec;</div>
<div class="line">  <span class="keyword">auto</span> *p = <span class="keyword">new</span>(std::nothrow) some_derived_handle_implementation(fd, ec);</div>
<div class="line">  <span class="keywordflow">if</span>(p == <span class="keyword">nullptr</span>)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga03e1e619a559e7f336621b1092e28527">std::make_unexpected</a>(<a class="code" href="group__monad.html#gab6204dd7620b0e495220e76988359589">std::make_error_code</a>(std::errc::not_enough_memory));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">delete</span> p;</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga03e1e619a559e7f336621b1092e28527">std::make_unexpected</a>(std::move(ec));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> handle_ref(p);  <span class="comment">// expected&lt;&gt; takes implicit conversion from type T</span></div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">auto fh_ = openfile(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(!fh_ &amp;&amp; fh_.error() != std::errc::no_such_file_or_directory)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// This is serious, abort</span></div>
<div class="line">  <span class="keywordflow">throw</span> std::system_error(std::move(fh_.error()));</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span>(fh_)</div>
<div class="line">{</div>
<div class="line">  handle_ref fh = std::move(fh_.value());</div>
<div class="line">  fh-&gt;read(... etc</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The prototype Boost.Expected library and the P0323R1 reference library actually declares <code>expected&lt;T, E = std::exception_ptr&gt;</code> as the default despite that P0323R1 specifies <code>expected&lt;T, E = std::error_condition&gt;</code> as the default. I have no idea why LEWG would use error condition as a default, such a default would lose information for users so I have assumed they'll change it to error code soon.</dd></dl>
<p><br/>
</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="design_differences"></a>
Design differences between Expected and Outcome</h1>
<p>After all the documentation to date, one might think that Outcome and Expected are interchangeable. They do cover substantially similar ground and in the semantic sense they are the same thing, however where Expected is intended as a generic fundamental type useful for many things, Outcome is specifically intended as a universal error handling framework capable of lossless propagation of all possible kinds of C++ error with the least possible runtime and compile time overhead. It could be considered as a "fixed feature" Expected specialised for the use case of handling errors only. Here are the exact differences:</p>
<ol type="1">
<li>Outcome is designed specifically for returning output from function calls in low latency/very high performance C++ of the kind <a href="https://groups.google.com/a/isocpp.org/forum/#!forum/sg14">WG21 SG14</a> is working upon. It therefore works perfectly with exceptions and RTTI disabled and its CI compiles per commit typical use cases of Outcomes and counts the assembler operations emitted by GCC, clang and MSVC to ensure code bloat is kept optimally minimal. On all recent GCCs and clangs, if the compiler's optimiser can infer the state of an outcome, <b>all runtime overhead due to the outcome ought to be completely eliminated</b> (sans optimiser bugs which appear from time to time). This means for inlined code if you return a <code>result&lt;T&gt;(T(...))</code>, the compiler will generate identical code as if you had returned a <code>T(...)</code> directly.</li>
<li>Outcome's actual core implementation is <code>boost::outcome::basic_monad&lt;Policy&lt;T, EC, E&gt;&gt;</code> with these convenience typedefs: <div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> <a class="code" href="group__monad.html#gaab2ff6220205017226794529c863b336">outcome</a> = basic_monad&lt; monad_policy&lt;T, std::error_code, std::exception_ptr&gt;&gt;;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> <a class="code" href="group__monad.html#ga91e1fe11dbebea15458d882d078d6eb5">result</a>  = basic_monad&lt;result_policy&lt;T, std::error_code, void&gt;&gt;;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> <a class="code" href="group__monad.html#ga0d0fd5ca15cb339df9aa8e829a8ea5e0">option</a>  = basic_monad&lt;option_policy&lt;T, void, void&gt;&gt;;</div>
</div><!-- fragment --> You can use any type <code>EC</code> or <code>E</code> you like so long as they act as if a <code>std::error_code</code> and a <code>std::exception_ptr</code> respectively e.g. <code>boost::error_code</code> and <code>boost::exception_ptr</code>. <b>Unlike</b> the <code>E</code> in <code>expected&lt;T, E&gt;</code>, Outcome hard codes the model of <code>EC</code> and <code>E</code> in stone, so they <em>must</em> provide at least the same APIs and behaviours as an error code and an exception pointer or be <code>void</code>, in which case the specialisation doesn't provide the ability to store an instance of that type.</li>
<li>As suggested by the presence of an <code>option&lt;T&gt;</code> convenience typedef, all <code>basic_monad&lt;&gt;</code> instances have a formal empty state. There is no <a href="http://en.cppreference.com/w/cpp/utility/variant/valueless_by_exception">"almost never empty" guarantee</a> which enables sane semantics when exceptions are disabled and also to not confuse the compiler's optimiser with complex potential branches in move construction (which can cause the optimiser to give up prematurely). It sidesteps handling the problem of move assignment throwing an exception, in which case Outcomes are left in an empty state. It ensures all <code>basic_monad&lt;&gt;</code> are constexpr default constructible. If you attempt to get a value from an empty Outcome, the compiler will throw an <code>outcome::monad_error</code> if exceptions are available, else it calls the macro <code><a class="el" href="config_8hpp.html#a10f1ea9f0f1205c24e106fb77cee19c3" title="Predefine to have something else occur when Outcome throws a monad_error due to being asked to do som...">BOOST_OUTCOME_THROW_MONAD_ERROR()</a></code> which by default dumps a stack trace and terminates the process.</li>
<li><p class="startli">Like <code>expected&lt;T, E&gt;</code>, <b>explicit</b> conversion exists from any <code>basic_monad&lt;Policy&lt;T1, EC1, E1&gt;&gt;</code> to any <code>basic_monad&lt;Policy&lt;T2, EC2, E2&gt;&gt;</code> if all of <code>T2</code>, <code>EC2</code> and <code>E2</code> are constructible from <code>T1</code>, <code>EC1</code> and <code>E1</code> respectively. <code>basic_monad&lt;Policy&lt;void&gt;&gt;</code> has special significance: you can always <b>implicitly</b> safely construct any arbitrary <code>basic_monad&lt;Policy&lt;T&gt;&gt;</code> from any <code>basic_monad&lt;Policy&lt;void&gt;&gt;</code> which is always a lossless operation. The rules are as follows:</p>
<ol type="a">
<li>If input <code>basic_monad&lt;Policy&lt;void&gt;&gt;</code> is empty, <code>basic_monad&lt;Policy&lt;T&gt;&gt;</code> is empty.</li>
<li>If input <code>basic_monad&lt;Policy&lt;void&gt;&gt;</code> has value, <code>basic_monad&lt;Policy&lt;T&gt;&gt;</code> is a default constructed <code>T</code>.</li>
<li>If input <code>basic_monad&lt;Policy&lt;void&gt;&gt;</code> has an error, <code>basic_monad&lt;Policy&lt;T&gt;&gt;</code> has the same error either copy or move constructed as appropriate.</li>
<li>If input <code>basic_monad&lt;Policy&lt;void&gt;&gt;</code> has an exception, <code>basic_monad&lt;Policy&lt;T&gt;&gt;</code> has the same exception either copy or move constructed as appropriate.</li>
</ol>
<p class="startli">This is Outcome's implementation of the <code>unexpected&lt;E&gt;</code> type sugar used by Expected to initialise an <code>expected&lt;T, E&gt;</code> with an <code>E</code>. In Outcome, returning a void Outcome with the error or exception you want (or better, use the <code>make_errored_result&lt;&gt;</code>, <code>make_errored_outcome&lt;&gt;</code> or <code>make_exceptional_outcome&lt;&gt;</code> free functions) will be implicitly converted into whatever type of Outcome you wish with the errored or excepted state.</p>
</li>
<li>Types <code>T</code>, <code>EC</code> and <code>E</code> cannot be the same nor be constructible from one another, and this is enforced by static assertion at compile time. This prevents pointless confusion and maintenance difficulty (if you really, really need to return error codes or exception pointers as <code>T</code>, wrap them in a thin type wrapper).</li>
<li>You can explicitly convert from any less representative <code>basic_monad&lt;&gt;</code> to any more representative form because that is always a loss free, non-throwing operation (and usually entirely eliminated by the compiler at runtime, if it can it will simply treat the same storage differently as if by <code>static_cast&lt;&gt;</code>). This is because it is expected that lowest level code will return <code>option&lt;T&gt;</code> and <code>result&lt;T&gt;</code> and higher level code will return <code>outcome&lt;T&gt;</code>, so this makes for seamless up-conversion as you move further away from low level code. This also lets you return a <code>result&lt;void&gt;</code> with an error code and it'll auto upconvert to any <code>outcome&lt;T&gt;</code>.</li>
<li>For the most part, <code>expected&lt;T, std::error_code&gt;</code> and <code>outcome::result&lt;T&gt;</code> ought to be close to interchangeable in most use cases, and could be configurably template alias swappable in most code. There is one glaring exception however, and that is that a default constructed Outcome is <b>empty</b>, not to a default constructed <code>T</code> which makes sense given the formal empty state.</li>
<li>Outcomes implement equality/non-equality operators, but not ordering comparison nor hash operations. This is due to <a href="https://akrzemi1.wordpress.com/2014/12/02/a-gotcha-with-optional/">https://akrzemi1.wordpress.com/2014/12/02/a-gotcha-with-optional/</a> where you either choose implicit construction OR comparison operations or else risk surprising behaviours. That means you can only place Outcomes in non-mapped STL containers. It is trivial for users to supply custom comparison and hashing operations to the STL associative map if they ever really needed to store Outcomes in associative maps.</li>
<li><p class="startli">Finally, Outcome goes out of its way to be as cheap on compile time as possible by having the compiler do as little work as possible if not optimising. A lot of the hard coded rigidity above stems from systematically avoiding, whenever possible, metaprogramming, SFINAE, instantiation of helper types during deduction, or doing anything which would cause the compiler to not use <code>O(1)</code> constant time operations during non-optimising compilation. I have also found empirically that there is also a useful side effect of this simplicity of implementation on helping the compiler's optimiser "to do the right thing" by eliminating assembler generated when facing real world use cases.</p>
<p class="startli">The reason for this minimum compile time load approach was due to my work experience with original prototype Boost.Expected in 2015 where we saw large increases in compile times once Expected was deployed at scale - remember <em>every single function</em> is returning an instance of one of these and much branch logic is working with them in every function, potentially instantiating lots of shim and helper deduction and introspection types each time. P0323R1 Expected removes a large chunk of metaprogrammed functionality, specifically the monadic operations which should help a great deal. Nevertheless, from my best reading, P0323R1 Expected still demands more from the compiler than Outcome does. Deploying Outcome into a large C++ codebase ought to have as minimal a compile time impact as possible for a variant implementation, something which matters on code bases heading into the tens of millions of lines like many potential low latency/high performance users will have. </p>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
