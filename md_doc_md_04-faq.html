<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>boost.outcome: Frequently Asked Questions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_md_04-faq.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Frequently Asked Questions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="faq"></a> </p>
<h1><a class="anchor" id="dontlike"></a>
Hard coding error_code and exception_ptr is incredibly restrictive and ruins Outcome for</h1>
<p>me. Can you not do that please (i.e. make it more like expected&lt;T, E&gt; with its arbitrary type E)?</p>
<p>Outcome isn't a direct substitute for Expected per se. It can substitute for Expected's default configuration of E = std::error_code and because it's less configurable and less flexible than Expected, we can achieve much tighter assembler output by the compiler. It's a tradeoff - Outcome imposes more restrictions but gives you faster, tighter, more predictable code. Expected is the STL primitive useful for a wide variety of tasks, not just error handling.</p>
<p>However much of the opposition to the hard coded error type is due to not realising how extended <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> is. Above and beyond the integer code and category that <code>error_code</code> provides, <code>error_code_extended</code>'s constructor adds:</p>
<ul>
<li>Arbitrary <code>const char *</code> string describing the error specifically. This string is copied and without allocating memory, so you can construct your specific description on the stack without using memory allocation and feed it to a newly constructed extended error code again without allocating memory. This makes error handling performance predictable.</li>
<li>Two arbitrary unsigned integers. These could be fused into a <code>void *</code>, up to you.</li>
<li>You can ask for a stack backtrace to be taken, thus allowing identification of what code sequence resulted in the error. This also does not allocate memory.</li>
</ul>
<p>To make using this extended functionality even easier, in the <a class="el" href="md_doc_md_02-quickstart.html#quickstart">Quick start</a> synopsis you may have noticed that the <code>make_errored_*()</code> functions accept an optional <code>const char *</code> string. This is simply fed to <code>error_code_extended</code>'s constructor. If Outcome ever converts a C++ exception into an error code for you e.g. through you using <code>BOOST_OUTCOME_CATCH_EXCEPTION_TO_RESULT</code>, the conversion always feeds the exception's <code>what()</code> as the extended string description so no information is lost.</p>
<dl class="section warning"><dt>Warning</dt><dd>The extended information is stored in a global threadsafe ringbuffer. It will get garbage collected at some point when the ring buffer wraps. The garbage collection is not synchronised with use of that data, so there is small chance that the extended data will get overwritten in mid use if you leave it too long between the error code being created and making use of its extended data. You should therefore endeavour to transfer the extended error code information into allocated memory as soon as you practically can (or increase the size of the ring buffer, this is very easy, examine the source code).</dd></dl>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="custom_enum"></a>
I want to use a custom enum as the error type, not an error_code!</h1>
<p>C++ 11 already has you covered. The <a href="http://en.cppreference.com/w/cpp/error/error_code"><code>std::error_code</code></a>, <a href="http://en.cppreference.com/w/cpp/error/error_condition"><code>std::error_condition</code></a> and <a href="http://en.cppreference.com/w/cpp/error/error_category"><code>std::error_category</code></a> STL types let you define a custom error code category for any custom enum or custom integer error code domain.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="error_chains"></a>
How do I implement chains of errors to transport errors happening whilst handling</h1>
<p>another error?</p>
<p>C++ 11 already has you covered. <a href="http://en.cppreference.com/w/cpp/error/nested_exception"><code>std::nested_exception</code></a> lets you nest exceptions of arbitrary types within each other. It returns a standard <code>std::exception_ptr</code> so Outcome won't even know.</p>
<p>If that's too heavyweight for you, <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> lets you attach an arbitrary pointer (via two unsigned integers) to an error code. You could use this to chain error codes, though note that the extended error code information can be garbage collected at any time so you'll need your own method of cleaning up.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="outcome_vs_result"></a>
When should I use a result&lt;T&gt; instead of an outcome&lt;T&gt;?</h1>
<p><code>outcome&lt;T&gt;</code> has the potential to carry a <code>std::exception_ptr</code> which is implemented by any STL I can think of as something very similar to a <code>std::shared_ptr</code> i.e. it uses atomics to manage the reference count. Atomics are unavoidably a <em>compiler fence</em> i.e. the compiler <b>must</b> emit code at the point of the fence. Outcome has been very carefully written to let the compiler's optimiser <em>not</em> emit code thus leading to its stellar low runtime overhead. Whilst recent versions of GCC and clang seem reasonably good at eliding compiler fences caused by use of atomics in <code>std::exception_ptr</code> when the compiler is absolutely sure that no <code>std::exception_ptr</code> can be transported, where there is doubt the compiler has no choice but to generate a lot more assembler to cover all the possible outcomes. <code>result&lt;T&gt;</code> cannot transport a <code>std::exception_ptr</code> and therefore doesn't force the compiler to generate output (except unfortunately on the Dinkumware STL where fetching a STL error category e.g. <code>std::generic_category()</code> uses atomics).</p>
<p>So in short, always use <code>result&lt;T&gt;</code> instead of <code>outcome&lt;T&gt;</code> where doing so does not impact negatively on your codebase, and remember one bit of your code can use <code>result&lt;T&gt;</code> because it'll auto upconvert to an <code>outcome&lt;T&gt;</code> when needed.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="result_vs_outcome"></a>
When should I use Outcome instead of expected&lt;T, E&gt;?</h1>
<p>The main reason to use an <code>outcome&lt;T&gt;</code> is in the "sea of noexcept" design pattern where implementations may throw exceptions internally, but all public extern APIs are always noexcept. <code>outcome&lt;T&gt;</code> provides a lossless method of exporting the thrown exception but without loading the programmer with dealing with unexpected control flow reversal, thus helping the programmer write correct exception safe code faster.</p>
<p>One can implement the "exceptions are exceptional" design pattern easily with the standards proposed <code>expected&lt;T, E&gt;</code>: expected errors are returned via <code>expected&lt;T, E&gt; = E</code> and aborting errors are returned via an exception throw. However the role where using <code>outcome&lt;T&gt;</code> really shines is in the "exceptions
are exceptional" combined with "sea of noexcept" design pattern where the errored state means an expected error which was handled inline, but the exceptioned state means an operation was aborted, yet the programmer still can easily write exception safe forward-only-execution code not having to worry about unexpected control flow inversion. This is where using Outcome adds significant value over using Expected.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="examples_of_use"></a>
Are there some real world code bases using Outcome I can study?</h1>
<p>The main reason I designed and wrote Outcome was to implement a universal error handling framework which could express <em>in the minimum possible overhead</em>, and without losing information, the many C++ error handling design patterns possible, and even more importantly that individual libraries could use the design pattern which best suited them whilst seamlessly interoperating with other libraries using different error handling designs. To go into a bit more detail:</p>
<ul>
<li>Proposed <a href="https://ned14.github.io/boost.afio/">Boost.AFIO v2</a> is a very low level very thin file i/o and filesystem library which sits just above the raw kernel syscalls. Throwing exceptions in such a library is overkill, so AFIO v2 uses the "sea of noexcept" design pattern both in its public API and in its internal implementation (i.e. it doesn't use C++ exceptions at all).</li>
<li>Proposed <a href="https://github.com/ned14/boost.kerneltest">Boost.KernelTest</a> is a kernel based testing infrastructure which uses Outcomes as the storage for each kernel permutation run in its permutation tables of preconditions, postconditions, parameters and outcomes. KernelTest itself is written using the "exceptions are exceptional" design pattern where expected errors are returned via outcomes but unexpected errors which abort the test use thrown exceptions which are collected into <code>outcome&lt;T&gt;</code>'s. AFIO v2's test suite is written using KernelTest.</li>
<li>Planned Boost.BLOBStore will be a versioned, ACID transactional key to BLOB store written using AFIO v2 which will use both the "sea of noexcept" and the "exceptions are exceptional" design patterns together. This allows user supplied callbacks to throw exceptions which aborts the current transaction and for those exceptions to be propagated, if desired, out of BLOBStore whilst the internal implementation of BLOBStore and indeed its public API is all noexcept and never throws exceptions (writing correct filesystem code is hard enough without dealing with unexpected control flow reversal). BLOBStore will also use KernelTest for its test suite. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
