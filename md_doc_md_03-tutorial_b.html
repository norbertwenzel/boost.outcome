<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>boost.outcome: Tutorial part B: Outcome&#39;s outcome&lt;T&gt;, result&lt;T&gt; and option&lt;T&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_md_03-tutorial_b.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial part B: Outcome's outcome&lt;T&gt;, result&lt;T&gt; and option&lt;T&gt; </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#expected_is_bad">Unrestricted use of expected<T, E> is bad practice</a></li>
<li class="level1"><a href="#expected_boilerplate">Unrestricted use of expected<T, E> means typing more boilerplate</a></li>
<li class="level1"><a href="#error_code_extended">Outcome's extended std::error_code</a></li>
<li class="level1"><a href="#outcome_rationale">Where Outcome's outcome<T>, result<T> and option<T> come from</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="tutorial_outcome"></a></p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>This section is not finished yet and may contain inaccurate or incorrect information.</dd></dl>
<p>Outcome provides a number of utility classes useful for ultra lightweight and constant time error handling in C++ 14 and later. One of these is <a class="el" href="md_doc_md_05-faq.html#expected_qoi">a highly conforming expected&lt;T, E&gt; implementation</a> which is currently before the ISO C++ standards Library Evolution Working Group for standardisation. <code>expected&lt;T, E&gt;</code> is a very flexible and generic utility class allowing perhaps too much unwise customisation in the hands of its users, so Outcome also provides a family of more hard coded and deliberately less flexible refinements to <code>expected&lt;T, E&gt;</code> called <code>outcome&lt;T&gt;</code> and <code>result&lt;T&gt;</code> the use of which ought to generate more maintainable code bases and require less typing of boilerplate by the programmer.</p>
<p>This tutorial is therefore split into three parts:</p>
<ol type="1">
<li>The first part (<a class="el" href="md_doc_md_02-tutorial_a.html#tutorial_expected">part A</a>) provides a broad overview of error handling in C++ in general and how the <code>expected&lt;T, E&gt;</code> proposed for standardisation will contribute to that big menu of error handling design patterns available to the C++ programmer. This part isn't relevant to Outcome the library, but places it in context.</li>
<li>The second part (part B, this part) describes why you probably ought to not use unrestricted <code>expected&lt;T, E&gt;</code> in any real world code base and why you ought to use the refinements of <code>outcome&lt;T&gt;</code> or <code>result&lt;T&gt;</code> instead.</li>
<li>The third part (part C) walks you through using Outcome's refinements <code>outcome&lt;T&gt;</code> and <code>result&lt;T&gt;</code>. Usage is very similar to Expected, but with less typing and more convenient extensions.</li>
</ol>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="expected_is_bad"></a>
Unrestricted use of expected&lt;T, E&gt; is bad practice</h1>
<p>Most people very keen on Expected entering C++ will be coming from a Swift or especially Rust background where when you use <code>Result&lt;T, E&gt;</code>, you invariably supply a bespoke enum of error codes for type E like this fragment of Rust:</p>
<div class="fragment"><div class="line">pub <span class="keyword">enum</span> MathError {</div>
<div class="line">  DivisionByZero,</div>
<div class="line">  NegativeLogarithm,</div>
<div class="line">  NegativeSquareRoot,</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">pub type MathResult = Result&lt;f64, MathError&gt;;</div>
</div><!-- fragment --><p>I will tell you now that this is a <b>bad idea</b> in large C++ codebases or in any code expected to be used by others, and you should not do this with <code>expected&lt;T, E&gt;</code>.</p>
<p>The first reason is because C++ 11 brought in an infrastructure from Boost which allows you to <em>non-intrusively</em> mark up <b>any</b> arbitrary third party error code system to tell the C++ standard library about it such that any other C++ code using that system can handle any third party error situation <em>without being recompiled</em> and <em>without losing information</em>. If you refuse to use the C++ 11 standard way of working with error codes, then you are being <b>anti-social</b> to other C++ code and devaluing the experience of anybody else who works with your code. Moreover, it is extremely easy to do the right thing and use the standard C++ 11 infrastructure for error codes, and a worked example follows below.</p>
<p>The second reason is that if everybody goes off and locally defines their own custom error code system, you multiply significantly the number of <code>expected&lt;T, E&gt;</code> permutations which the compiler has to deal with. That means slower compile and link times, just because you couldn't be bothered to use the standard library's infrastructure for error codes. You also force programmers coming later to your code to deal with a multitude of local error code domains which may or may not mean the same thing. Expect a multiplication of lots of little switch statements mapping one small domain of error code to another, all of which must be maintained and parsed by programmers coming later to your codebase. The growing maintenance burden over time is obvious, and a further worked example follows below.</p>
<p>The third reason is that the C++ 11 standard library already provides an enum of the most common error codes for you so you don't feel like going off and reinventing the wheel. It's called <a href="http://en.cppreference.com/w/cpp/error/errc"><code>std::errc</code></a> and it has the following contents:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;system_error&gt;</span>  <span class="comment">// header to bring in this enum</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>std</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">enum class</span> errc</div>
<div class="line">  {</div>
<div class="line">    address_family_not_supported        = EAFNOSUPPORT,</div>
<div class="line">    address_in_use                      = EADDRINUSE,</div>
<div class="line">    address_not_available               = EADDRNOTAVAIL,</div>
<div class="line">    already_connected                   = EISCONN,</div>
<div class="line">    argument_list_too_long              = E2BIG,</div>
<div class="line">    argument_out_of_domain              = EDOM,</div>
<div class="line">    bad_address                         = EFAULT,</div>
<div class="line">    bad_file_descriptor                 = EBADF,</div>
<div class="line">    bad_message                         = EBADMSG,</div>
<div class="line">    broken_pipe                         = EPIPE,</div>
<div class="line">    connection_aborted                  = ECONNABORTED,</div>
<div class="line">    connection_already_in_progress      = EALREADY,</div>
<div class="line">    connection_refused                  = ECONNREFUSED,</div>
<div class="line">    connection_reset                    = ECONNRESET,</div>
<div class="line">    cross_device_link                   = EXDEV,</div>
<div class="line">    destination_address_required        = EDESTADDRREQ,</div>
<div class="line">    device_or_resource_busy             = EBUSY,</div>
<div class="line">    directory_not_empty                 = ENOTEMPTY,</div>
<div class="line">    executable_format_error             = ENOEXEC,</div>
<div class="line">    file_exists                         = EEXIST,</div>
<div class="line">    file_too_large                      = EFBIG,</div>
<div class="line">    filename_too_long                   = ENAMETOOLONG,</div>
<div class="line">    function_not_supported              = ENOSYS,</div>
<div class="line">    host_unreachable                    = EHOSTUNREACH,</div>
<div class="line">    identifier_removed                  = EIDRM,</div>
<div class="line">    illegal_byte_sequence               = EILSEQ,</div>
<div class="line">    inappropriate_io_control_operation  = ENOTTY,</div>
<div class="line">    interrupted                         = EINTR,</div>
<div class="line">    invalid_argument                    = EINVAL,</div>
<div class="line">    invalid_seek                        = ESPIPE,</div>
<div class="line">    io_error                            = EIO,</div>
<div class="line">    is_a_directory                      = EISDIR,</div>
<div class="line">    message_size                        = EMSGSIZE,</div>
<div class="line">    network_down                        = ENETDOWN,</div>
<div class="line">    network_reset                       = ENETRESET,</div>
<div class="line">    network_unreachable                 = ENETUNREACH,</div>
<div class="line">    no_buffer_space                     = ENOBUFS,</div>
<div class="line">    no_child_process                    = ECHILD,</div>
<div class="line">    no_link                             = ENOLINK,</div>
<div class="line">    no_lock_available                   = ENOLCK,</div>
<div class="line">    no_message_available                = ENODATA,</div>
<div class="line">    no_message                          = ENOMSG,</div>
<div class="line">    no_protocol_option                  = ENOPROTOOPT,</div>
<div class="line">    no_space_on_device                  = ENOSPC,</div>
<div class="line">    no_stream_resources                 = ENOSR,</div>
<div class="line">    no_such_device_or_address           = ENXIO,</div>
<div class="line">    no_such_device                      = ENODEV,</div>
<div class="line">    no_such_file_or_directory           = ENOENT,</div>
<div class="line">    no_such_process                     = ESRCH,</div>
<div class="line">    not_a_directory                     = ENOTDIR,</div>
<div class="line">    not_a_socket                        = ENOTSOCK,</div>
<div class="line">    not_a_stream                        = ENOSTR,</div>
<div class="line">    not_connected                       = ENOTCONN,</div>
<div class="line">    not_enough_memory                   = ENOMEM,</div>
<div class="line">    not_supported                       = ENOTSUP,</div>
<div class="line">    operation_canceled                  = ECANCELED,</div>
<div class="line">    operation_in_progress               = EINPROGRESS,</div>
<div class="line">    operation_not_permitted             = EPERM,</div>
<div class="line">    operation_not_supported             = EOPNOTSUPP,</div>
<div class="line">    operation_would_block               = EWOULDBLOCK,</div>
<div class="line">    owner_dead                          = EOWNERDEAD,</div>
<div class="line">    permission_denied                   = EACCES,</div>
<div class="line">    protocol_error                      = EPROTO,</div>
<div class="line">    protocol_not_supported              = EPROTONOSUPPORT,</div>
<div class="line">    read_only_file_system               = EROFS,</div>
<div class="line">    resource_deadlock_would_occur       = EDEADLK,</div>
<div class="line">    resource_unavailable_try_again      = EAGAIN,</div>
<div class="line">    result_out_of_range                 = ERANGE,</div>
<div class="line">    state_not_recoverable               = ENOTRECOVERABLE,</div>
<div class="line">    stream_timeout                      = ETIME,</div>
<div class="line">    text_file_busy                      = ETXTBSY,</div>
<div class="line">    timed_out                           = ETIMEDOUT,</div>
<div class="line">    too_many_files_open_in_system       = ENFILE,</div>
<div class="line">    too_many_files_open                 = EMFILE,</div>
<div class="line">    too_many_links                      = EMLINK,</div>
<div class="line">    too_many_symbolic_link_levels       = ELOOP,</div>
<div class="line">    value_too_large                     = EOVERFLOW,</div>
<div class="line">    wrong_protocol_type                 = EPROTOTYPE</div>
<div class="line">  };</div>
<div class="line">}</div>
</div><!-- fragment --><p>As you will note, these are the standard POSIX error codes, and most of the time you'll find that whatever custom error code domain you are about to write can be adequately covered by <code>std::errc</code>. In fact, let's try it:</p>
<div class="fragment"><div class="line"><span class="comment">// Mathematical &quot;errors&quot; we want to catch</span></div>
<div class="line"><span class="keyword">using</span> MathError = std::error_code;</div>
<div class="line"><span class="keyword">static</span> constexpr MathError DivisionByZero = std::errc::result_out_of_range;</div>
<div class="line"><span class="keyword">static</span> constexpr MathError NegativeLogarithm = std::errc::argument_out_of_domain;</div>
<div class="line"><span class="keyword">static</span> constexpr MathError NegativeSquareRoot = std::errc::argument_out_of_domain;  </div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> MathResult = outcome::expected&lt;double, MathError&gt;;</div>
</div><!-- fragment --><p>Anything which can "speak" <code>std::error_code</code> can now work perfectly with your error code system because you are using a standard error code domain (i.e. the POSIX error code domain).</p>
<p>But let's say you really, really wanted to have your own custom error code scheme, this is how you tell C++ 11's standard error code infrastructure about your custom error code domain:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;system_error&gt;</span>  <span class="comment">// bring in std::error_code et al</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// This is the custom error code enum</span></div>
<div class="line"><span class="keyword">enum class</span> MathError {</div>
<div class="line">  DivisionByZero,</div>
<div class="line">  NegativeLogarithm,</div>
<div class="line">  NegativeSquareRoot</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>detail</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Define a custom error code category derived from std::error_category</span></div>
<div class="line">  <span class="keyword">class </span>MathError_category : <span class="keyword">public</span> std::error_category</div>
<div class="line">  {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line">    <span class="comment">// Return a short descriptive name for the category</span></div>
<div class="line">    <span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keywordtype">char</span> *name() const noexcept override final { <span class="keywordflow">return</span> <span class="stringliteral">&quot;MathError&quot;</span>; }</div>
<div class="line">    <span class="comment">// Return what each enum means in text</span></div>
<div class="line">    <span class="keyword">virtual</span> std::string message(<span class="keywordtype">int</span> c) <span class="keyword">const</span> <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (static_cast&lt;MathError&gt;(c))</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> MathError::DivisionByZero:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;division by zero&quot;</span>;</div>
<div class="line">      <span class="keywordflow">case</span> MathError::NegativeLogarithm:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;logarithm of negative number&quot;</span>;</div>
<div class="line">      <span class="keywordflow">case</span> MathError::NegativeSquareRoot:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;square root of negative number&quot;</span>;</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;unknown&quot;</span>;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// OPTIONAL: Allow generic error conditions to be compared to me</span></div>
<div class="line">    <span class="keyword">virtual</span> std::error_condition default_error_condition(<span class="keywordtype">int</span> c) <span class="keyword">const</span> noexcept <span class="keyword">override</span> <span class="keyword">final</span></div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">switch</span> (static_cast&lt;MathError&gt;(c))</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> MathError::DivisionByZero:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__monad.html#ga5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::result_out_of_range);</div>
<div class="line">      <span class="keywordflow">case</span> MathError::NegativeLogarithm:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__monad.html#ga5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::argument_out_of_domain);</div>
<div class="line">      <span class="keywordflow">case</span> MathError::NegativeSquareRoot:</div>
<div class="line">        <span class="keywordflow">return</span> <a class="code" href="group__monad.html#ga5824d43d94ed4cb2593cf39b2d0f354d">make_error_condition</a>(std::errc::argument_out_of_domain);</div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="comment">// I have no mapping for this code</span></div>
<div class="line">        <span class="keywordflow">return</span> std::error_condition(c, *<span class="keyword">this</span>);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare a global function returning a static instance of the custom category</span></div>
<div class="line"><span class="keyword">extern</span> <span class="keyword">const</span> detail::MathError_category &amp;MathError_category()</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">static</span> detail::MathError_category c;</div>
<div class="line">  <span class="keywordflow">return</span> c;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Overload the global make_error_code() free function with our</span></div>
<div class="line"><span class="comment">// custom enum. It will be found via ADL by the compiler if needed.</span></div>
<div class="line"><span class="keyword">inline</span> std::error_code <a class="code" href="group__monad.html#gab6204dd7620b0e495220e76988359589">make_error_code</a>(MathError e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> std::error_code(static_cast&lt;int&gt;(e), MathError_category());</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span>std</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Tell the C++ 11 STL metaprogramming that enum MathError</span></div>
<div class="line">  <span class="comment">// is registered with the standard error code system</span></div>
<div class="line">  <span class="keyword">template</span> &lt;&gt; <span class="keyword">struct </span>is_error_code_enum&lt;MathError&gt; : std::true_type</div>
<div class="line">  {</div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Note that we can now supply MathError directly to error_code</span></div>
<div class="line">  std::error_code ec(MathError::NegativeLogarithm);</div>
<div class="line"></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;MathError::NegativeLogarithm is printed by std::error_code as &quot;</span></div>
<div class="line">    &lt;&lt; ec &lt;&lt; <span class="stringliteral">&quot; with explanatory message &quot;</span> &lt;&lt; ec.message() &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// We can compare MathError containing error codes to generic conditions</span></div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;ec is equivalent to std::errc::result_out_of_range = &quot;</span></div>
<div class="line">    &lt;&lt; (ec == std::errc::result_out_of_range) &lt;&lt; std::endl;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;ec is equivalent to std::errc::argument_out_of_domain = &quot;</span></div>
<div class="line">    &lt;&lt; (ec == std::errc::argument_out_of_domain) &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This might look like an awful lot of extra boilerplate, but look at the advantages:</p>
<ol type="1">
<li>Any code which can speak <code>std::error_code</code> can now work with errors from your code, AND without being recompiled.</li>
<li><code>std::system_error</code> can now wrap your custom error codes seamlessly, allowing your custom error code to be converted into a C++ exception <em>and back out again</em> without losing information.</li>
<li><code>std::error_code</code> knows how to print itself, and will print your custom error code without extra work from you. As usually you'd need to define a print routine for any custom error code you'd write anyway, there is actually very little extra boilerplate here.</li>
<li>If you implement the <code>default_error_condition()</code> override, you can allow code exclusively written to understand <code>std::errc</code> alone to examine your custom error code domain for equivalence to the standard error conditions, AND without being recompiled.</li>
</ol>
<p>So to sum up, if you are going to deploy <code>expected&lt;T, E&gt;</code> into your C++ codebase, I <b>urge</b> you do not use unrestricted <code>expected&lt;T, E&gt;</code> because that will tempt people into using custom error enums as type <code>E</code> which I've hopefully proven by now is a bad idea. Instead <em>restrict</em> <code>expected&lt;T, E&gt;</code> to a hard coded error type using something like:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>my_codes_namespace</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> <a class="code" href="group__monad.html#ga91e1fe11dbebea15458d882d078d6eb5">result</a> = expected&lt;T, std::error_code&gt;;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Custom error code enum</span></div>
<div class="line">  <span class="keyword">enum class</span> MathError {</div>
<div class="line">    DivisionByZero,</div>
<div class="line">    NegativeLogarithm,</div>
<div class="line">    NegativeSquareRoot</div>
<div class="line">  };</div>
<div class="line">  ... boilerplate to tell error_code about MathError ...</div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#ga559b5e8efc12ededdc3aeecce0d304de">make_result</a>(T &amp;&amp;v)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga276cc35056dccfdbe461c11d8eeb3d93">make_expected</a>(std::forward&lt;T&gt;(v));</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">inline</span> unexpected_type&lt;std::error_code&gt; make_error(std::error_code ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga03e1e619a559e7f336621b1092e28527">make_unexpected</a>(ec);</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now instead of directly calling Expected's factory functions, simply return all values from your functions using <code>make_result()</code>. Returning a value now becomes:</p>
<div class="fragment"><div class="line">result&lt;int&gt; foo()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__monad.html#ga559b5e8efc12ededdc3aeecce0d304de">make_result</a>(5);</div>
<div class="line">}</div>
</div><!-- fragment --><p>Returning an error now becomes:</p>
<div class="fragment"><div class="line">result&lt;int&gt; foo()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> make_error(MathError::DivisionByZero);</div>
<div class="line">}</div>
</div><!-- fragment --><p>... and note that you can feed <code>make_error()</code> any custom error code enum understood by <code>std::error_code</code>.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="expected_boilerplate"></a>
Unrestricted use of expected&lt;T, E&gt; means typing more boilerplate</h1>
<p>If you weren't convinced by the previous section, let's look at another problem which unrestricted use of Expected has: the quantity of boilerplate it makes you write.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../include/boost/outcome.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cfloat&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="group__monad.html#gaab2ff6220205017226794529c863b336">outcome</a> = <a class="code" href="group__config.html#gab113de43db2cd2a4cf1e33b54294944a">BOOST_OUTCOME_V1_NAMESPACE</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Custom error code domain 1</span></div>
<div class="line"><span class="keyword">enum class</span> MathError1 {</div>
<div class="line">  DivisionByZero,</div>
<div class="line">  NegativeLogarithm,</div>
<div class="line">  NegativeSquareRoot</div>
<div class="line">};</div>
<div class="line"><span class="comment">// Custom error code domain 2</span></div>
<div class="line"><span class="keyword">enum class</span> MathError2 {</div>
<div class="line">  NegativeSquareRoot,</div>
<div class="line">  NegativeLogarithm,</div>
<div class="line">  DivisionByZero</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">using</span> MathResult1 = outcome::expected&lt;double, MathError1&gt;;</div>
<div class="line"><span class="keyword">using</span> MathResult2 = outcome::expected&lt;long long, MathError2&gt;;</div>
<div class="line"></div>
<div class="line">MathResult1 div(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (::fabs(y) &lt; FLT_EPSILON)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// This operation would fail, instead let&#39;s return the reason of</span></div>
<div class="line">    <span class="comment">// the failure wrapped in E</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga03e1e619a559e7f336621b1092e28527">outcome::make_unexpected</a>(MathError1::DivisionByZero);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// This operation is valid, return the result wrapped in T</span></div>
<div class="line">    <span class="keywordflow">return</span> x / y;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">MathResult2 div10mul3(<span class="keywordtype">double</span> y) noexcept</div>
<div class="line">{</div>
<div class="line">  MathResult1 <a class="code" href="group__monad.html#ga91e1fe11dbebea15458d882d078d6eb5">result</a> = div(10.0, y);</div>
<div class="line">  <span class="comment">// If successful, return the result</span></div>
<div class="line">  <span class="keywordflow">if</span> (result)</div>
<div class="line">    <span class="keywordflow">return</span> (<span class="keywordtype">long</span> <span class="keywordtype">long</span>)(result.value() * 3.0);</div>
<div class="line">  <span class="comment">// NOTE: If it failed, convert the MathError1 error code domain into</span></div>
<div class="line">  <span class="comment">//       the MathError2 error code domain</span></div>
<div class="line">  <span class="keywordflow">switch</span> (result.error())</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">case</span> MathError1::DivisionByZero:</div>
<div class="line">      <span class="keywordflow">return</span> MathError2::DivisionByZero;</div>
<div class="line">    <span class="keywordflow">case</span> MathError1::NegativeLogarithm:</div>
<div class="line">      <span class="keywordflow">return</span> MathError2::NegativeLogarithm;</div>
<div class="line">    <span class="keywordflow">case</span> MathError1::NegativeSquareRoot:</div>
<div class="line">      <span class="keywordflow">return</span> MathError2::NegativeSquareRoot;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; div10mul3(1.0).value() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// NOTE: the C++ exception type thrown by Expected embeds a copy</span></div>
<div class="line">  <span class="comment">//       of type E and therefore its template signature must</span></div>
<div class="line">  <span class="comment">//       be the correct type E. If we accidentally used MathError1</span></div>
<div class="line">  <span class="comment">//       here the exception would not be caught!</span></div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> outcome::bad_expected_access&lt;MathError2&gt; &amp;e)</div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;div10mul3().value() threw an exception&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The example is contrived for sure, but it shows the problem of having lots of local custom error code domains. In the above example, <code>MathError2</code> has a different assignment of integer values to <code>MathError1</code>, but they could simply be different error code enums. As is common in any code base of any size, one layer of functions (<code>div10mul3()</code>) will call into an inner layer of more basic functions (<code>div()</code>) and will need to pass back out any errors encountered.</p>
<p>There are two things to note in this example. The first is that due to the error code domains being different, you need to convert error codes using a switch statement. The second is that on bad access, Expected throws a templated exception type with the type <code>E</code> as the template parameter. I can tell you that it is far too easy in the real world to accidentally mistype or forget to update the type caught in the catch statement leading to unintentional bugs which are quite tricky to track down.</p>
<p>Again, restricting <code>expected&lt;T, E&gt;</code> to <code>E = std::error_code</code> makes the code much more maintainable and easy to parse by humans:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;../include/boost/outcome.hpp&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;cfloat&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cmath&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="group__monad.html#gaab2ff6220205017226794529c863b336">outcome</a> = <a class="code" href="group__config.html#gab113de43db2cd2a4cf1e33b54294944a">BOOST_OUTCOME_V1_NAMESPACE</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Restrict expected&lt;T, E&gt;</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> result = outcome::expected&lt;T, std::error_code&gt;;</div>
<div class="line"><span class="comment">// Restrict bad_expected_access too</span></div>
<div class="line"><span class="keyword">using</span> bad_result_access = outcome::bad_expected_access&lt;std::error_code&gt;;</div>
<div class="line"></div>
<div class="line">result&lt;double&gt; div(<span class="keywordtype">double</span> x, <span class="keywordtype">double</span> y) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (::fabs(y) &lt; FLT_EPSILON)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// This operation would fail, instead let&#39;s return the reason of</span></div>
<div class="line">    <span class="comment">// the failure wrapped in E</span></div>
<div class="line">    <span class="keywordflow">return</span> <a class="code" href="group__expected.html#ga03e1e619a559e7f336621b1092e28527">outcome::make_unexpected</a>(<a class="code" href="group__monad.html#gab6204dd7620b0e495220e76988359589">std::make_error_code</a>(std::errc::result_out_of_range));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// This operation is valid, return the result wrapped in T</span></div>
<div class="line">    <span class="keywordflow">return</span> x / y;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line">result&lt;long long&gt; div10mul3(<span class="keywordtype">double</span> y) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// If calling div() fails, return the same error immediately,</span></div>
<div class="line">  <span class="comment">// else unpack the T into result</span></div>
<div class="line">  <a class="code" href="monad_8hpp.html#aa977bf0b7aded30c781c35f956edc1d7">BOOST_OUTCOME_TRY</a>(result, div(10.0, y));</div>
<div class="line">  <span class="keywordflow">return</span> (<span class="keywordtype">long</span> <span class="keywordtype">long</span>)(result * 3.0);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    std::cout &lt;&lt; div10mul3(1.0).value() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// NOTE: We restricted bad_expected_access above so this is much</span></div>
<div class="line">  <span class="comment">//       less likely to become accidentally wrong as code evolves</span></div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> bad_result_access &amp;e)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Also note we can always print the error code because E is</span></div>
<div class="line">    <span class="comment">// always an error_code</span></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;div10mul3().value() failed due to &quot;</span> &lt;&lt; e.error() &lt;&lt; std::endl;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> You'll note the use of the convenience macro <code>BOOST_OUTCOME_TRY(var, expr)</code> which provides some of the <code>try</code> keyword in Swift or Rust. The try operation evaluates the expression and if the result returned is an unexpected value, it immediately returns from the current function with the same unexpected value - therefore your type <code>E</code> needs to be the same. If it is an expected value, that value is <em>unwrapped</em> and returned as the result from the try operation.</p>
<p>Unlike the <code>try</code> keyword, the macro is not an expression so you can't write statements like <code>if(BOOST_OUTCOME_TRY(var, expr))</code> as you can in Rust or Swift, this is due to a limitation of the C++ language (you can't return from functions in an expression). What you can do is to initialise a variable <code>var</code> on the stack to the unwrapped return value from the expression, so you might write:</p>
<div class="fragment"><div class="line">expected&lt;std::string, std::error_code&gt; somefunc();</div>
<div class="line">...</div>
<div class="line">expected&lt;int, std::error_code&gt; someotherfunc()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// If somefunc() returns an E, immediately return an</span></div>
<div class="line">  <span class="comment">// expected&lt;int, std::error_code&gt; with the same E</span></div>
<div class="line">  <span class="comment">// as if return make_unexpected(somefunc().error());</span></div>
<div class="line">  <a class="code" href="monad_8hpp.html#aa977bf0b7aded30c781c35f956edc1d7">BOOST_OUTCOME_TRY</a>(v, somefunc());</div>
<div class="line">  <span class="comment">// ... else unpack the T into v as if</span></div>
<div class="line">  <span class="comment">// std::string v(std::move(somefunc().value());</span></div>
<div class="line">  <span class="keywordflow">return</span> v.empty() ? 0 : v.size();</div>
<div class="line">}</div>
</div><!-- fragment --><hr/>
<p><br/>
</p>
<h1><a class="anchor" id="error_code_extended"></a>
Outcome's extended std::error_code</h1>
<p>A lot of people find <code>std::error_code</code> too constraining and value their custom error types precisely because they can carry <em>payload</em> e.g. a custom string describing exactly the cause of the error, or maybe a backtrace of the exact offending call sequence leading to the error. They therefore reject the restriction to <code>std::error_code</code> as unsuitable for their use case.</p>
<p>Outcome provides an <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> refinement of <code>std::error_code</code> for exactly this situation. <code>error_code_extended</code> inherits publicly from <code>std::error_code</code>, adding two new member functions: <code>extended_message()</code> and <code>backtrace()</code>. These <em>may</em> provide additional information about the error code like any <code>what()</code> message from the C++ exception the error code was constructed from (if any), or the stack backtrace of the point at which the <code>error_code_extended</code> was constructed.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>error_code_extended : <span class="keyword">public</span> std::error_code</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  error_code_extended();</div>
<div class="line">  error_code_extended(<span class="keywordtype">int</span> ec, <span class="keyword">const</span> std::error_category &amp;cat, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>, <span class="keywordtype">unsigned</span> code1 = 0, <span class="keywordtype">unsigned</span> code2 = 0, <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <a class="code" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316">template &lt;class ErrorCodeEnum, typename = typename std::enable_if&lt;std::is_error_code_enum&lt;ErrorCodeEnum&gt;::value</a>&gt;::type&gt;</div>
<div class="line">    error_code_extended(ErrorCodeEnum e);</div>
<div class="line">  <span class="keyword">explicit</span> error_code_extended(<span class="keyword">const</span> std::error_code &amp;e, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>, <span class="keywordtype">unsigned</span> code1 = 0, <span class="keywordtype">unsigned</span> code2 = 0, <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <span class="keyword">explicit</span> error_code_extended(std::error_code &amp;&amp;e, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>, <span class="keywordtype">unsigned</span> code1 = 0, <span class="keywordtype">unsigned</span> code2 = 0, <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <span class="keywordtype">void</span> assign(<span class="keywordtype">int</span> ec, <span class="keyword">const</span> std::error_category &amp;cat, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>, <span class="keywordtype">unsigned</span> code1 = 0, <span class="keywordtype">unsigned</span> code2 = 0, <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <span class="keywordtype">void</span> clear();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// New member functions</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Fill a char buffer with the extended message, retrieving the two extended unsigned integer codes</span></div>
<div class="line">  <span class="keywordtype">size_t</span> extended_message(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">size_t</span> len, <span class="keywordtype">unsigned</span> &amp;code1, <span class="keywordtype">unsigned</span> &amp;code2) <span class="keyword">const</span> noexcept;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Return an array of strings describing the stack at the time of construction. MUST call free() on this returned pointer.</span></div>
<div class="line">  <span class="keywordtype">char</span> **backtrace() const noexcept;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Prints the extended error code, including any extended information if available</span></div>
<div class="line">inline std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, const error_code_extended &amp;ec);</div>
</div><!-- fragment --><p><code>error_code_extended</code> is completely API compatible with <code>std::error_code</code> and all its member functions can be used the same way. You can supply a <code>std::error_code</code> to an extended error code, or else construct an extended error code the same way you would a STL error code. You should note that it is <b>always safe</b> to slice <code>error_code_extended</code> into an <code>std::error_code</code>, so you can safely feed <code>error_code_extended</code> to anything consuming a <code>std::error_code</code>.</p>
<p>The main big additions are obviously the ability to add a custom string message to an extended error code, this allows the preservation of the original <code>what()</code> message when converting a thrown exception into an extended error code. You can also add two arbitrary unsigned integer codes and most interestingly, a backtrace of the stack at the point of construction. The extended message and backtrace can be later fetched using the new member functions, though note that the storage for these is kept in a statically allocated threadsafe ring buffer and so may vanish at some arbitrary later point when the storage gets recycled. If this happens, <code>extended_message()</code> will return zero characters written and <code>backtrace()</code> will return a null pointer.</p>
<p>Because the storage for the extended information may be recycled at any arbitrary future point, you ought to make sure that you copy the extended information as soon as possible after the <code>error_code_extended</code> is constructed. In other words, don't store <code>error_code_extended</code> as-is into say a vector, instead extract the information into a custom struct.</p>
<dl class="section note"><dt>Note</dt><dd>Construction of an extended error code with extended message or codes takes a maximum of a microsecond on recent hardware due to an atomic pointer increment. Constructing an extended error code with backtrace takes a maximum of about 35 microseconds on a recent Ivy Bridge Intel CPU. <b>No memory allocation</b> is ever performed when constructing an extended error code, latency is always predictable.</dd></dl>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="outcome_rationale"></a>
Where Outcome's outcome&lt;T&gt;, result&lt;T&gt; and option&lt;T&gt; come from</h1>
<p>Hopefully by now you are persuaded to always <em>restrict</em> your use of <code>expected&lt;T, E&gt;</code> to one of:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> result = outcome::expected&lt;T, std::error_code&gt;;</div>
<div class="line"><span class="keyword">using</span> bad_result_access = outcome::bad_expected_access&lt;std::error_code&gt;;</div>
</div><!-- fragment --><p>... or ...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> result = outcome::expected&lt;T, std::exception_ptr&gt;;</div>
<div class="line"><span class="keyword">using</span> bad_result_access = outcome::bad_expected_access&lt;std::exception_ptr&gt;;</div>
</div><!-- fragment --><p>If you've been convinced, then you'll be glad that Outcome provides additional refinements of <code>expected&lt;T, E&gt;</code> designed to make your programming life even easier again. As a rough <b>semantic</b> map onto <code>optional&lt;T&gt;</code>, <code>variant&lt;...&gt;</code> and <code>expected&lt;T, E&gt;</code>:</p>
<pre>
template&lt;class T&gt; using option = std::optional&lt;T&gt;;</pre><pre>template&lt;class T&gt; using result = std::optional&lt;
  std::experimental::expected&lt;
    T,
    error_code_extended
  &gt;
&gt;;</pre><pre>template&lt;class T&gt; using outcome = std::optional&lt;
  std::experimental::expected&lt;
    T,
    std::variant&lt;
      error_code_extended,
      std::exception_ptr
    &gt;
  &gt;
&gt;;
</pre><p>So Outcome's <code>outcome&lt;T&gt;</code>, <code>result&lt;T&gt;</code> and <code>option&lt;T&gt;</code> assume the error type is hard coded to the C++ 11 standard error transport infrastructure, and because they hard code this they can make a series of optimisations both at runtime and for you the programmer during coding which an <code>expected&lt;T, E&gt;</code> implementation can not. In Outcome's refinements, an <em>empty</em> transport is empty, a <em>valued</em> transport contains a <code>T</code>, an <em>errored</em> transport contains an <code>error_code_extended</code> and an <em>excepted</em> transport contains a <code>std::exception_ptr</code>.</p>
<ul>
<li><code>.value()</code> on an errored transport directly throws <code>std::system_error</code> with the error code instead of throwing a wrapper type.</li>
<li><code>.value()</code> on an excepted transport directly rethrows the exception pointer instead of throwing a wrapper type.</li>
<li>Implicit conversion is permitted for any less representative form into any more representative form, so <code>option&lt;T&gt;</code> auto converts to a <code>result&lt;T&gt;</code> preserving exact contents. This turns out to be very useful in large C++ codebases where the lowest layers tend to be written using <code>option&lt;T&gt;</code> and <code>result&lt;T&gt;</code>, whilst highest layers tend to be written using <code>outcome&lt;T&gt;</code> and C++ exception throws.</li>
</ul>
<p>todo </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
