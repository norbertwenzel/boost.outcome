<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>boost.outcome: Refining Expected&lt;T, E&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_md_04-tutorial_c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Refining Expected&lt;T, E&gt; </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#error_code_extended">Outcome's extended std::error_code</a></li>
<li class="level1"><a href="#outcome_overview">Outcome's outcome<T>, result<T> and option<T> refinements</a></li>
<li class="level1"><a href="#outcome_helpers">Outcome's helper free functions</a></li>
<li class="level1"><a href="#outcome_macros">Outcome's helper macros</a></li>
<li class="level1"><a href="#outcome_usage">Example of usage of Outcome's expected<T, E> refinements</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="tutorial_outcome"></a></p>
<p>Outcome's design rationale and tutorial is split into three parts:</p>
<ol type="1">
<li>The <a class="el" href="md_doc_md_02-tutorial_a.html#tutorial_expected">first part</a> provides a broad overview of error handling in C++ in general and how the <code>expected&lt;T, E&gt;</code> proposed for standardisation will contribute to that big menu of error handling design patterns available to the C++ programmer. This part places Outcome the library in context.</li>
<li>The <a class="el" href="md_doc_md_03-tutorial_b.html#tutorial_whynot">second part</a> describes some design anti-patterns common with inexperienced usage of <code>expected&lt;T, E&gt;</code> in C++ which you ought to avoid. It shows you how to use <code>expected&lt;T, E&gt;</code> in a way which integrates well with the C++ 11 STL's standard error code facilities <code>std::error_code</code> and <code>std::error_category</code>.</li>
<li>The third part (this part) walks you through using Outcome's <code>expected&lt;T, E&gt;</code> refinements <code>outcome&lt;T&gt;</code> and <code>result&lt;T&gt;</code>, plus its <code>extended_error_code</code>. Usage is very similar to Expected, but with less typing, less runtime overhead and more convenient extensions.</li>
</ol>
<hr/>
<p><br/>
</p>
<p>In the previous part of this tutorial, we saw how there is a tension between type safety and convenience of programming when using the <code>expected&lt;T, E&gt;</code> transport. Expected as a STL primitive reflects a trade off between those two use cases, and as something which can wear multiple hats it is close to optimal.</p>
<p>What is presented during this last part of Outcome's tutorial are Outcome's convenience extensions to Expected. We start by assuming that you have no need for type safety in your type <code>E</code>, and furthermore that you only have need for <code>E</code> to be either an error code or an exception pointer <em>and nothing else</em>. Such assumptions, as hopefully demonstrated in the previous part, are not wise for some code bases and use cases for Expected - in those use cases, do not use these convenience extensions because the loss of type safety is too big a trade off.</p>
<p>Rather, these convenience extensions are ideally suited for low level systems programming and other such use cases where errors exclusively come from outside your code and where therefore enforcing type safety on each particular error type is unnatural. Classic examples of such code bases would be the Networking TS, the Filesystem TS and so on.</p>
<p>As these refinements are within our control, we can also provide <a class="el" href="md_doc_md_07-faq.html#abi_stability">**ABI stability promises**</a> for these refinements that we can not for <code>expected&lt;T, E&gt;</code>. This lets you use the refinements in your public extern APIs with a guarantee that code compiled with future versions of Outcome will not cause misoperation.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="error_code_extended"></a>
Outcome's extended std::error_code</h1>
<p>A lot of people find <code>std::error_code</code> too constraining and value their custom error types precisely because they can carry <em>payload</em> e.g. a custom string describing exactly the cause of the error, or maybe a backtrace of the exact offending call sequence leading to the error. They therefore reject the restriction to <code>std::error_code</code> as unsuitable for their use case.</p>
<p>Outcome provides an error_code_extended refinement of <code>std::error_code</code> for exactly this situation. <code>error_code_extended</code> inherits publicly from <code>std::error_code</code>, adding three new member functions: <code>extended_message()</code>, <code>raw_backtrace()</code> and <code>backtrace()</code>. These <em>may</em> provide additional information about the error code like any <code>what()</code> message from the C++ exception the error code was constructed from (if any), or the stack backtrace of the point at which the <code>error_code_extended</code> was constructed.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>error_code_extended : <span class="keyword">public</span> std::error_code</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  error_code_extended();</div>
<div class="line">  error_code_extended(<span class="keywordtype">int</span> ec, <span class="keyword">const</span> std::error_category &amp;cat,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>,  <span class="comment">// These are the extended payloads available</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> code1 = 0,</div>
<div class="line">    <span class="keywordtype">unsigned</span> code2 = 0,</div>
<div class="line">    <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  template &lt;class ErrorCodeEnum, typename = typename std::enable_if&lt;std::is_error_code_enum&lt;ErrorCodeEnum&gt;::value&gt;::type&gt;</div>
<div class="line">    error_code_extended(ErrorCodeEnum e);</div>
<div class="line">  <span class="keyword">explicit</span> error_code_extended(<span class="keyword">const</span> std::error_code &amp;e,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>,  <span class="comment">// These are the extended payloads available</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> code1 = 0,</div>
<div class="line">    <span class="keywordtype">unsigned</span> code2 = 0,</div>
<div class="line">    <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <span class="keyword">explicit</span> error_code_extended(std::error_code &amp;&amp;e,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>,  <span class="comment">// These are the extended payloads available</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> code1 = 0,</div>
<div class="line">    <span class="keywordtype">unsigned</span> code2 = 0,</div>
<div class="line">    <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <span class="keywordtype">void</span> assign(<span class="keywordtype">int</span> ec, <span class="keyword">const</span> std::error_category &amp;cat,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>,  <span class="comment">// These are the extended payloads available</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> code1 = 0,</div>
<div class="line">    <span class="keywordtype">unsigned</span> code2 = 0,</div>
<div class="line">    <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <span class="keywordtype">void</span> clear();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// New member functions follow</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Fill a buffer with any extended error message and codes, returning bytes of buffer filled (zero if no extended message).</span></div>
<div class="line">  <span class="keywordtype">size_t</span> extended_message(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">size_t</span> len, <span class="keywordtype">unsigned</span> &amp;code1, <span class="keywordtype">unsigned</span> &amp;code2) <span class="keyword">const</span> noexcept;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Fill a buffer with any backtrace available, returning items filled if any.</span></div>
<div class="line">  <span class="keywordtype">size_t</span> raw_backtrace(<span class="keywordtype">void</span> **buffer, <span class="keywordtype">size_t</span> len) <span class="keyword">const</span> noexcept</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Returns an array of strings describing the backtrace. You must free() this after use.</span></div>
<div class="line">  <span class="keywordtype">char</span> **backtrace() const noexcept;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Prints the extended error code, including any extended information if available</span></div>
<div class="line">inline std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, const error_code_extended &amp;ec);</div>
</div><!-- fragment --><p><code>error_code_extended</code> is completely API compatible with <code>std::error_code</code> and all its member functions can be used the same way. You can supply a <code>std::error_code</code> to an extended error code, or else construct an extended error code the same way you would a STL error code. You should note that it is <b>always safe</b> to slice <code>error_code_extended</code> into an <code>std::error_code</code>, so you can safely feed <code>error_code_extended</code> to anything consuming a <code>std::error_code</code>. The important-to-optimisation implicit destructor of <code>std::error_code</code> is retained in <code>error_code_extended</code>.</p>
<p>The main big additions are obviously the ability to add a custom string message to an extended error code, this allows the preservation of the original <code>what()</code> message when converting a thrown exception into an extended error code. You can also add two arbitrary unsigned integer codes and most interestingly, a backtrace of the stack at the point of construction. The extended message and backtrace can be later fetched using the new member functions, though note that the storage for these is kept in a statically allocated threadsafe ring buffer and so may vanish at some arbitrary later point when the storage gets recycled. If this happens, <code>extended_message()</code> will return zero characters written, <code>raw_backtrace()</code> will return zero items filled and <code>backtrace()</code> will return a null pointer.</p>
<p>Because the storage for the extended information may be recycled at any arbitrary future point, you ought to make sure that you copy the extended information as soon as possible after the <code>error_code_extended</code> is constructed. In other words, don't store <code>error_code_extended</code> as-is into say a vector, instead extract the information into a custom struct as soon as you can.</p>
<dl class="section note"><dt>Note</dt><dd>Construction of an extended error code with extended message or codes takes a worst case maximum of a microsecond on recent hardware. That's a worst case, almost all of the time construction is in the low hundreds of nanoseconds range. Constructing an extended error code with backtrace takes a maximum of about 35 microseconds on a recent Ivy Bridge Intel CPU. <b>No memory allocation</b> is ever performed when constructing an extended error code, latency is always predictable. Construction of an extended error code without using the extended features is no additional overhead over <code>std::error_code</code>.</dd></dl>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="outcome_overview"></a>
Outcome's outcome&lt;T&gt;, result&lt;T&gt; and option&lt;T&gt; refinements</h1>
<p>Outcome provides additional refinements of <code>expected&lt;T, E&gt;</code> designed to make your programming life easier if you are willing to accept the hard coding of <code>E</code> to one of <code>error_code_extended</code> or <code>std::exception_ptr</code>. As a rough <b>semantic</b> map onto <code>optional&lt;T&gt;</code>, <code>variant&lt;...&gt;</code> and <code>expected&lt;T, E&gt;</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> option = std::optional&lt;T&gt;;</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> result = std::optional&lt;</div>
<div class="line">  std::experimental::expected&lt;</div>
<div class="line">    T,</div>
<div class="line">    error_code_extended</div>
<div class="line">  &gt;</div>
<div class="line">&gt;;</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> outcome = std::optional&lt;</div>
<div class="line">  std::experimental::expected&lt;</div>
<div class="line">    T,</div>
<div class="line">    std::variant&lt;</div>
<div class="line">      error_code_extended,</div>
<div class="line">      std::exception_ptr</div>
<div class="line">    &gt;</div>
<div class="line">  &gt;</div>
<div class="line">&gt;;</div>
</div><!-- fragment --><p>Outcome's <code>outcome&lt;T&gt;</code>, <code>result&lt;T&gt;</code> and <code>option&lt;T&gt;</code> assume the error type is hard coded to the C++ 11 standard error transport infrastructure, and because they hard code this they can make a series of optimisations in API design for you the programmer to save boilerplate, at compile time and at runtime which an <code>expected&lt;T, E&gt;</code> implementation can not. To spell it out:</p>
<ul>
<li><code>option&lt;T&gt;</code> can be empty, or hold an instance of a type <code>T</code>.</li>
<li><code>result&lt;T&gt;</code> can be empty, or hold an instance of a type <code>T</code>, or hold an instance of <code>error_code_extended</code>.</li>
<li><code>outcome&lt;T&gt;</code> can be empty, or hold an instance of a type <code>T</code>, or hold an instance of <code>error_code_extended</code>, or hold an instance of <code>std::exception_ptr</code>. This saves you having to wrap an error code into an exception pointer instance, thus also avoiding a memory allocation.</li>
</ul>
<p>Implicit conversion is permitted for any less representative form into any more representative form, so <code>option&lt;T&gt;</code> auto converts to a <code>result&lt;T&gt;</code> preserving exact contents, as does <code>result&lt;T&gt;</code> into an <code>outcome&lt;T&gt;</code>. This turns out to be very useful in large C++ codebases where the lowest layers tend to be written using <code>option&lt;T&gt;</code> and <code>result&lt;T&gt;</code>, whilst highest layers tend to be written using <code>outcome&lt;T&gt;</code> and C++ exception throws.</p>
<p>In Outcome's refinements which we shall call <em>transports</em>, an <em>empty</em> transport is empty, a <em>valued</em> transport contains a <code>T</code>, an <em>errored</em> transport contains an <code>error_code_extended</code> and an <em>excepted</em> transport contains a <code>std::exception_ptr</code>. All transports will throw a monad_error type if you try doing something wrong instead of a <code>bad_expected_access&lt;E&gt;</code>. <code>monad_error</code> subclasses <code>std::system_error</code> with an error code of custom category <code>monad_category()</code>, with corresponding enumeration monad_errc, which can have one of two values:</p>
<ul>
<li><code>monad_errc::no_state</code> means you attempted to fetch a value, error or exception from an empty transport.</li>
<li><code>monad_errc::exception_present</code> is returned as the error code if you retrieve an error code from an excepted transport.</li>
</ul>
<p>This leads to the following differences to <code>expected&lt;T, E&gt;</code>:</p>
<ul>
<li>Outcome's refinements constexpr default construct to <b>empty</b>, not to a default constructed <code>T</code>. There is no "almost never empty" guarantee like with <code>expected&lt;T, E&gt;</code> or <code>variant&lt;...&gt;</code>, instead there is a formal empty state to do with as you please (in some situations, a function returning a value OR empty OR an error makes a lot of sense and Outcome supports a <code>tribool</code> extension for ternary logics for those who need such a thing). Attempting to retrieve a value, error or exception from an empty transport throws a <code>monad_error::no_state</code> [1].</li>
<li><code>.value()</code> on an errored transport directly throws a <code>std::system_error</code> with the error code [2] instead of throwing a wrapper type like <code>bad_expected_access&lt;E&gt;</code> from which you need to manually extract the <code>E</code> instance later.</li>
<li><code>.value()</code> on an excepted transport directly rethrows the contents of the exception pointer [3] instead of throwing a wrapper type like <code>bad_expected_access</code> from which you need to manually extract later.</li>
<li><code>.error()</code> returns any <code>error_code_extended</code> as you'd expect, returning a default constructed (null) error code if the transport is valued, or <code>monad_errc::exception_present</code> if the transport is excepted.</li>
<li><code>.exception()</code> returns any <code>std::exception_ptr</code> as you'd expect. If the transport is valued, it returns a default constructed (null) exception pointer. If the transport is errored, it returns an exception pointer to a <code>std::system_error</code> wrapping the error code.</li>
</ul>
<p>And finally, if your compiler is in C++ 17 mode or later, transports are marked with the <a href="http://en.cppreference.com/w/cpp/language/attributes"><code>[[nodiscard]]</code></a> attribute. This means the compiler ought to warn if you forget to examine transports returned by functions. If you really mean to throw away a returned transport, make sure you cast it to <code>(void)</code> to tell the compiler you specifically intend to throw it away.</p>
<p>[1]: Actually the <code>BOOST_OUTCOME_THROW_MONAD_ERROR(ec, monad_error(monad_errc::no_state))</code> macro is executed where <code>ec</code> is the <code>std::error_code</code> contained by the monad. This can be user redefined to do anything, but the default implementation throws a C++ exception of type monad_error with code monad_errc::no_state if C++ exceptions are enabled by the compiler. If they are not, it prints a stack backtrace to stderr and aborts the process.</p>
<p>[2]: Similarly the <code>BOOST_OUTCOME_THROW_SYSTEM_ERROR(ec, std::system_error(ec))</code> macro is actually executed where <code>ec</code> is the <code>error_code_extended</code> contained by the monad.</p>
<p>[3]: Similarly the <code>BOOST_OUTCOME_RETHROW_EXCEPTION(e)</code> macro is actually executed where <code>e</code> is the <code>std::exception_ptr</code> contained by the monad.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="outcome_helpers"></a>
Outcome's helper free functions</h1>
<p>As with Expected, Outcome supplies helper free functions to make your life writing code with <code>option&lt;T&gt;</code>, <code>result&lt;T&gt;</code> and <code>outcome&lt;T&gt;</code> easier. They are named a bit differently however, though the naming convention is straightforward. As with <code>expected&lt;void, E&gt;</code>, it is legal to be valued and of type <code>void</code>. Because a transport of type <code>void</code> is always considered less representative than any type <code>T</code>, any void transport will implicitly convert into any non-void transport, preserving any empty, errored or excepted state. This lets you conveniently write:</p>
<div class="fragment"><div class="line">result&lt;Foo&gt; somefunction()</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">  <span class="keywordflow">if</span>(bad)</div>
<div class="line">    <span class="keywordflow">return</span> make_errored_result&lt;<span class="comment">/*void&gt;(...);  // Note we didn&#39;t specify &lt;Foo&gt;</span></div>
<div class="line"><span class="comment">  else</span></div>
<div class="line"><span class="comment">    return Foo(...);</span></div>
<div class="line"><span class="comment">}</span></div>
</div><!-- fragment --><p>The full set of free functions is as follows: </p>
<dl>
<dt><code>make_(option|result|outcome)(T v)</code> </dt>
<dd>Makes a valued transport with value <code>v</code>. </dd>
<dt><code>make_(option|result|outcome)&lt;T = void&gt;()</code> </dt>
<dd>Makes a valued transport default constructing a <code>T</code>. </dd>
<dt><code>make_empty_(option|result|outcome)&lt;T = void&gt;()</code> </dt>
<dd>Makes an empty transport. </dd>
<dt><code>make_errored_(result|outcome)&lt;T = void&gt;(error_code_extended ec)</code> </dt>
<dd>Makes an errored transport. </dd>
<dt><code>make_errored_(result|outcome)&lt;T = void&gt;(int code, const char *extendedmsg = nullptr)</code> </dt>
<dd>Makes an errored transport with the given error code of generic POSIX category and optionally some extended custom message which is copied into storage as per <code>error_code_extended</code>. This is very convenient for writing: <div class="fragment"><div class="line">result&lt;Foo&gt; somefunction()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(-1 == open(...))  <span class="comment">// Any POSIX system call setting errno on failure</span></div>
<div class="line">    <span class="keywordflow">return</span> make_errored_result&lt;&gt;(errno);</div>
<div class="line">}</div>
</div><!-- fragment -->  </dd>
<dt><code>make_errored_(result|outcome)&lt;T = void&gt;(DWORD code, const char *extendedmsg = nullptr)</code> (Windows only) </dt>
<dd>Makes an errored transport with the given error code of Win32 system category and optionally some extended custom message which is copied into storage as per <code>error_code_extended</code>. This is very convenient for writing: <div class="fragment"><div class="line">result&lt;Foo&gt; somefunction()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(INVALID_HANDLE_VALUE == CreateFile(...))  <span class="comment">// Any Win32 call setting GetLastError() on failure</span></div>
<div class="line">    <span class="keywordflow">return</span> make_errored_result&lt;&gt;(GetLastError());</div>
<div class="line">}</div>
</div><!-- fragment -->  </dd>
<dt><code>make_excepted_outcome&lt;T = void&gt;(std::exception_ptr v = std::current_exception())</code> </dt>
<dd>Makes an excepted transport. This lets you conveniently write: <div class="fragment"><div class="line">outcome&lt;Foo&gt; somefunction()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(...)  <span class="comment">// catch all</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> make_excepted_outcome&lt;<span class="comment">/*void&gt;(/* std::current_exception() );</span></div>
<div class="line"><span class="comment">  }</span></div>
<div class="line"><span class="comment">}</span></div>
</div><!-- fragment -->  </dd>
<dt><code>as_(result|outcome)(option|result)</code> </dt>
<dd>Lets you formally annotate an implicit conversion from less representative to more representative. </dd>
<dt><code>as_void(const (option&lt;T&gt;|result&lt;T&gt;|outcome&lt;T&gt;|expected&lt;T, E&gt;) &amp;)</code> </dt>
<dd>Returns a copy of any input transport as a void version of the same transport, preserving any empty/errored/excepted state. If the input was valued, the returned copy will be valued <b>void</b>. </dd>
</dl>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="outcome_macros"></a>
Outcome's helper macros</h1>
<p>We've already seen in part B the helper macro <code>BOOST_OUTCOME_TRY(var, expr)</code> which also works with <code>expected&lt;T, E&gt;</code> when the error type in the returned Expected is the same. Something unique to Outcome's refinements due to using <code>error_code_extended</code> is the convenience macro <code>BOOST_OUTCOME_CATCH_EXCEPTION_TO_RESULT</code> which is a long sequence of STL exception type catch clauses converting STL exception types into their equivalent generic category error codes, preserving any custom <code>what()</code> message:</p>
<div class="fragment"><div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::invalid_argument &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EINVAL, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::domain_error &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EDOM, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::length_error &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(E2BIG, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::out_of_range &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(ERANGE, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::logic_error &amp;e) <span class="comment">/* base class for this group </span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EINVAL, e.what());</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">catch(const std::system_error &amp;e) /* also catches ios::failure </span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(BOOST_OUTCOME_V1_NAMESPACE::error_code_extended(e.code(), e.what()));</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">catch(const std::overflow_error &amp;e)</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EOVERFLOW, e.what());</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">catch(const std::range_error &amp;e)</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(ERANGE, e.what());</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">catch(const std::runtime_error &amp;e) /* base class for this group </span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EAGAIN, e.what());</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">catch(const std::bad_alloc &amp;e)</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(ENOMEM, e.what());</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">catch(const std::exception &amp;e)</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EINVAL, e.what());</span></div>
<div class="line"><span class="comment">}</span></div>
</div><!-- fragment --><p>This macro is particularly useful when you are calling into the STL from a noexcept function which returns a <code>result&lt;T&gt;</code> and not an <code>outcome&lt;T&gt;</code>. So long as the code you call only <b>ever</b> will throw STL exception types, using this macro is safe and information loss free. Note that the above sequence does not include a catch all clause, so if you want one of those then use the <code>BOOST_OUTCOME_CATCH_ALL_EXCEPTION_TO_RESULT</code> macro which adds to the end of the catch sequence:</p>
<div class="fragment"><div class="line">... all the stuff from BOOST_OUTCOME_CATCH_EXCEPTION_TO_RESULT and then ...</div>
<div class="line">catch(...)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EAGAIN, <span class="stringliteral">&quot;unknown exception&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><hr/>
<p><br/>
</p>
<h1><a class="anchor" id="outcome_usage"></a>
Example of usage of Outcome's expected&lt;T, E&gt; refinements</h1>
<p>The final set of code examples are reasonably long ones which place, side by side, an implementation written using <code>expected&lt;T, E&gt;</code> beside one using <code>result&lt;T&gt;</code> so you can both see usage of Outcome in real world code, and also the differences enabled by the refinements.</p>
<p>The first program is a find regex in files utility written using C++ 14 and the Filesystem TS:</p>
<table class="doxtable">
<tr>
<th>Outcome refinements</th><th>Expected </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="keyword">class </span>mapped_string_view : <span class="keyword">public</span> std::string_view</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> _disabled;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  constexpr mapped_string_view() noexcept : _disabled(true) {}</div>
<div class="line">  mapped_string_view(<span class="keywordtype">char</span> *s, <span class="keywordtype">size_t</span> l) noexcept : std::string_view(s, l), _disabled(<span class="keyword">false</span>) {}</div>
<div class="line">  mapped_string_view(mapped_string_view &amp;&amp;o) noexcept : std::string_view(std::move(o)), _disabled(o._disabled) { o._disabled = <span class="keyword">true</span>; }</div>
<div class="line">  mapped_string_view &amp;operator=(mapped_string_view &amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  ~mapped_string_view()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (!_disabled)</div>
<div class="line">    {</div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><span class="preprocessor"></span>      UnmapViewOfFile(this-&gt;data());</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>      munmap((<span class="keywordtype">void</span> *) this-&gt;data(), this-&gt;size());</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">static</span> outcome::result&lt;mapped_string_view&gt; map_file_into_memory(filesystem::path p) noexcept</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><span class="preprocessor"></span>  HANDLE fh, mh;</div>
<div class="line">  DWORD ec;</div>
<div class="line">  fh = CreateFile(p.c_str(), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,</div>
<div class="line">    <span class="keyword">nullptr</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="keyword">nullptr</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (INVALID_HANDLE_VALUE == fh)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_errored_result&lt;&gt;(GetLastError());</div>
<div class="line">  }</div>
<div class="line">  BY_HANDLE_FILE_INFORMATION bhfi;</div>
<div class="line">  memset(&amp;bhfi, 0, <span class="keyword">sizeof</span>(bhfi));</div>
<div class="line">  <span class="keywordflow">if</span> (!GetFileInformationByHandle(fh, &amp;bhfi))</div>
<div class="line">  {</div>
<div class="line">    ec = GetLastError();</div>
<div class="line">    CloseHandle(fh);</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_errored_result&lt;&gt;(ec);</div>
<div class="line">  }</div>
<div class="line">  uint64_t length = ((uint64_t) bhfi.nFileSizeHigh &lt;&lt; 32) | bhfi.nFileSizeLow;</div>
<div class="line">  mh = CreateFileMapping(fh, <span class="keyword">nullptr</span>, PAGE_READONLY, 0, 0, <span class="keyword">nullptr</span>);</div>
<div class="line">  ec = GetLastError();</div>
<div class="line">  CloseHandle(fh);</div>
<div class="line">  <span class="keywordflow">if</span> (INVALID_HANDLE_VALUE == mh)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_errored_result&lt;&gt;(ec);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">char</span> *addr = (<span class="keywordtype">char</span> *) MapViewOfFile(mh, FILE_MAP_READ, 0, 0, 0);</div>
<div class="line">  ec = GetLastError();</div>
<div class="line">  CloseHandle(mh);</div>
<div class="line">  <span class="keywordflow">if</span> (!addr)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_errored_result&lt;&gt;(ec);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> mapped_string_view(addr, (<span class="keywordtype">size_t</span>) length);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>  <span class="keywordtype">int</span> fh, ec;</div>
<div class="line">  fh = open(p.c_str(), O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span> (-1 == fh)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_errored_result&lt;&gt;(errno);</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">struct </span>stat st;</div>
<div class="line">  memset(&amp;st, 0, <span class="keyword">sizeof</span>(st));</div>
<div class="line">  <span class="keywordflow">if</span> (-1 == fstat(fh, &amp;st))</div>
<div class="line">  {</div>
<div class="line">    ec = errno;</div>
<div class="line">    close(fh);</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_errored_result&lt;&gt;(ec);</div>
<div class="line">  }</div>
<div class="line">  uint64_t length = st.st_size;</div>
<div class="line">  <span class="keywordtype">char</span> *addr = (<span class="keywordtype">char</span> *)mmap(<span class="keyword">nullptr</span>, length, PROT_READ, MAP_SHARED, fh, 0);</div>
<div class="line">  ec = errno;</div>
<div class="line">  close(fh);</div>
<div class="line">  <span class="keywordflow">if</span> (!addr)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_errored_result(ec);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> mapped_string_view(addr, (<span class="keywordtype">size_t</span>)length);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> outcome::result&lt;std::vector&lt;filesystem::path&gt;&gt; find_regex_in_files(<span class="keyword">const</span> std::regex &amp;re, filesystem::directory_iterator dit, <span class="keywordtype">size_t</span> depth = 0) noexcept</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;filesystem::path&gt; ret;</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p : dit)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (filesystem::is_directory(p.status()))</div>
<div class="line">      {</div>
<div class="line">        std::error_code ec;</div>
<div class="line">        filesystem::directory_iterator nit(p.path(), ec);</div>
<div class="line">        <span class="keywordflow">if</span> (ec)</div>
<div class="line">          <span class="keywordflow">return</span> outcome::make_errored_result&lt;&gt;(ec);</div>
<div class="line">        BOOST_OUTCOME_TRY(results, find_regex_in_files(re, std::move(nit), depth + 1));</div>
<div class="line">        <span class="comment">// Merge found results from subdirectory into me</span></div>
<div class="line">        ret.reserve(ret.size() + results.size());</div>
<div class="line">        std::move(results.begin(), results.end(), std::back_inserter(ret));</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// Try to map the file into memory</span></div>
<div class="line">      BOOST_OUTCOME_TRY(view, map_file_into_memory(p.path()));</div>
<div class="line">      <span class="comment">// regex doesn&#39;t have a string_view overload yet ...</span></div>
<div class="line">      <span class="keywordflow">if</span>(std::regex_search(view.data(), re))</div>
<div class="line">        ret.push_back(p.path());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">  }</div>
<div class="line">  BOOST_OUTCOME_CATCH_ALL_EXCEPTION_TO_RESULT</div>
<div class="line">}</div>
</div><!-- fragment --> </td><td valign="top"><div class="fragment"><div class="line"><span class="keyword">class </span>mapped_string_view : <span class="keyword">public</span> std::string_view</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">bool</span> _disabled;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  constexpr mapped_string_view() noexcept : _disabled(true) {}</div>
<div class="line">  mapped_string_view(<span class="keywordtype">char</span> *s, <span class="keywordtype">size_t</span> l) noexcept : std::string_view(s, l), _disabled(<span class="keyword">false</span>) {}</div>
<div class="line">  mapped_string_view(mapped_string_view &amp;&amp;o) noexcept : std::string_view(std::move(o)), _disabled(o._disabled) { o._disabled = <span class="keyword">true</span>; }</div>
<div class="line">  mapped_string_view &amp;operator=(mapped_string_view &amp;&amp;) = <span class="keyword">delete</span>;</div>
<div class="line">  ~mapped_string_view()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span> (!_disabled)</div>
<div class="line">    {</div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><span class="preprocessor"></span>      UnmapViewOfFile(this-&gt;data());</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>      munmap((<span class="keywordtype">void</span> *) this-&gt;data(), this-&gt;size());</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">static</span> outcome::expected&lt;mapped_string_view&gt; map_file_into_memory(filesystem::path p) noexcept</div>
<div class="line">{</div>
<div class="line"><span class="preprocessor">#ifdef _WIN32</span></div>
<div class="line"><span class="preprocessor"></span>  HANDLE fh, mh;</div>
<div class="line">  DWORD ec;</div>
<div class="line">  fh = CreateFile(p.c_str(), GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,</div>
<div class="line">    <span class="keyword">nullptr</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="keyword">nullptr</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (INVALID_HANDLE_VALUE == fh)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected(std::error_code(GetLastError(), std::system_category()));</div>
<div class="line">  }</div>
<div class="line">  BY_HANDLE_FILE_INFORMATION bhfi;</div>
<div class="line">  memset(&amp;bhfi, 0, <span class="keyword">sizeof</span>(bhfi));</div>
<div class="line">  <span class="keywordflow">if</span> (!GetFileInformationByHandle(fh, &amp;bhfi))</div>
<div class="line">  {</div>
<div class="line">    ec = GetLastError();</div>
<div class="line">    CloseHandle(fh);</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected(std::error_code(ec, std::system_category()));</div>
<div class="line">  }</div>
<div class="line">  uint64_t length = ((uint64_t) bhfi.nFileSizeHigh &lt;&lt; 32) | bhfi.nFileSizeLow;</div>
<div class="line">  mh = CreateFileMapping(fh, <span class="keyword">nullptr</span>, PAGE_READONLY, 0, 0, <span class="keyword">nullptr</span>);</div>
<div class="line">  ec = GetLastError();</div>
<div class="line">  CloseHandle(fh);</div>
<div class="line">  <span class="keywordflow">if</span> (INVALID_HANDLE_VALUE == mh)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected(std::error_code(ec, std::system_category()));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">char</span> *addr = (<span class="keywordtype">char</span> *) MapViewOfFile(mh, FILE_MAP_READ, 0, 0, 0);</div>
<div class="line">  ec = GetLastError();</div>
<div class="line">  CloseHandle(mh);</div>
<div class="line">  <span class="keywordflow">if</span> (!addr)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected(std::error_code(ec, std::system_category()));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> mapped_string_view(addr, (<span class="keywordtype">size_t</span>) length);</div>
<div class="line"><span class="preprocessor">#else</span></div>
<div class="line"><span class="preprocessor"></span>  <span class="keywordtype">int</span> fh, ec;</div>
<div class="line">  fh = open(p.c_str(), O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span> (-1 == fh)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected(std::error_code(errno, std::system_category()));</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">struct </span>stat st;</div>
<div class="line">  memset(&amp;st, 0, <span class="keyword">sizeof</span>(st));</div>
<div class="line">  <span class="keywordflow">if</span> (-1 == fstat(fh, &amp;st))</div>
<div class="line">  {</div>
<div class="line">    ec = errno;</div>
<div class="line">    close(fh);</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected(std::error_code(ec, std::system_category()));</div>
<div class="line">  }</div>
<div class="line">  uint64_t length = st.st_size;</div>
<div class="line">  <span class="keywordtype">char</span> *addr = (<span class="keywordtype">char</span> *)mmap(<span class="keyword">nullptr</span>, length, PROT_READ, MAP_SHARED, fh, 0);</div>
<div class="line">  ec = errno;</div>
<div class="line">  close(fh);</div>
<div class="line">  <span class="keywordflow">if</span> (!addr)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected(std::error_code(ec, std::system_category()));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> mapped_string_view(addr, (<span class="keywordtype">size_t</span>)length);</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>}</div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> outcome::expected&lt;std::vector&lt;filesystem::path&gt;&gt; find_regex_in_files(<span class="keyword">const</span> std::regex &amp;re, filesystem::directory_iterator dit, <span class="keywordtype">size_t</span> depth = 0) noexcept</div>
<div class="line">{</div>
<div class="line">  std::vector&lt;filesystem::path&gt; ret;</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p : dit)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">if</span> (filesystem::is_directory(p.status()))</div>
<div class="line">      {</div>
<div class="line">        std::error_code ec;</div>
<div class="line">        filesystem::directory_iterator nit(p.path(), ec);</div>
<div class="line">        <span class="keywordflow">if</span> (ec)</div>
<div class="line">          <span class="keywordflow">return</span> outcome::make_unexpected(ec);</div>
<div class="line">        BOOST_OUTCOME_TRY(results, find_regex_in_files(re, std::move(nit), depth + 1));</div>
<div class="line">        <span class="comment">// Merge found results from subdirectory into me</span></div>
<div class="line">        ret.reserve(ret.size() + results.size());</div>
<div class="line">        std::move(results.begin(), results.end(), std::back_inserter(ret));</div>
<div class="line">      }</div>
<div class="line">      <span class="comment">// Try to map the file into memory</span></div>
<div class="line">      BOOST_OUTCOME_TRY(view, map_file_into_memory(p.path()));</div>
<div class="line">      <span class="comment">// regex doesn&#39;t have a string_view overload yet ...</span></div>
<div class="line">      <span class="keywordflow">if</span>(std::regex_search(view.data(), re))</div>
<div class="line">        ret.push_back(p.path());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> ret;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::bad_alloc &amp;)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected(std::make_error_code(std::errc::not_enough_memory));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span> (...)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> outcome::make_unexpected(std::make_error_code(std::errc::resource_unavailable_try_again));</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment -->  </td></tr>
</table>
<p>As you can see, in the above use case there is not much difference between using <code>expected&lt;T, E = std::error_code&gt;</code> or <code>result&lt;T&gt;</code>:</p>
<ol type="1">
<li>Instead of typing <code>outcome::make_unexpected(std::error_code(GetLastError(), std::system_category()))</code> you can type <code>outcome::make_errored_result&lt;&gt;(GetLastError())</code>.</li>
<li>Instead of typing out a sequence of exception catch clauses, you can use <code>BOOST_OUTCOME_CATCH_ALL_EXCEPTION_TO_RESULT</code>.</li>
</ol>
<p>This similarity is because the above code avoids "default actions" by being careful to always explicitly check state of a transport before using it. <code>result&lt;T&gt;</code> was intentionally designed to be substitutable by automation for an <code>expected&lt;T, E = std::error_code&gt;</code> using find and replace regex in files. This ought to ease a retrofitting of an existing codebase using Expected to use Outcome's refinements.</p>
<p>The second program demonstrates much more of Outcome's refinements in action. It is a simple Executor implementation modelled on the Networking TS/ASIO's i/o completion handlers and i/o service. When work is posted to the service, the next available thread worker will execute that work. Handlers are permitted to return a lightweight error code to indicate a routine error, or throw an exception to indicate an abortable situation has occurred.</p>
<table class="doxtable">
<tr>
<th>Outcome refinements</th><th>Expected </th></tr>
<tr>
<td valign="top"><div class="fragment"><div class="line"><span class="comment">/* This is an implementation of a futures based Executor as proposed by P0443R1</span></div>
<div class="line"><span class="comment">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0443r1.html using the</span></div>
<div class="line"><span class="comment">ASIO/Networking TS io_service as a model.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">ASIO propagates exception throws by handlers out of the corresponding run().</span></div>
<div class="line"><span class="comment">Executors don&#39;t do that, and neither does this implementation.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keyword">class </span>io_service</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">  //! The type of the i/o handler, same as ASIO</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">using</span> io_handler = void(std::error_code &amp;ec, <span class="keywordtype">size_t</span> bytes_transferred);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::mutex _lock;</div>
<div class="line">  std::deque&lt;std::packaged_task&lt;outcome::outcome&lt;void&gt;(size_t)&gt;&gt; _work;</div>
<div class="line">  std::condition_variable _newwork;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Call the i/o handler at some future point in some future thread, returning immediately</span></div>
<div class="line">  outcome::result&lt;std::future&lt;outcome::outcome&lt;void&gt;&gt;&gt; post(std::function&lt;io_handler&gt; f) noexcept</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Make a packaged task rebinding the completion handler</span></div>
<div class="line">      std::packaged_task&lt;outcome::outcome&lt;void&gt;(size_t)&gt; rebound([f = std::move(f)](<span class="keywordtype">size_t</span> bytes_transferred)</div>
<div class="line">        -&gt;outcome::outcome&lt;void&gt;</div>
<div class="line">      {</div>
<div class="line">        <span class="keywordflow">try</span></div>
<div class="line">        {</div>
<div class="line">          std::error_code ec;</div>
<div class="line">          <span class="comment">// Call the handler, if he returns an error code return that,</span></div>
<div class="line">          <span class="comment">// if he throws return the exception thrown</span></div>
<div class="line">          f(ec, bytes_transferred);</div>
<div class="line">          <span class="keywordflow">if</span> (ec)</div>
<div class="line">            <span class="keywordflow">return</span> outcome::make_errored_outcome&lt;&gt;(ec);</div>
<div class="line">          <span class="keywordflow">return</span> outcome::make_ready_outcome();</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">catch</span> (...)</div>
<div class="line">        {</div>
<div class="line">          <span class="keywordflow">return</span> outcome::make_exceptional_outcome&lt;&gt;();</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line">      <span class="comment">// Fetching the future can throw a STL exception</span></div>
<div class="line">      std::future&lt;outcome::outcome&lt;void&gt;&gt; f(rebound.get_future());</div>
<div class="line">      {</div>
<div class="line">        std::lock_guard&lt;decltype(_lock)&gt; g(_lock);</div>
<div class="line">        <span class="comment">// Extending the deque can throw a STL exception</span></div>
<div class="line">        _work.push_back(std::move(rebound));</div>
<div class="line">        _newwork.notify_one();</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> std::move(f);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Catch all STL exception throws and return a corresponding result</span></div>
<div class="line">    BOOST_OUTCOME_CATCH_ALL_EXCEPTION_TO_RESULT</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">/* Call the i/o handler in some thread, returning when it completes.</span></div>
<div class="line"><span class="comment">  Note that ASIO&#39;s io_service calls this dispatch(), but the Executors proposal calls it execute()</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  outcome::outcome&lt;void&gt; execute(std::function&lt;io_handler&gt; f) noexcept</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// If post() returns a failure in its result, then this will throw</span></div>
<div class="line">      <span class="comment">// a system_error with that error code</span></div>
<div class="line">      <span class="comment">// The future.get() may throw too.</span></div>
<div class="line">      <span class="keywordflow">return</span> post(std::move(f)).value().get();</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Convert all STL exception throws into the equivalent error code</span></div>
<div class="line">    <span class="comment">// such that the returned outcome will be errored, not excepted.</span></div>
<div class="line">    <span class="comment">// Note if the result returned by post() was errored it will have</span></div>
<div class="line">    <span class="comment">// been thrown as a system_error, this will convert it back to its</span></div>
<div class="line">    <span class="comment">// original error code.</span></div>
<div class="line">    BOOST_OUTCOME_CATCH_EXCEPTION_TO_RESULT</div>
<div class="line">    <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// For any non-STL exception throws, return as an excepted outcome</span></div>
<div class="line">      <span class="keywordflow">return</span> outcome::make_exceptional_outcome&lt;&gt;();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">// If there are handlers pending, execute up to one of them</span></div>
<div class="line">  <span class="keywordtype">size_t</span> run_one() noexcept</div>
<div class="line">  {</div>
<div class="line">    std::unique_lock&lt;decltype(_lock)&gt; g(_lock);</div>
<div class="line">    <span class="keywordflow">if</span> (_work.empty())</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line">    std::packaged_task&lt;outcome::outcome&lt;void&gt;(size_t)&gt; mywork(std::move(_work.front()));</div>
<div class="line">    _work.pop_front();</div>
<div class="line">    g.unlock();</div>
<div class="line">    <span class="comment">// Call the completion handler with some arbitrary bytes_transferred</span></div>
<div class="line">    mywork(78);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// If there is no work, sleep until work arrives, else execute as much work as possible</span></div>
<div class="line">  <span class="keywordtype">size_t</span> run() noexcept</div>
<div class="line">  {</div>
<div class="line">    {</div>
<div class="line">      std::unique_lock&lt;decltype(_lock)&gt; g(_lock);</div>
<div class="line">      <span class="keywordflow">if</span> (_work.empty())</div>
<div class="line">      {</div>
<div class="line">        _newwork.wait(g);  <span class="comment">// allow spurious wakeups</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">size_t</span> executed = 0;</div>
<div class="line">    <span class="keywordflow">while</span> (run_one())</div>
<div class="line">      executed++;</div>
<div class="line">    <span class="keywordflow">return</span> executed;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>work</div>
<div class="line">{</div>
<div class="line">  io_service *ios;</div>
<div class="line">  <span class="keywordtype">size_t</span> count;</div>
<div class="line">  constexpr work(io_service &amp;_ios) : ios(&amp;_ios), count(0) {}</div>
<div class="line">  <span class="keywordtype">void</span> operator()(std::error_code &amp;ec, <span class="keywordtype">size_t</span> bytes_transferred)</div>
<div class="line">  {</div>
<div class="line">    ++count;</div>
<div class="line">    <span class="keywordflow">if</span> (count &lt; 10000000)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Call myself again. Note I can simply call value() to</span></div>
<div class="line">      <span class="comment">// cause the result to throw a system_error with any error code</span></div>
<div class="line">      ios-&gt;post(std::ref(*<span class="keyword">this</span>)).value();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  io_service ios;</div>
<div class="line">  std::vector&lt;work&gt; works(std::thread::hardware_concurrency(), work(ios));</div>
<div class="line">  std::vector&lt;std::thread&gt; threads;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> n = 0; n &lt; std::thread::hardware_concurrency(); n++)</div>
<div class="line">  {</div>
<div class="line">    threads.push_back(std::thread([&amp;ios] {</div>
<div class="line">      ios.run();</div>
<div class="line">    }));</div>
<div class="line">  }</div>
<div class="line">  std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> n = 0; n &lt; std::thread::hardware_concurrency(); n++)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Note I can simply call value() to cause the result to throw</span></div>
<div class="line">    <span class="comment">// a system_error with any error code</span></div>
<div class="line">    ios.post(works[n]).value();</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;i : threads)</div>
<div class="line">    i.join();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </td><td valign="top"><div class="fragment"><div class="line"><span class="comment">/* This is an implementation of a futures based Executor as proposed by P0443R1</span></div>
<div class="line"><span class="comment">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0443r1.html using the</span></div>
<div class="line"><span class="comment">ASIO/Networking TS io_service as a model.</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line"><span class="comment">ASIO propagates exception throws by handlers out of the corresponding run().</span></div>
<div class="line"><span class="comment">Executors don&#39;t do that, and neither does this implementation.</span></div>
<div class="line"><span class="comment">*/</span></div>
<div class="line"><span class="keyword">class </span>io_service</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:<span class="comment"></span></div>
<div class="line"><span class="comment">  //! The type of the i/o handler, same as ASIO</span></div>
<div class="line"><span class="comment"></span>  <span class="keyword">using</span> io_handler = void(std::error_code &amp;ec, <span class="keywordtype">size_t</span> bytes_transferred);</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">  std::mutex _lock;</div>
<div class="line">  std::deque&lt;std::packaged_task&lt;outcome::expected&lt;void&gt;(size_t)&gt;&gt; _work;</div>
<div class="line">  std::condition_variable _newwork;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Call the i/o handler at some future point in some future thread, returning immediately</span></div>
<div class="line">  outcome::expected&lt;std::future&lt;outcome::expected&lt;void&gt;&gt;, std::exception_ptr&gt; post(std::function&lt;io_handler&gt; f) noexcept</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Make a packaged task rebinding the completion handler</span></div>
<div class="line">      std::packaged_task&lt;outcome::expected&lt;void&gt;(size_t)&gt; rebound([f = std::move(f)](<span class="keywordtype">size_t</span> bytes_transferred)</div>
<div class="line">        -&gt;outcome::expected&lt;void&gt;</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Note we let exception throws be handled by the packaged_task</span></div>
<div class="line"></div>
<div class="line">        std::error_code ec;</div>
<div class="line">        <span class="comment">// Call the handler, if he returns an error code return that,</span></div>
<div class="line">        <span class="comment">// if he throws return the exception thrown</span></div>
<div class="line">        f(ec, bytes_transferred);</div>
<div class="line">        <span class="keywordflow">if</span> (ec)</div>
<div class="line">          <span class="keywordflow">return</span> outcome::make_unexpected(ec);</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">      });</div>
<div class="line">      <span class="comment">// Fetching the future can throw a STL exception</span></div>
<div class="line">      std::future&lt;outcome::expected&lt;void&gt;&gt; f(rebound.get_future());</div>
<div class="line">      {</div>
<div class="line">        std::lock_guard&lt;decltype(_lock)&gt; g(_lock);</div>
<div class="line">        <span class="comment">// Extending the deque can throw a STL exception</span></div>
<div class="line">        _work.push_back(std::move(rebound));</div>
<div class="line">        _newwork.notify_one();</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> std::move(f);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Return the exception thrown</span></div>
<div class="line">      <span class="keywordflow">return</span> outcome::make_unexpected(std::current_exception());</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line"></div>
<div class="line">  <span class="comment">/* Call the i/o handler in some thread, returning when it completes.</span></div>
<div class="line"><span class="comment">  Note that ASIO&#39;s io_service calls this dispatch(), but the Executors proposal calls it execute()</span></div>
<div class="line"><span class="comment">  */</span></div>
<div class="line">  outcome::expected&lt;void, outcome::expected&lt;std::error_code, std::exception_ptr&gt;&gt; execute(std::function&lt;io_handler&gt; f) noexcept</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// If post() returns a failure in its result, then this will throw</span></div>
<div class="line">      std::future&lt;outcome::expected&lt;void&gt;&gt; fut = post(std::move(f)).value();</div>
<div class="line">      <span class="comment">// Might rethrow any exception thrown by the handler, that will get caught below</span></div>
<div class="line">      outcome::expected&lt;void&gt; v = fut.get();</div>
<div class="line">      <span class="comment">// If the handler succeeded, return success, else return its error code</span></div>
<div class="line">      <span class="keywordflow">if</span> (v)</div>
<div class="line">        <span class="keywordflow">return</span> {};</div>
<div class="line">      <span class="keywordflow">return</span> outcome::make_unexpected(v.error());</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (<span class="keyword">const</span> outcome::bad_expected_access&lt;std::exception_ptr&gt; &amp;e)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// This called when post() failed internally to do the dispatch</span></div>
<div class="line">      <span class="keywordflow">return</span> outcome::make_unexpected(outcome::make_unexpected(e.error()));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (...)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Return the exception thrown</span></div>
<div class="line">      <span class="keywordflow">return</span> outcome::make_unexpected(outcome::make_unexpected(std::current_exception()));</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// If there are handlers pending, execute up to one of them</span></div>
<div class="line">  <span class="keywordtype">size_t</span> run_one() noexcept</div>
<div class="line">  {</div>
<div class="line">    std::unique_lock&lt;decltype(_lock)&gt; g(_lock);</div>
<div class="line">    <span class="keywordflow">if</span> (_work.empty())</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line">    std::packaged_task&lt;outcome::expected&lt;void&gt;(size_t)&gt; mywork(std::move(_work.front()));</div>
<div class="line">    _work.pop_front();</div>
<div class="line">    g.unlock();</div>
<div class="line">    <span class="comment">// Call the completion handler with some arbitrary bytes_transferred</span></div>
<div class="line">    mywork(78);</div>
<div class="line">    <span class="keywordflow">return</span> 1;</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// If there is no work, sleep until work arrives, else execute as much work as possible</span></div>
<div class="line">  <span class="keywordtype">size_t</span> run() noexcept</div>
<div class="line">  {</div>
<div class="line">    {</div>
<div class="line">      std::unique_lock&lt;decltype(_lock)&gt; g(_lock);</div>
<div class="line">      <span class="keywordflow">if</span> (_work.empty())</div>
<div class="line">      {</div>
<div class="line">        _newwork.wait(g);  <span class="comment">// allow spurious wakeups</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">size_t</span> executed = 0;</div>
<div class="line">    <span class="keywordflow">while</span> (run_one())</div>
<div class="line">      executed++;</div>
<div class="line">    <span class="keywordflow">return</span> executed;</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>work</div>
<div class="line">{</div>
<div class="line">  io_service *ios;</div>
<div class="line">  <span class="keywordtype">size_t</span> count;</div>
<div class="line">  constexpr work(io_service &amp;_ios) : ios(&amp;_ios), count(0) {}</div>
<div class="line">  <span class="keywordtype">void</span> operator()(std::error_code &amp;ec, <span class="keywordtype">size_t</span> bytes_transferred)</div>
<div class="line">  {</div>
<div class="line">    ++count;</div>
<div class="line">    <span class="keywordflow">if</span> (count &lt; 10000000)</div>
<div class="line">    {</div>
<div class="line">      <span class="comment">// Call myself again</span></div>
<div class="line">      <span class="keyword">auto</span> ret = ios-&gt;post(std::ref(*<span class="keyword">this</span>));</div>
<div class="line">      <span class="keywordflow">if</span> (!ret)</div>
<div class="line">        std::rethrow_exception(ret.error());</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  io_service ios;</div>
<div class="line">  std::vector&lt;work&gt; works(std::thread::hardware_concurrency(), work(ios));</div>
<div class="line">  std::vector&lt;std::thread&gt; threads;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> n = 0; n &lt; std::thread::hardware_concurrency(); n++)</div>
<div class="line">  {</div>
<div class="line">    threads.push_back(std::thread([&amp;ios] {</div>
<div class="line">      ios.run();</div>
<div class="line">    }));</div>
<div class="line">  }</div>
<div class="line">  std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> n = 0; n &lt; std::thread::hardware_concurrency(); n++)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> ret = ios.post(works[n]);</div>
<div class="line">    <span class="keywordflow">if</span> (!ret)</div>
<div class="line">      std::rethrow_exception(ret.error());</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;i : threads)</div>
<div class="line">    i.join();</div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment -->  </td></tr>
</table>
<p>You'll note how more convoluted the Expected implementation is, in particular the public API with the signature: </p>
<div class="fragment"><div class="line">outcome::expected&lt;void, outcome::expected&lt;std::error_code, std::exception_ptr&gt;&gt; execute(std::function&lt;io_handler&gt; f) noexcept;</div>
</div><!-- fragment --><p> This is a nested Expected used to transport one of two unexpected values. In real world usage of Expected you'll find yourself writing this more than you'd prefer and indeed a historical edition of the Expected proposal had special convenience semantics for them. The current proposal does not however, so you end up writing clunky code.</p>
<p>Indeed, it would be worse again if it weren't for the <code>std::future</code> being used to carry any exception throws for us which lets us skip a nested Expected. One could entirely and legitimately argue that the Expected implementation should simply rethrow any transported exceptions instead of messing around with nested Expected, however the "sea of noexcept" public API design would then be lost and the two examples no longer equivalent.</p>
<p>To conclude, this aspect of simplifying the programmer's effort to write "sea of noexcept" API designs is precisely what Outcome's refinements are intended for. If Outcome's refinements suit well your code base, they should let you write clearer, more maintainable and less buggy code. <em>Buen provecho!</em> </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
