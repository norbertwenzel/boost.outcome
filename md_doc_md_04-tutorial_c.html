<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>boost.outcome: Tutorial part C: Outcome&#39;s outcome&lt;T&gt;, result&lt;T&gt; and option&lt;T&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_md_04-tutorial_c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Tutorial part C: Outcome's outcome&lt;T&gt;, result&lt;T&gt; and option&lt;T&gt; </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#error_code_extended">Outcome's extended std::error_code</a></li>
<li class="level1"><a href="#outcome_overview">Outcome's outcome<T>, result<T> and option<T> refinements</a></li>
<li class="level1"><a href="#outcome_helpers">Outcome's helper free functions</a></li>
<li class="level1"><a href="#outcome_macros">Outcome's helper macros</a></li>
<li class="level1"><a href="#outcome_usage">Example of usage of the refinements</a></li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="tutorial_outcome"></a></p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>This section is not finished yet and may contain inaccurate or incorrect information.</dd></dl>
<p>Outcome provides a number of utility classes useful for ultra lightweight and constant time error handling in C++ 14 and later. One of these is <a class="el" href="md_doc_md_08-expectedsynopsis.html#outcome_expected_reference">a highly conforming expected&lt;T, E&gt; implementation</a> which is currently before the ISO C++ standards Library Evolution Working Group for standardisation. <code>expected&lt;T, E&gt;</code> is a very flexible and generic utility class allowing perhaps too much unwise customisation in the hands of its users, so Outcome also provides a family of more hard coded and deliberately less flexible refinements to <code>expected&lt;T, E&gt;</code> called <code>outcome&lt;T&gt;</code> and <code>result&lt;T&gt;</code> the use of which ought to generate more maintainable code bases and require less typing of boilerplate by the programmer.</p>
<p>This tutorial is therefore split into three parts:</p>
<ol type="1">
<li>The first part (<a class="el" href="md_doc_md_02-tutorial_a.html#tutorial_expected">part A</a>) provides a broad overview of error handling in C++ in general and how the <code>expected&lt;T, E&gt;</code> proposed for standardisation will contribute to that big menu of error handling design patterns available to the C++ programmer. This part isn't relevant to Outcome the library, but places it in context.</li>
<li>The second part (<a class="el" href="md_doc_md_03-tutorial_b.html#tutorial_whynot">part B</a>) describes why you probably ought to not use unrestricted <code>expected&lt;T, E&gt;</code> in any real world code base and why you ought to use the refinements of <code>outcome&lt;T&gt;</code> or <code>result&lt;T&gt;</code> instead.</li>
<li>The third part (part C, this part) walks you through using Outcome's refinements <code>outcome&lt;T&gt;</code> and <code>result&lt;T&gt;</code>, plus its <code>extended_error_code</code>. Usage is very similar to Expected, but with less typing and more convenient extensions.</li>
</ol>
<hr/>
<p><br/>
</p>
<p>Hopefully after part B you are persuaded to always <em>restrict</em> your use of <code>expected&lt;T, E&gt;</code> to one of:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> result = outcome::expected&lt;T, std::error_code&gt;;</div>
<div class="line"><span class="keyword">using</span> bad_result_access = outcome::bad_expected_access&lt;std::error_code&gt;;</div>
</div><!-- fragment --><p>... or ...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> result = outcome::expected&lt;T, std::exception_ptr&gt;;</div>
<div class="line"><span class="keyword">using</span> bad_result_access = outcome::bad_expected_access&lt;std::exception_ptr&gt;;</div>
</div><!-- fragment --><p>... where the latter is a superset of the former, because you can wrap any arbitrary <code>std::error_code</code> instance into a <code>std::exception_ptr</code> instance using the C++ 11 STL error code wrapping C++ exception type <code>std::system_error</code>:</p>
<div class="fragment"><div class="line">std::error_code ec;</div>
<div class="line">std::exception_ptr e = std::make_exception_ptr(std::system_error(ec));</div>
<div class="line"></div>
<div class="line"><span class="comment">// OR</span></div>
<div class="line"></div>
<div class="line">std::exception_ptr e = std::make_exception_ptr(std::system_error(ec, <span class="stringliteral">&quot;custom what() string&quot;</span>));</div>
</div><!-- fragment --><p>If you have been persuaded, then Outcome's hardcoded refinements of <code>expected&lt;T, E&gt;</code> are definitely for you. The remainder of this tutorial covers those refinements.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="error_code_extended"></a>
Outcome's extended std::error_code</h1>
<p>A lot of people find <code>std::error_code</code> too constraining and value their custom error types precisely because they can carry <em>payload</em> e.g. a custom string describing exactly the cause of the error, or maybe a backtrace of the exact offending call sequence leading to the error. They therefore reject the restriction to <code>std::error_code</code> as unsuitable for their use case.</p>
<p>Outcome provides an <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> refinement of <code>std::error_code</code> for exactly this situation. <code>error_code_extended</code> inherits publicly from <code>std::error_code</code>, adding three new member functionss: <code>extended_message()</code>, <code>raw_backtrace()</code> and <code>backtrace()</code>. These <em>may</em> provide additional information about the error code like any <code>what()</code> message from the C++ exception the error code was constructed from (if any), or the stack backtrace of the point at which the <code>error_code_extended</code> was constructed.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>error_code_extended : <span class="keyword">public</span> std::error_code</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  error_code_extended();</div>
<div class="line">  error_code_extended(<span class="keywordtype">int</span> ec, <span class="keyword">const</span> std::error_category &amp;cat,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>,  <span class="comment">// These are the extended payloads available</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> code1 = 0,</div>
<div class="line">    <span class="keywordtype">unsigned</span> code2 = 0,</div>
<div class="line">    <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <a class="code" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316">template &lt;class ErrorCodeEnum, typename = typename std::enable_if&lt;std::is_error_code_enum&lt;ErrorCodeEnum&gt;::value</a>&gt;::type&gt;</div>
<div class="line">    error_code_extended(ErrorCodeEnum e);</div>
<div class="line">  <span class="keyword">explicit</span> error_code_extended(<span class="keyword">const</span> std::error_code &amp;e,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>,  <span class="comment">// These are the extended payloads available</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> code1 = 0,</div>
<div class="line">    <span class="keywordtype">unsigned</span> code2 = 0,</div>
<div class="line">    <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <span class="keyword">explicit</span> error_code_extended(std::error_code &amp;&amp;e,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>,  <span class="comment">// These are the extended payloads available</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> code1 = 0,</div>
<div class="line">    <span class="keywordtype">unsigned</span> code2 = 0,</div>
<div class="line">    <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <span class="keywordtype">void</span> assign(<span class="keywordtype">int</span> ec, <span class="keyword">const</span> std::error_category &amp;cat,</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>,  <span class="comment">// These are the extended payloads available</span></div>
<div class="line">    <span class="keywordtype">unsigned</span> code1 = 0,</div>
<div class="line">    <span class="keywordtype">unsigned</span> code2 = 0,</div>
<div class="line">    <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <span class="keywordtype">void</span> clear();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// New member functions follow</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Fill a buffer with any extended error message and codes, returning bytes of buffer filled (zero if no extended message).</span></div>
<div class="line">  <span class="keywordtype">size_t</span> extended_message(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">size_t</span> len, <span class="keywordtype">unsigned</span> &amp;code1, <span class="keywordtype">unsigned</span> &amp;code2) <span class="keyword">const</span> noexcept;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Fill a buffer with any backtrace available, returning items filled if any.</span></div>
<div class="line">  <span class="keywordtype">size_t</span> raw_backtrace(<span class="keywordtype">void</span> **buffer, <span class="keywordtype">size_t</span> len) <span class="keyword">const</span> noexcept</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Returns an array of strings describing the backtrace. You must free() this after use.</span></div>
<div class="line">  <span class="keywordtype">char</span> **backtrace() const noexcept;</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="comment">// Prints the extended error code, including any extended information if available</span></div>
<div class="line">inline std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, const error_code_extended &amp;ec);</div>
</div><!-- fragment --><p><code>error_code_extended</code> is completely API compatible with <code>std::error_code</code> and all its member functions can be used the same way. You can supply a <code>std::error_code</code> to an extended error code, or else construct an extended error code the same way you would a STL error code. You should note that it is <b>always safe</b> to slice <code>error_code_extended</code> into an <code>std::error_code</code>, so you can safely feed <code>error_code_extended</code> to anything consuming a <code>std::error_code</code>. The important-to-optimisation implicit destructor of <code>std::error_code</code> is retained in <code>error_code_extended</code>.</p>
<p>The main big additions are obviously the ability to add a custom string message to an extended error code, this allows the preservation of the original <code>what()</code> message when converting a thrown exception into an extended error code. You can also add two arbitrary unsigned integer codes and most interestingly, a backtrace of the stack at the point of construction. The extended message and backtrace can be later fetched using the new member functions, though note that the storage for these is kept in a statically allocated threadsafe ring buffer and so may vanish at some arbitrary later point when the storage gets recycled. If this happens, <code>extended_message()</code> will return zero characters written, <code>raw_backtrace()</code> will return zero items filled and <code>backtrace()</code> will return a null pointer.</p>
<p>Because the storage for the extended information may be recycled at any arbitrary future point, you ought to make sure that you copy the extended information as soon as possible after the <code>error_code_extended</code> is constructed. In other words, don't store <code>error_code_extended</code> as-is into say a vector, instead extract the information into a custom struct as soon as you can.</p>
<dl class="section note"><dt>Note</dt><dd>Construction of an extended error code with extended message or codes takes a worst case maximum of a microsecond on recent hardware. That's a worst case, almost all of the time construction is in the low hundreds of nanoseconds range. Constructing an extended error code with backtrace takes a maximum of about 35 microseconds on a recent Ivy Bridge Intel CPU. <b>No memory allocation</b> is ever performed when constructing an extended error code, latency is always predictable. Construction of an extended error code without using the extended features is no additional overhead over <code>std::error_code</code>.</dd></dl>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="outcome_overview"></a>
Outcome's outcome&lt;T&gt;, result&lt;T&gt; and option&lt;T&gt; refinements</h1>
<p>Outcome provides additional refinements of <code>expected&lt;T, E&gt;</code> designed to make your programming life easier if you are willing to accept the hard coding of <code>E</code> to one of <code>error_code_extended</code> or <code>std::exception_ptr</code>. As a rough <b>semantic</b> map onto <code>optional&lt;T&gt;</code>, <code>variant&lt;...&gt;</code> and <code>expected&lt;T, E&gt;</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> <a class="code" href="group__monad.html#ga0d0fd5ca15cb339df9aa8e829a8ea5e0">option</a> = std::optional&lt;T&gt;;</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> result = std::optional&lt;</div>
<div class="line">  <a class="code" href="group__expected.html#ga7440167038cbd110405573cf2bd873ad">std::experimental::expected</a>&lt;</div>
<div class="line">    T,</div>
<div class="line">    error_code_extended</div>
<div class="line">  &gt;</div>
<div class="line">&gt;;</div>
<div class="line"></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> <a class="code" href="group__monad.html#gaab2ff6220205017226794529c863b336">outcome</a> = std::optional&lt;</div>
<div class="line">  <a class="code" href="group__expected.html#ga7440167038cbd110405573cf2bd873ad">std::experimental::expected</a>&lt;</div>
<div class="line">    T,</div>
<div class="line">    std::variant&lt;</div>
<div class="line">      error_code_extended,</div>
<div class="line">      std::exception_ptr</div>
<div class="line">    &gt;</div>
<div class="line">  &gt;</div>
<div class="line">&gt;;</div>
</div><!-- fragment --><p>Outcome's <code>outcome&lt;T&gt;</code>, <code>result&lt;T&gt;</code> and <code>option&lt;T&gt;</code> assume the error type is hard coded to the C++ 11 standard error transport infrastructure, and because they hard code this they can make a series of optimisations in design for you the programmer to save boilerplate, at compile time and at runtime which an <code>expected&lt;T, E&gt;</code> implementation can not. To spell it out:</p>
<ul>
<li><code>option&lt;T&gt;</code> can be empty, or hold an instance of a type <code>T</code>.</li>
<li><code>result&lt;T&gt;</code> can be empty, or hold an instance of a type <code>T</code>, or hold an instance of <code>error_code_extended</code>.</li>
<li><code>outcome&lt;T&gt;</code> can be empty, or hold an instance of a type <code>T</code>, or hold an instance of <code>error_code_extended</code>, or hold an instance of <code>std::exception_ptr</code>. This saves you having to wrap an error code into an exception pointer instance, thus also avoiding a memory allocation.</li>
</ul>
<p>Implicit conversion is permitted for any less representative form into any more representative form, so <code>option&lt;T&gt;</code> auto converts to a <code>result&lt;T&gt;</code> preserving exact contents, as does <code>result&lt;T&gt;</code> into an <code>outcome&lt;T&gt;</code>. This turns out to be very useful in large C++ codebases where the lowest layers tend to be written using <code>option&lt;T&gt;</code> and <code>result&lt;T&gt;</code>, whilst highest layers tend to be written using <code>outcome&lt;T&gt;</code> and C++ exception throws.</p>
<p>In Outcome's refinements which we shall call <em>transports</em>, an <em>empty</em> transport is empty, a <em>valued</em> transport contains a <code>T</code>, an <em>errored</em> transport contains an <code>error_code_extended</code> and an <em>excepted</em> transport contains a <code>std::exception_ptr</code>. All transports will throw a <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1monad__error.html">monad_error</a> type if you try doing something wrong instead of a <code>bad_expected_access&lt;E&gt;</code>. <code>monad_error</code> subclasses <code>std::system_error</code> with an error code of custom category <code>monad_category()</code>, with corresponding enumeration <a class="el" href="group__monad.html#gaf5abc43f8d09588556c4c65b53485c0d">monad_errc</a>, which can have one of two values:</p>
<ul>
<li><code>monad_errc::no_state</code> means you attempted to fetch a value, error or exception from an empty transport.</li>
<li><code>monad_errc::exception_present</code> is returned as the error code if you retrieve an error code from an excepted transport.</li>
</ul>
<p>This leads to the following differences to <code>expected&lt;T, E&gt;</code>:</p>
<ul>
<li>Outcome's refinements constexpr default construct to <b>empty</b>, not to a default constructed <code>T</code>. There is no "almost never empty" guarantee like with <code>expected&lt;T, E&gt;</code> or <code>variant&lt;...&gt;</code>, instead there is a formal empty state to do with as you please (in some situations, a function returning a value OR empty OR an error makes a lot of sense and Outcome supports a <code>tribool</code> extension for ternary logics for those who need such a thing). Attempting to retrieve a value, error or exception from an empty transport throws a <code>monad_error::no_state</code> [1].</li>
<li><code>.value()</code> on an errored transport directly throws a <code>std::system_error</code> with the error code [2] instead of throwing a wrapper type like <code>bad_expected_access</code> which you need to manually extract from later.</li>
<li><code>.value()</code> on an excepted transport directly rethrows the contents of the exception pointer [3] instead of throwing a wrapper type like <code>bad_expected_access</code> which you need to manually extract from later.</li>
<li><code>.error()</code> returns any <code>error_code_extended</code> as you'd expect, returning a default constructed (null) error code if the transport is valued, or <code>monad_errc::exception_present</code> if the transport is excepted.</li>
<li><code>.exception()</code> returns any <code>std::exception_ptr</code> as you'd expect. If the transport is valued, it returns a default constructed (null) exception pointer. If the transport is errored, it returns an exception pointer to a <code>std::system_error</code> wrapping the error code.</li>
</ul>
<p>And finally, if your compiler is in C++ 17 mode or later, transports are marked with the <a href="http://en.cppreference.com/w/cpp/language/attributes"><code>[[nodiscard]]</code></a> attribute. This means the compiler ought to warn if you forget to examine transports returned by functions. If you really mean to throw away a returned transport, make sure you cast it to <code>(void)</code> to tell the compiler you specifically intend to throw it away.</p>
<p>[1]: Actually the <code>BOOST_OUTCOME_THROW_MONAD_ERROR(monad_error(monad_errc::no_state))</code> macro is executed where <code>ec</code> is the <code>std::error_code</code> contained by the monad. This can be user redefined to do anything, but the default implementation throws a C++ exception of type <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1monad__error.html">monad_error</a> with code <a class="el" href="group__monad.html#gaf5abc43f8d09588556c4c65b53485c0d">monad_errc::no_state</a> if C++ exceptions are enabled by the compiler. If they are not, it prints a stack backtrace to stderr and aborts the process.</p>
<p>[2]: Similarly the <code>BOOST_OUTCOME_THROW_SYSTEM_ERROR(std::system_error(ec))</code> macro is actually executed where <code>ec</code> is the <code>error_code_extended</code> contained by the monad.</p>
<p>[3]: Similarly the <code>BOOST_OUTCOME_RETHROW_EXCEPTION(e)</code> macro is actually executed where <code>e</code> is the <code>std::exception_ptr</code> contained by the monad.</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="outcome_helpers"></a>
Outcome's helper free functions</h1>
<p>As with Expected, Outcome supplies helper free functions to make your life writing code with <code>option&lt;T&gt;</code>, <code>result&lt;T&gt;</code> and <code>expected&lt;T&gt;</code> easier. They are named a bit differently however, though the naming convention is straightforward. As with <code>expected&lt;void, E&gt;</code>, it is legal to be valued and of type <code>void</code>. Because a transport of type <code>void</code> is always considered less representative than any type <code>T</code>, any void transport will implicitly convert into any non-void transport, preserving any empty, errored or excepted state. This lets you conveniently write:</p>
<div class="fragment"><div class="line">result&lt;Foo&gt; somefunction()</div>
<div class="line">{</div>
<div class="line">  ...</div>
<div class="line">  <span class="keywordflow">if</span>(bad)</div>
<div class="line">    <span class="keywordflow">return</span> make_errored_result&lt;&gt;(...);  <span class="comment">// Note we didn&#39;t specify &lt;Foo&gt;</span></div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    <span class="keywordflow">return</span> Foo(...);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The full set of free functions is as follows: </p>
<dl>
<dt><code>make_(option|result|outcome)(T v)</code> </dt>
<dd>Makes a valued transport. </dd>
<dt><code>make_(option|result|outcome)&lt;T = void&gt;()</code> </dt>
<dd>Makes a valued transport default constructing a <code>T</code>. </dd>
<dt><code>make_empty_(option|result|outcome)&lt;T = void&gt;()</code> </dt>
<dd>Makes an empty transport. </dd>
<dt><code>make_errored_(result|outcome)&lt;T = void&gt;(error_code_extended ec)</code> </dt>
<dd>Makes an errored transport. </dd>
<dt><code>make_errored_(result|outcome)&lt;T = void&gt;(int code, const char *extendedmsg = nullptr)</code> </dt>
<dd>Makes an errored transport with the given error code of generic POSIX category and optionally some extended custom message which is copied into storage as per <code>error_code_extended</code>. This is very convenient for writing: <div class="fragment"><div class="line">result&lt;Foo&gt; somefunction()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(-1 == open(...))</div>
<div class="line">    <span class="keywordflow">return</span> make_errored_result&lt;&gt;(errno);</div>
<div class="line">}</div>
</div><!-- fragment -->  </dd>
<dt><code>make_errored_(result|outcome)&lt;T = void&gt;(DWORD code, const char *extendedmsg = nullptr)</code> (Windows only) </dt>
<dd>Makes an errored transport with the given error code of Win32 system category and optionally some extended custom message which is copied into storage as per <code>error_code_extended</code>. This is very convenient for writing: <div class="fragment"><div class="line">result&lt;Foo&gt; somefunction()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span>(INVALID_HANDLE_VALUE == CreateFile(...))</div>
<div class="line">    <span class="keywordflow">return</span> make_errored_result&lt;&gt;(GetLastError());</div>
<div class="line">}</div>
</div><!-- fragment -->  </dd>
<dt><code>make_excepted_outcome&lt;T = void&gt;(std::exception_ptr v = std::current_exception())</code> </dt>
<dd>Makes an excepted transport. This lets you conveniently write: <div class="fragment"><div class="line">outcome&lt;Foo&gt; somefunction()</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    ...</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(...)  <span class="comment">// catch all</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> make_excepted_outcome&lt;&gt;();  <span class="comment">// Defaults to std::current_exception()</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment -->  </dd>
<dt><code>as_(result|outcome)(option|result)</code> </dt>
<dd>Lets you formally annotate an implicit conversion from less representative to more representative. </dd>
<dt><code>as_void(const (option&lt;T&gt;|result&lt;T&gt;|outcome&lt;T&gt;|expected&lt;T, E&gt;) &amp;)</code> </dt>
<dd>Returns a copy of any input transport as a void version of the same transport, preserving any empty/errored/excepted state. If the input was valued, the returned copy will be valued void. </dd>
</dl>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="outcome_macros"></a>
Outcome's helper macros</h1>
<p>We've already seen in part B the helper macro <code>BOOST_OUTCOME_TRY(var, expr)</code> which also works with <code>expected&lt;T, E&gt;</code> when the error type in the returned transport is the same. Something unique to Outcome's refinements due to using <code>error_code_extended</code> is the convenience macro <code>BOOST_OUTCOME_CATCH_EXCEPTION_TO_RESULT</code> which is a long sequence of STL exception type catch clauses converting STL exception types into their equivalent POSIX error codes, preserving any custom <code>what()</code> message:</p>
<div class="fragment"><div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::invalid_argument &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EINVAL, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::domain_error &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EDOM, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::length_error &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(E2BIG, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::out_of_range &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(ERANGE, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::logic_error &amp;e) <span class="comment">/* base class for this group </span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EINVAL, e.what());</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">catch(const std::system_error &amp;e) /* also catches ios::failure </span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(BOOST_OUTCOME_V1_NAMESPACE::error_code_extended(e.code(), e.what()));</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">catch(const std::overflow_error &amp;e)</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EOVERFLOW, e.what());</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">catch(const std::range_error &amp;e)</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(ERANGE, e.what());</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">catch(const std::runtime_error &amp;e) /* base class for this group </span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EAGAIN, e.what());</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">catch(const std::bad_alloc &amp;e)</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(ENOMEM, e.what());</span></div>
<div class="line"><span class="comment">}</span></div>
<div class="line"><span class="comment">catch(const std::exception &amp;e)</span></div>
<div class="line"><span class="comment">{</span></div>
<div class="line"><span class="comment">  return BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EINVAL, e.what());</span></div>
<div class="line"><span class="comment">}</span></div>
</div><!-- fragment --><p>This macro is particularly useful when you are calling into the STL from a noexcept function which returns a <code>result&lt;T&gt;</code> and not an <code>outcome&lt;T&gt;</code>. So long as the code you call only ever will throw STL exception types, using this macro is safe and information loss free. Note that the above sequence does not include a catch all clause, so if you want one of those then use the <code>BOOST_OUTCOME_CATCH_ALL_EXCEPTION_TO_RESULT</code> macro which adds:</p>
<div class="fragment"><div class="line">... all the stuff from <a class="code" href="group__macro__helpers.html#gaacf14d3429ad0bc72a6ba40e7f283b43">BOOST_OUTCOME_CATCH_EXCEPTION_TO_RESULT</a> and then ...</div>
<div class="line">catch(...)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EAGAIN, <span class="stringliteral">&quot;unknown exception&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><hr/>
<p><br/>
</p>
<h1><a class="anchor" id="outcome_usage"></a>
Example of usage of the refinements</h1>
<p>todo </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
