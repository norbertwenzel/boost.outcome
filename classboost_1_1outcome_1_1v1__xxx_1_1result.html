<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>boost.outcome: boost::outcome::v1_xxx::result&lt; R &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classboost_1_1outcome_1_1v1__xxx_1_1result.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="classboost_1_1outcome_1_1v1__xxx_1_1result-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::outcome::v1_xxx::result&lt; R &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>result&lt;R&gt;</code> can hold a fixed variant list of empty, a type <code>R</code> or a lightweight <code>std::error_code</code> at a space cost of <code>max(24, sizeof(R)+8)</code>. This corresponds to <code>tribool::unknown</code>, <code>tribool::true_</code> and <code>tribool::false_</code> respectively. This specialisation looks deliberately like Rust's <code>Result&lt;T&gt;</code>.  
 <a href="classboost_1_1outcome_1_1v1__xxx_1_1result.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="monad_8hpp_source.html">monad.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for boost::outcome::v1_xxx::result&lt; R &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1outcome_1_1v1__xxx_1_1result.png" usemap="#boost::outcome::v1_xxx::result&lt; R &gt;_map" alt=""/>
  <map id="boost::outcome::v1_xxx::result&lt; R &gt;_map" name="boost::outcome::v1_xxx::result&lt; R &gt;_map">
<area href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html" alt="boost::outcome::v1_xxx::basic_monad&lt; policy::result_policy_base&lt; policy::basic_monad_storage&lt; policy::result_policy&lt; R &gt; &gt;, R, error_code_extended &gt; &gt;" shape="rect" coords="0,56,893,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4f95e33c88060309e9632fa997028010"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f95e33c88060309e9632fa997028010"></a>
typedef <br class="typebreak"/>
policy::result_policy_base<br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1policy_1_1basic__monad__storage.html">policy::basic_monad_storage</a><br class="typebreak"/>
&lt; policy::result_policy&lt; R &gt;<br class="typebreak"/>
 &gt;, R, <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> &gt;<br class="typebreak"/>
::<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a4f95e33c88060309e9632fa997028010">implementation_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a4f95e33c88060309e9632fa997028010">implementation_type</a></td></tr>
<tr class="memdesc:a4f95e33c88060309e9632fa997028010"><td class="mdescLeft">&#160;</td><td class="mdescRight">The final implementation type. <br/></td></tr>
<tr class="separator:a4f95e33c88060309e9632fa997028010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7a10f44f0f3321842176d2a58a1e87"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf7a10f44f0f3321842176d2a58a1e87"></a>
typedef <br class="typebreak"/>
value_storage_type::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a></td></tr>
<tr class="memdesc:acf7a10f44f0f3321842176d2a58a1e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type potentially held by the monad. <br/></td></tr>
<tr class="separator:acf7a10f44f0f3321842176d2a58a1e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909ec139fd9b9b150c2711985eb76477"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a909ec139fd9b9b150c2711985eb76477"></a>
typedef <br class="typebreak"/>
policy::result_policy_base<br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1policy_1_1basic__monad__storage.html">policy::basic_monad_storage</a><br class="typebreak"/>
&lt; policy::result_policy&lt; R &gt;<br class="typebreak"/>
 &gt;, R, <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> &gt;<br class="typebreak"/>
::<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a909ec139fd9b9b150c2711985eb76477">raw_value_type</a></td></tr>
<tr class="memdesc:a909ec139fd9b9b150c2711985eb76477"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw type potentially held by the monad. <br/></td></tr>
<tr class="separator:a909ec139fd9b9b150c2711985eb76477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42c5c45cf1f7726765680d47347bf461"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a42c5c45cf1f7726765680d47347bf461"></a>
typedef <br class="typebreak"/>
value_storage_type::error_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a42c5c45cf1f7726765680d47347bf461">error_type</a></td></tr>
<tr class="memdesc:a42c5c45cf1f7726765680d47347bf461"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error code potentially held by the monad. <br/></td></tr>
<tr class="separator:a42c5c45cf1f7726765680d47347bf461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d27b094471bf6eb9992eaf1eb3390b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a35d27b094471bf6eb9992eaf1eb3390b"></a>
typedef <br class="typebreak"/>
policy::result_policy_base<br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1policy_1_1basic__monad__storage.html">policy::basic_monad_storage</a><br class="typebreak"/>
&lt; policy::result_policy&lt; R &gt;<br class="typebreak"/>
 &gt;, R, <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> &gt;<br class="typebreak"/>
::<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a42c5c45cf1f7726765680d47347bf461">error_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a35d27b094471bf6eb9992eaf1eb3390b">raw_error_type</a></td></tr>
<tr class="memdesc:a35d27b094471bf6eb9992eaf1eb3390b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw error code potentially held by the monad. <br/></td></tr>
<tr class="separator:a35d27b094471bf6eb9992eaf1eb3390b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8455835eb8adf36b70e50d1bc119686"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae8455835eb8adf36b70e50d1bc119686"></a>
typedef <br class="typebreak"/>
value_storage_type::exception_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ae8455835eb8adf36b70e50d1bc119686">exception_type</a></td></tr>
<tr class="memdesc:ae8455835eb8adf36b70e50d1bc119686"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception ptr potentially held by the monad. <br/></td></tr>
<tr class="separator:ae8455835eb8adf36b70e50d1bc119686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9921f4a278c4cc472d5a7ee50797337f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9921f4a278c4cc472d5a7ee50797337f"></a>
typedef <br class="typebreak"/>
policy::result_policy_base<br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1policy_1_1basic__monad__storage.html">policy::basic_monad_storage</a><br class="typebreak"/>
&lt; policy::result_policy&lt; R &gt;<br class="typebreak"/>
 &gt;, R, <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> &gt;<br class="typebreak"/>
::<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ae8455835eb8adf36b70e50d1bc119686">exception_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a9921f4a278c4cc472d5a7ee50797337f">raw_exception_type</a></td></tr>
<tr class="memdesc:a9921f4a278c4cc472d5a7ee50797337f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The raw exception ptr potentially held by the monad. <br/></td></tr>
<tr class="separator:a9921f4a278c4cc472d5a7ee50797337f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51cfb4b55793524c391494f1fd3190d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a51cfb4b55793524c391494f1fd3190d3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a51cfb4b55793524c391494f1fd3190d3">rebind</a> = typename policy::result_policy_base&lt; <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1policy_1_1basic__monad__storage.html">policy::basic_monad_storage</a>&lt; policy::result_policy&lt; R &gt; &gt;, R, <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> &gt;::template <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a51cfb4b55793524c391494f1fd3190d3">rebind</a>&lt; U &gt;</td></tr>
<tr class="memdesc:a51cfb4b55793524c391494f1fd3190d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebind this monad type into a different value_type. <br/></td></tr>
<tr class="separator:a51cfb4b55793524c391494f1fd3190d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b74df5ca4ef2c07609adacea62d5ca3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4b74df5ca4ef2c07609adacea62d5ca3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>_is_constructible</b> = typename value_storage_type::template _is_constructible_from&lt; typename OtherMonad::raw_value_type, typename OtherMonad::raw_error_type, typename OtherMonad::raw_exception_type &gt;</td></tr>
<tr class="separator:a4b74df5ca4ef2c07609adacea62d5ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633613a661ada84fc4ac221a0b9c37eb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a633613a661ada84fc4ac221a0b9c37eb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>_is_comparable</b> = typename value_storage_type::template _is_comparable_to&lt; typename OtherMonad::raw_value_type, typename OtherMonad::raw_error_type, typename OtherMonad::raw_exception_type &gt;</td></tr>
<tr class="separator:a633613a661ada84fc4ac221a0b9c37eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad0b8ce85fae4169abc7519cf830fb194"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0b8ce85fae4169abc7519cf830fb194"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ad0b8ce85fae4169abc7519cf830fb194">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:ad0b8ce85fae4169abc7519cf830fb194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>true_(tribool(*this))</code> <br/></td></tr>
<tr class="separator:ad0b8ce85fae4169abc7519cf830fb194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab205222bc090ed4b41498432dc03b17"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab205222bc090ed4b41498432dc03b17"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#aab205222bc090ed4b41498432dc03b17">operator boost_lite::tribool::tribool</a> () const noexcept</td></tr>
<tr class="memdesc:aab205222bc090ed4b41498432dc03b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if monad contains a value_type, unknown if monad is empty, else false if monad is errored/excepted. <br/></td></tr>
<tr class="separator:aab205222bc090ed4b41498432dc03b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff2295edbbeec04c0b5421050f81621"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5ff2295edbbeec04c0b5421050f81621"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a5ff2295edbbeec04c0b5421050f81621">is_ready</a> () const noexcept</td></tr>
<tr class="memdesc:a5ff2295edbbeec04c0b5421050f81621"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if monad is not empty. <br/></td></tr>
<tr class="separator:a5ff2295edbbeec04c0b5421050f81621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb4201b875f7736743a00ae29b97637"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3cb4201b875f7736743a00ae29b97637"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a3cb4201b875f7736743a00ae29b97637">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a3cb4201b875f7736743a00ae29b97637"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if monad is empty. <br/></td></tr>
<tr class="separator:a3cb4201b875f7736743a00ae29b97637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a9e6d1cdfd40bfc9956a0f2362e860"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28a9e6d1cdfd40bfc9956a0f2362e860"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a28a9e6d1cdfd40bfc9956a0f2362e860">has_value</a> () const noexcept</td></tr>
<tr class="memdesc:a28a9e6d1cdfd40bfc9956a0f2362e860"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if monad contains a value_type. <br/></td></tr>
<tr class="separator:a28a9e6d1cdfd40bfc9956a0f2362e860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aca0f96409e1f7403d75d863732afc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2aca0f96409e1f7403d75d863732afc"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#aa2aca0f96409e1f7403d75d863732afc">has_error</a> () const noexcept</td></tr>
<tr class="memdesc:aa2aca0f96409e1f7403d75d863732afc"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if monad contains an error_type. <br/></td></tr>
<tr class="separator:aa2aca0f96409e1f7403d75d863732afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e1870612af23da5cc1dcbad6310023"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60e1870612af23da5cc1dcbad6310023"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a60e1870612af23da5cc1dcbad6310023">has_exception</a> (bool only_exception=false) const noexcept</td></tr>
<tr class="memdesc:a60e1870612af23da5cc1dcbad6310023"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if monad contains an exception_type or error_type (any error_type is returned as an exception_ptr by get_exception()). This needs to be true for both for compatibility with Boost.Thread's future. If you really want to test only for has exception only, pass true as the argument. <br/></td></tr>
<tr class="separator:a60e1870612af23da5cc1dcbad6310023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9eb4d9e54b8dd8bcd1539ebad40613"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b9eb4d9e54b8dd8bcd1539ebad40613"></a>
constexpr <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a3b9eb4d9e54b8dd8bcd1539ebad40613">get_or</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;v)&amp;noexcept</td></tr>
<tr class="memdesc:a3b9eb4d9e54b8dd8bcd1539ebad40613"><td class="mdescLeft">&#160;</td><td class="mdescRight">If contains a value_type, return that value type, else return the supplied value_type. <br/></td></tr>
<tr class="separator:a3b9eb4d9e54b8dd8bcd1539ebad40613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d065fdfe9655c15660df6b3363b659"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a43d065fdfe9655c15660df6b3363b659"></a>
constexpr const <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a43d065fdfe9655c15660df6b3363b659">get_or</a> (const <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;v) const &amp;noexcept</td></tr>
<tr class="memdesc:a43d065fdfe9655c15660df6b3363b659"><td class="mdescLeft">&#160;</td><td class="mdescRight">If contains a value_type, return that value type, else return the supplied value_type. <br/></td></tr>
<tr class="separator:a43d065fdfe9655c15660df6b3363b659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8bc8f0193414853e0a888ae02cc00d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f8bc8f0193414853e0a888ae02cc00d"></a>
constexpr <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a4f8bc8f0193414853e0a888ae02cc00d">get_or</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&amp;v)&amp;&amp;noexcept</td></tr>
<tr class="memdesc:a4f8bc8f0193414853e0a888ae02cc00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">If contains a value_type, return that value type, else return the supplied value_type. <br/></td></tr>
<tr class="separator:a4f8bc8f0193414853e0a888ae02cc00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf8beaed15f67e34a8fc763f8c4316b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3bf8beaed15f67e34a8fc763f8c4316b"></a>
constexpr const <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a3bf8beaed15f67e34a8fc763f8c4316b">get_or</a> (const <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&amp;v) const &amp;&amp;noexcept</td></tr>
<tr class="memdesc:a3bf8beaed15f67e34a8fc763f8c4316b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If contains a value_type, return that value type, else return the supplied value_type. <br/></td></tr>
<tr class="separator:a3bf8beaed15f67e34a8fc763f8c4316b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ac76326950d134a879a5aae3e33048"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac1ac76326950d134a879a5aae3e33048"></a>
constexpr <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ac1ac76326950d134a879a5aae3e33048">value_or</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;v)&amp;noexcept</td></tr>
<tr class="memdesc:ac1ac76326950d134a879a5aae3e33048"><td class="mdescLeft">&#160;</td><td class="mdescRight">If contains a value_type, return that value type, else return the supplied value_type. <br/></td></tr>
<tr class="separator:ac1ac76326950d134a879a5aae3e33048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba642a90ca2974c90c0487f91db417f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aba642a90ca2974c90c0487f91db417f9"></a>
constexpr const <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#aba642a90ca2974c90c0487f91db417f9">value_or</a> (const <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;v) const &amp;noexcept</td></tr>
<tr class="memdesc:aba642a90ca2974c90c0487f91db417f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">If contains a value_type, return that value type, else return the supplied value_type. <br/></td></tr>
<tr class="separator:aba642a90ca2974c90c0487f91db417f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bf79f0053d663f152fd34ecd1695de"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6bf79f0053d663f152fd34ecd1695de"></a>
constexpr <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#aa6bf79f0053d663f152fd34ecd1695de">value_or</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&amp;v)&amp;&amp;noexcept</td></tr>
<tr class="memdesc:aa6bf79f0053d663f152fd34ecd1695de"><td class="mdescLeft">&#160;</td><td class="mdescRight">If contains a value_type, return that value type, else return the supplied value_type. <br/></td></tr>
<tr class="separator:aa6bf79f0053d663f152fd34ecd1695de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bfe3ca1cba9a9eff36594bfadf5957"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77bfe3ca1cba9a9eff36594bfadf5957"></a>
constexpr const <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a77bfe3ca1cba9a9eff36594bfadf5957">value_or</a> (const <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&amp;v) const &amp;&amp;noexcept</td></tr>
<tr class="memdesc:a77bfe3ca1cba9a9eff36594bfadf5957"><td class="mdescLeft">&#160;</td><td class="mdescRight">If contains a value_type, return that value type, else return the supplied value_type. <br/></td></tr>
<tr class="separator:a77bfe3ca1cba9a9eff36594bfadf5957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65399387b0e250a5e0be7f4007610d8e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65399387b0e250a5e0be7f4007610d8e"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a65399387b0e250a5e0be7f4007610d8e">set_state</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1value__storage.html">value_storage_type</a> &amp;&amp;v)</td></tr>
<tr class="memdesc:a65399387b0e250a5e0be7f4007610d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disposes of any existing state, setting the monad to the value storage. <br/></td></tr>
<tr class="separator:a65399387b0e250a5e0be7f4007610d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf46a9c64aef8a3b39d0abe6f3875bc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbf46a9c64aef8a3b39d0abe6f3875bc"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#afbf46a9c64aef8a3b39d0abe6f3875bc">set_value</a> (const <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;v)</td></tr>
<tr class="memdesc:afbf46a9c64aef8a3b39d0abe6f3875bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disposes of any existing state, setting the monad to a copy of the value_type. <br/></td></tr>
<tr class="separator:afbf46a9c64aef8a3b39d0abe6f3875bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721ed5dd4e5f3c7f5fea054fa55e6eed"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a721ed5dd4e5f3c7f5fea054fa55e6eed"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a721ed5dd4e5f3c7f5fea054fa55e6eed">set_value</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a> &amp;&amp;v)</td></tr>
<tr class="memdesc:a721ed5dd4e5f3c7f5fea054fa55e6eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disposes of any existing state, setting the monad to a move of the value_type. <br/></td></tr>
<tr class="separator:a721ed5dd4e5f3c7f5fea054fa55e6eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04365e78c3bea78ac1009a9830e8f8f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04365e78c3bea78ac1009a9830e8f8f4"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a04365e78c3bea78ac1009a9830e8f8f4">set_value</a> ()</td></tr>
<tr class="memdesc:a04365e78c3bea78ac1009a9830e8f8f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disposes of any existing state, setting the monad to a default value. <br/></td></tr>
<tr class="separator:a04365e78c3bea78ac1009a9830e8f8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58a89310d0a79909e8849166de9a3ca"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa58a89310d0a79909e8849166de9a3ca"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#aa58a89310d0a79909e8849166de9a3ca">emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:aa58a89310d0a79909e8849166de9a3ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disposes of any existing state, setting the monad to an emplaced construction. <br/></td></tr>
<tr class="separator:aa58a89310d0a79909e8849166de9a3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4f989ad1132827ff4d4123dba89d78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9b4f989ad1132827ff4d4123dba89d78"></a>
constexpr <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a42c5c45cf1f7726765680d47347bf461">error_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a9b4f989ad1132827ff4d4123dba89d78">get_error_or</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a42c5c45cf1f7726765680d47347bf461">error_type</a> e) const noexcept</td></tr>
<tr class="memdesc:a9b4f989ad1132827ff4d4123dba89d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">If contains an error_type, returns that error_type else returns the error_type supplied. <br/></td></tr>
<tr class="separator:a9b4f989ad1132827ff4d4123dba89d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183417020bb9677db2f4e3a289c10fc3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a183417020bb9677db2f4e3a289c10fc3"></a>
constexpr <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a42c5c45cf1f7726765680d47347bf461">error_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a183417020bb9677db2f4e3a289c10fc3">error_or</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a42c5c45cf1f7726765680d47347bf461">error_type</a> e) const noexcept</td></tr>
<tr class="memdesc:a183417020bb9677db2f4e3a289c10fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If contains an error_type, returns that error_type else returns the error_type supplied. <br/></td></tr>
<tr class="separator:a183417020bb9677db2f4e3a289c10fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e7052fec846a489822333f61c36f50"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9e7052fec846a489822333f61c36f50"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ae9e7052fec846a489822333f61c36f50">set_error</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a42c5c45cf1f7726765680d47347bf461">error_type</a> v)</td></tr>
<tr class="memdesc:ae9e7052fec846a489822333f61c36f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disposes of any existing state, setting the monad to the error_type. <br/></td></tr>
<tr class="separator:ae9e7052fec846a489822333f61c36f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f5d3260a0f90e66aabb017dfe19fd6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6f5d3260a0f90e66aabb017dfe19fd6"></a>
constexpr <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ae8455835eb8adf36b70e50d1bc119686">exception_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ab6f5d3260a0f90e66aabb017dfe19fd6">get_exception_or</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ae8455835eb8adf36b70e50d1bc119686">exception_type</a> e) const noexcept</td></tr>
<tr class="memdesc:ab6f5d3260a0f90e66aabb017dfe19fd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If contains an exception_type, returns that exception_type else returns the exception_type supplied. <br/></td></tr>
<tr class="separator:ab6f5d3260a0f90e66aabb017dfe19fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dbd52682468fe80576ff3d4012402aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2dbd52682468fe80576ff3d4012402aa"></a>
constexpr <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ae8455835eb8adf36b70e50d1bc119686">exception_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a2dbd52682468fe80576ff3d4012402aa">exception_or</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ae8455835eb8adf36b70e50d1bc119686">exception_type</a> e) const noexcept</td></tr>
<tr class="memdesc:a2dbd52682468fe80576ff3d4012402aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If contains an exception_type, returns that exception_type else returns the exception_type supplied. <br/></td></tr>
<tr class="separator:a2dbd52682468fe80576ff3d4012402aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7e8869d61ec47a97f043eef35ecfb3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e7e8869d61ec47a97f043eef35ecfb3"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a0e7e8869d61ec47a97f043eef35ecfb3">set_exception</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ae8455835eb8adf36b70e50d1bc119686">exception_type</a> v)</td></tr>
<tr class="memdesc:a0e7e8869d61ec47a97f043eef35ecfb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disposes of any existing state, setting the monad to the exception_type. <br/></td></tr>
<tr class="separator:a0e7e8869d61ec47a97f043eef35ecfb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d963cdef2f990e78fa51b50b0e7c67"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a59d963cdef2f990e78fa51b50b0e7c67"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a59d963cdef2f990e78fa51b50b0e7c67">set_exception</a> (E &amp;&amp;e)</td></tr>
<tr class="memdesc:a59d963cdef2f990e78fa51b50b0e7c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disposes of any existing state, setting the monad to make_exception_type(forward&lt;E&gt;(e)) <br/></td></tr>
<tr class="separator:a59d963cdef2f990e78fa51b50b0e7c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15484c4e305f7faa02a2ba0d9ae5e96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa15484c4e305f7faa02a2ba0d9ae5e96"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#aa15484c4e305f7faa02a2ba0d9ae5e96">swap</a> (<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">basic_monad</a> &amp;o) noexcept(<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a1e3c7c16642a47ec1efe83c99cace63c">is_nothrow_move_constructible</a>)</td></tr>
<tr class="memdesc:aa15484c4e305f7faa02a2ba0d9ae5e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps one monad for another. <br/></td></tr>
<tr class="separator:aa15484c4e305f7faa02a2ba0d9ae5e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8049a603883792f145794580e96e64e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8049a603883792f145794580e96e64e9"></a>
constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a8049a603883792f145794580e96e64e9">clear</a> () noexcept(<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a73875e12dc7a120a73529ccfae94b7ea">is_nothrow_destructible</a>)</td></tr>
<tr class="memdesc:a8049a603883792f145794580e96e64e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructs any state stored, resetting to empty. <br/></td></tr>
<tr class="separator:a8049a603883792f145794580e96e64e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a7100a0bd6d01e90f194bbcf1facdf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae0a7100a0bd6d01e90f194bbcf1facdf"></a>
const <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1value__storage.html">value_storage_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>__storage</b> () const noexcept</td></tr>
<tr class="separator:ae0a7100a0bd6d01e90f194bbcf1facdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functional programming extensions (optional)</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>If contains a value_type, returns a lvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type.</p>
<p>If contains a value_type, returns a const lvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type. If contains a value_type, returns a rvalue reference to it, else throws an exception of monad_error(no_state), system_error or the exception_type. If contains an error_type, returns that error_type. If contains an error, returns an error code of <code>monad_errc::exception_present</code>. Otherwise returns a null error_type. Can only throw the exception monad_error(no_state) if empty. If contains an exception_type, returns that exception_type. If contains an error_type, returns system_error(error_type). If contains a value_type, returns a null exception_type. Can only throw the exception monad_error(no_state) if empty.</p>
<dl class="section note"><dt>Note</dt><dd>All code in this section can be enabled by defining BOOST_OUTCOME_ENABLE_ADVANCED. By default only next() is available. This prevents you writing code which impacts build times.</dd></dl>
<p>Classic monadic programming consists of a sequence of nested functional operations: </p>
<dl>
<dt>JOIN (single): outcome&lt;outcome&lt;T&gt;&gt;.get() -&gt; outcome&lt;T&gt; </dt>
<dd></dd>
<dt>JOIN (maximum): outcome&lt;outcome&lt;outcome&lt;outcome&lt;T&gt;&gt;&gt;&gt;.unwrap() -&gt; outcome&lt;T&gt; </dt>
<dd>Whatever is the first monad containing a non-monad is returned. </dd>
<dt>MAP: outcome&lt;T&gt;.map(R(T)) -&gt; outcome&lt;R&gt; </dt>
<dd>If callable maps T to R, map() maps a outcome&lt;T&gt; to a outcome&lt;R&gt; if outcome&lt;T&gt; contains a T. If it contains an error or is empty, that is passed through. </dd>
<dt>BIND: outcome&lt;T&gt;.bind(outcome&lt;R&gt;(T)) -&gt; outcome&lt;R&gt; </dt>
<dd></dd>
<dt>BIND: outcome&lt;T&gt;.bind(R(T)) -&gt; outcome&lt;R&gt; </dt>
<dd>If callable maps T to outcome&lt;R&gt; and if outcome&lt;T&gt; contains a T, then bind() maps a outcome&lt;T&gt; to a outcome&lt;R&gt; else if callable maps T to R and if outcome&lt;T&gt; contains a T, bind() maps a outcome&lt;T&gt; to a outcome&lt;R&gt;. In other words, returning a monad from the callable does not wrap it in another monad. If the originating monad did not contain a T, that is passed through. </dd>
</dl>
<p>We also support outcome&lt;T&gt;.next(R(outcome&lt;T&gt;)) for semantic equivalence to futures where the callable is called with the originating monad. This acts like bind(), so if the callable returns a monad it is not wrapped in another monad. Unlike map() or bind(), next() always calls the callable no matter what the monad contains, so it is up to you to interrogate the monad. Note that the originating monad is passed by const lvalue ref unless the callable takes a rvalue ref to the monad.</p>
<p>A quick use example: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; outcome&lt;T&gt; do_test(outcome&lt;T&gt; m)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The value of my input monad is &quot;</span>;</div>
<div class="line">  <span class="keywordflow">if</span>(m)</div>
<div class="line">    std::cout &lt;&lt; m.value() &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; (m.has_error() ? <span class="stringliteral">&quot;errored&quot;</span> : m.has_exception() ? <span class="stringliteral">&quot;excepted&quot;</span> : <span class="stringliteral">&quot;empty&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">  </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  or via bind(), my value is &quot;</span>;</div>
<div class="line">  <span class="keyword">auto</span> o(m &gt;&gt; [](T v) { std::cout &lt;&lt; v; <span class="keywordflow">return</span> v; }</div>
<div class="line">           &gt;&gt; [](error_code_extended e) { std::cout &lt;&lt; <span class="stringliteral">&quot;errored&quot;</span>; <span class="keywordflow">return</span> e; }</div>
<div class="line">           &gt;&gt; [](std::exception_ptr e) { std::cout &lt;&lt; <span class="stringliteral">&quot;excepted&quot;</span>; <span class="keywordflow">return</span> e; }</div>
<div class="line">           &gt;&gt; [](<span class="keyword">typename</span> decltype(m)::empty_type) { std::cout &lt;&lt; <span class="stringliteral">&quot;empty&quot;</span>; });</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> o;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">  <span class="keyword">struct </span>o_type</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> expected;</div>
<div class="line">    <span class="comment">// monad.match() will call an overload for each possible content it might have</span></div>
<div class="line">    <span class="keywordtype">void</span> operator()(<span class="keywordtype">int</span> <span class="comment">/*unused*/</span>)<span class="keyword"> const </span>{ BOOST_CHECK(expected == 1); }</div>
<div class="line">    <span class="keywordtype">void</span> operator()(error_code_extended <span class="comment">/*unused*/</span>)<span class="keyword"> const </span>{ BOOST_CHECK(expected == 2); }</div>
<div class="line">    <span class="keywordtype">void</span> operator()(std::exception_ptr <span class="comment">/*unused*/</span>)<span class="keyword"> const </span>{ BOOST_CHECK(expected == 3); }  <span class="comment">// NOLINT</span></div>
<div class="line">    <span class="keywordtype">void</span> operator()(outcome&lt;int&gt;::empty_type <span class="comment">/*unused*/</span>)<span class="keyword"> const </span>{ BOOST_CHECK(expected == 4); }</div>
<div class="line">    o_type()</div>
<div class="line">        : expected(0)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">  } o;</div>
<div class="line">  error_code_extended ec;</div>
<div class="line">  std::exception_ptr e;</div>
<div class="line">  outcome&lt;int&gt; a(5);</div>
<div class="line">  o.expected = 1;</div>
<div class="line">  (void) a.match(o);</div>
<div class="line">  o.expected = 2;</div>
<div class="line">  a = ec;</div>
<div class="line">  (void) a.match(o);</div>
<div class="line">  o.expected = 3;</div>
<div class="line">  a = e;</div>
<div class="line">  (void) a.match(o);</div>
<div class="line">  o.expected = 4;</div>
<div class="line">  a.clear();</div>
<div class="line">  (void) a.match(o);</div>
</div><!-- fragment --><div class="fragment"><div class="line">  {</div>
<div class="line">    error_code_extended ec;</div>
<div class="line">    outcome&lt;int&gt; a(5);</div>
<div class="line">    outcome&lt;int&gt; b(a &amp; 6);   <span class="comment">// a has a value, so become 6</span></div>
<div class="line">    outcome&lt;int&gt; c(b | 4);   <span class="comment">// b has a value, so remain at 6</span></div>
<div class="line">    outcome&lt;int&gt; d(a &amp; ec);  <span class="comment">// a has a value, so become errored</span></div>
<div class="line">    outcome&lt;int&gt; e(d &amp; 2);   <span class="comment">// d does not have a value, so remain errored</span></div>
<div class="line">    outcome&lt;int&gt; f(d | 2);   <span class="comment">// d does not have a value, so become 2</span></div>
<div class="line">    BOOST_CHECK(b.get() == 6);</div>
<div class="line">    BOOST_CHECK(c.get() == 6);</div>
<div class="line">    BOOST_CHECK(d.has_error());</div>
<div class="line">    BOOST_CHECK(e.has_error());</div>
<div class="line">    BOOST_CHECK(f.get() == 2);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  error_code_extended ec;</div>
<div class="line">  {</div>
<div class="line">    outcome&lt;std::string&gt; a(<span class="stringliteral">&quot;niall&quot;</span>);</div>
<div class="line">    <span class="comment">// Does bind work with chains of value, error, exception and empty?</span></div>
<div class="line">    <span class="keyword">auto</span> x(a &gt;&gt; [ec](std::string) { <span class="keywordflow">return</span> ec; }                              <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](error_code_extended) { <span class="keywordflow">return</span> std::make_exception_ptr(5); }  <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](std::exception_ptr) { <span class="keywordflow">return</span>; }                              <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](outcome&lt;std::string&gt;::empty_type) { <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;douglas&quot;</span>); });</div>
<div class="line">    BOOST_CHECK(x.get() == <span class="stringliteral">&quot;douglas&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> y(a &gt;&gt; [ec](std::string) -&gt; outcome&lt;int&gt; { <span class="keywordflow">return</span> ec; }                                        <span class="comment">//</span></div>
<div class="line">                                     &gt;&gt; [](error_code_extended) { <span class="keywordflow">return</span> std::make_exception_ptr(5); }  <span class="comment">//</span></div>
<div class="line">                                     &gt;&gt; [](std::exception_ptr) { <span class="keywordflow">return</span>; }                              <span class="comment">//</span></div>
<div class="line">                                     &gt;&gt; [](outcome&lt;int&gt;::empty_type) { <span class="keywordflow">return</span> 5; });</div>
<div class="line">    BOOST_CHECK(y.get() == 5);</div>
<div class="line">    <span class="keyword">auto</span> z(a &gt;&gt; [](std::string &amp;&amp;v) { <span class="keywordflow">return</span> std::move(v); }  <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](std::string &amp;&amp;v) { <span class="keywordflow">return</span> std::move(v); }    <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](std::string &amp;&amp;v) { <span class="keywordflow">return</span> std::move(v); }    <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](std::string &amp;&amp;v) { <span class="keywordflow">return</span> std::move(v); });</div>
<div class="line">    BOOST_CHECK(z.get() == <span class="stringliteral">&quot;niall&quot;</span>);</div>
<div class="line">    BOOST_CHECK(a.get().empty());</div>
<div class="line">  }</div>
</div><!-- fragment --><p> You will note in the code example that the type of the callable for bind() and map() determines what operation happens. Here are the rules:</p>
<ul>
<li>If the monad contains a T and the callable takes a T or an <code>auto</code>, then:<ul>
<li>If the callable takes a T or any reference to a T which isn't an rvalue reference, the T is passed by const lvalue reference (i.e. copy semantics).</li>
<li>If the callable takes a T by non-const rvalue reference, the T is passed by rvalue ref. This lets you move from the value held by the originating monad if so desired.</li>
<li>If the callable takes the originating monad or any reference to such which isn't a rvalue reference, then the originating monad is passed by const lvalue reference.</li>
<li>If the callable takes the originating monad by non-const rvalue reference, the originating monad is passed by rvalue reference. The ability to take the originating monad makes bind() identical to next() though much harder on build times. Note that these options let you rebind the type of the monad, so if your callable returns a different type from the originating monad then the resulting monad is based on that different return type. <dl class="section warning"><dt>Warning</dt><dd>The current implementation requires you to specify a non-dependent return type for all generic lambdas, else you'll get compile errors where the compiler tried to insert <code>error_type</code>, <code>exception_type</code> etc when it was trying to figure out if the return type is correct. A future implementation (once VS2015 has Expression SFINAE) may remove this restriction, until then just hard specify your return types if your lambdas take an <code>auto</code>, or use lambdas not taking <code>auto</code>.</dd></dl>
</li>
</ul>
</li>
<li>If the monad contains an <code>error_type</code> and the callable takes an <code>error_type</code>, then call the callable, else pass through the monad. For this reason, any callable taking an <code>error_type</code> must always return the same monad type as the originating monad.</li>
<li>If the monad contains an <code>error_type</code> or an <code>exception_type</code> and the callable takes an <code>exception_type</code>, then call the callable, else pass through the monad. For this reason, any callable taking an <code>exception_type</code> must always return the same monad type as the originating monad.</li>
<li>If the monad is empty and the callable takes an <code>empty_type</code>, then call the callable, else pass through the monad. For this reason, any callable with an <code>empty_type</code> parameter must always return the same monad type as the originating monad.</li>
</ul>
<p>Note that for nested monads e.g. outcome&lt;outcome&lt;int&gt;&gt;, either or both of the inner or outer monads can be with value or with error or empty. You should have your binds and maps work appropriately.</p>
<p>For maximum build performance, try to avoid bind() and map() as these use some hefty metaprogramming to deduce what kind of bind and map you're doing based on the callables passed. unwrap() is implemented using a recursively expanded structure which is probably okay for low unwrap depths. next() is probably the least weighty of the monadic operators as it's relatively dumb and the only metaprogramming is to determine whether to wrap the return type with a monad or not.</p>
<h3>Acknowledgements</h3>
<p>To T.C. on Stack Overflow for answering my question at <a href="https://stackoverflow.com/questions/30802404/how-to-detect-whether-some-callable-takes-a-rvalue-reference">https://stackoverflow.com/questions/30802404/how-to-detect-whether-some-callable-takes-a-rvalue-reference</a> and without whose excellent answer the intelligent map() and bind() above could not work. </p>
</div></td></tr>
<tr class="memitem:afc4f2c19ecec524ca76890e9bf75c656"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc4f2c19ecec524ca76890e9bf75c656"></a>
<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">basic_monad</a>&lt;...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#afc4f2c19ecec524ca76890e9bf75c656">operator&gt;&gt;</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:afc4f2c19ecec524ca76890e9bf75c656"><td class="mdescLeft">&#160;</td><td class="mdescRight">If bool(*this), return basic_monad(F(get())).unwrap, else return basic_monad&lt;result_of&lt;F(get())&gt;&gt;(error) <br/></td></tr>
<tr class="separator:afc4f2c19ecec524ca76890e9bf75c656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53108eba9c8978443fd0e41f9cdcc3de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">basic_monad</a>&lt;...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a53108eba9c8978443fd0e41f9cdcc3de">next</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a53108eba9c8978443fd0e41f9cdcc3de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return basic_monad(F(*this)) or F(*this) if the latter returns a monad.  <a href="#a53108eba9c8978443fd0e41f9cdcc3de">More...</a><br/></td></tr>
<tr class="separator:a53108eba9c8978443fd0e41f9cdcc3de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0176175c0401f7546b2a8c96ac25cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1c0176175c0401f7546b2a8c96ac25cb"></a>
<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">basic_monad</a>&lt;...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a1c0176175c0401f7546b2a8c96ac25cb">unwrap</a> () const &amp;</td></tr>
<tr class="memdesc:a1c0176175c0401f7546b2a8c96ac25cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If I am a basic_monad&lt;basic_monad&lt;...&gt;&gt;, return copy of most nested basic_monad&lt;...&gt;, else return copy of *this. <br/></td></tr>
<tr class="separator:a1c0176175c0401f7546b2a8c96ac25cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb65315259fe108cea2965c98250fd2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adeb65315259fe108cea2965c98250fd2"></a>
<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">basic_monad</a>&lt;...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#adeb65315259fe108cea2965c98250fd2">unwrap</a> ()&amp;&amp;</td></tr>
<tr class="memdesc:adeb65315259fe108cea2965c98250fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">If I am a basic_monad&lt;basic_monad&lt;...&gt;&gt;, return move of most nested basic_monad&lt;...&gt;, else return move of *this. <br/></td></tr>
<tr class="separator:adeb65315259fe108cea2965c98250fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afe316f28f9af74970b89b75e30a28a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1afe316f28f9af74970b89b75e30a28a"></a>
<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">basic_monad</a>&lt;...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a1afe316f28f9af74970b89b75e30a28a">bind</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a1afe316f28f9af74970b89b75e30a28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If bool(*this), return basic_monad(F(get())).unwrap, else return basic_monad&lt;result_of&lt;F(get())&gt;&gt;(error) <br/></td></tr>
<tr class="separator:a1afe316f28f9af74970b89b75e30a28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4191034be4c90a5447a6677472d3ab18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4191034be4c90a5447a6677472d3ab18"></a>
<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">basic_monad</a>&lt;...&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a4191034be4c90a5447a6677472d3ab18">map</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:a4191034be4c90a5447a6677472d3ab18"><td class="mdescLeft">&#160;</td><td class="mdescRight">If bool(*this), return basic_monad(F(get())), else return basic_monad&lt;result_of&lt;F(get())&gt;&gt;(error) <br/></td></tr>
<tr class="separator:a4191034be4c90a5447a6677472d3ab18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab4756c7e94044e6314ed17697d6aa1af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4756c7e94044e6314ed17697d6aa1af"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ab4756c7e94044e6314ed17697d6aa1af">has_value_type</a></td></tr>
<tr class="memdesc:ab4756c7e94044e6314ed17697d6aa1af"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad has a value_type. <br/></td></tr>
<tr class="separator:ab4756c7e94044e6314ed17697d6aa1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e0cb095cd00aacc2c8e71affe1385a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85e0cb095cd00aacc2c8e71affe1385a"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a85e0cb095cd00aacc2c8e71affe1385a">has_error_type</a></td></tr>
<tr class="memdesc:a85e0cb095cd00aacc2c8e71affe1385a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad has an error_type. <br/></td></tr>
<tr class="separator:a85e0cb095cd00aacc2c8e71affe1385a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a6a6fd54c07189c0a9c81d67d078d0e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0a6a6fd54c07189c0a9c81d67d078d0e"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a0a6a6fd54c07189c0a9c81d67d078d0e">has_exception_type</a></td></tr>
<tr class="memdesc:a0a6a6fd54c07189c0a9c81d67d078d0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad has an exception_type. <br/></td></tr>
<tr class="separator:a0a6a6fd54c07189c0a9c81d67d078d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb1a02af737f7072080f4682b788413"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4eb1a02af737f7072080f4682b788413"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a4eb1a02af737f7072080f4682b788413">is_default_constructible</a></td></tr>
<tr class="memdesc:a4eb1a02af737f7072080f4682b788413"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad can be default constructed. <br/></td></tr>
<tr class="separator:a4eb1a02af737f7072080f4682b788413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd33742f65b90d608737848e76bcfeb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcd33742f65b90d608737848e76bcfeb"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#afcd33742f65b90d608737848e76bcfeb">is_nothrow_default_constructible</a></td></tr>
<tr class="memdesc:afcd33742f65b90d608737848e76bcfeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad will never throw exceptions during default construction. <br/></td></tr>
<tr class="separator:afcd33742f65b90d608737848e76bcfeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d53145bb8ea17b8a3f782b2f49b68bf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d53145bb8ea17b8a3f782b2f49b68bf"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a6d53145bb8ea17b8a3f782b2f49b68bf">is_copy_constructible</a></td></tr>
<tr class="memdesc:a6d53145bb8ea17b8a3f782b2f49b68bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad can be copy constructed. <br/></td></tr>
<tr class="separator:a6d53145bb8ea17b8a3f782b2f49b68bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab766f97321f577abff1283a778decdb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab766f97321f577abff1283a778decdb5"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ab766f97321f577abff1283a778decdb5">is_nothrow_copy_constructible</a></td></tr>
<tr class="memdesc:ab766f97321f577abff1283a778decdb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad will never throw exceptions during copy construction. <br/></td></tr>
<tr class="separator:ab766f97321f577abff1283a778decdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52504874b9b5cc1f0888f9983af373ef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a52504874b9b5cc1f0888f9983af373ef"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a52504874b9b5cc1f0888f9983af373ef">is_move_constructible</a></td></tr>
<tr class="memdesc:a52504874b9b5cc1f0888f9983af373ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad can be move constructed. <br/></td></tr>
<tr class="separator:a52504874b9b5cc1f0888f9983af373ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3c7c16642a47ec1efe83c99cace63c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1e3c7c16642a47ec1efe83c99cace63c"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a1e3c7c16642a47ec1efe83c99cace63c">is_nothrow_move_constructible</a></td></tr>
<tr class="memdesc:a1e3c7c16642a47ec1efe83c99cace63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad will never throw exceptions during move construction. <br/></td></tr>
<tr class="separator:a1e3c7c16642a47ec1efe83c99cace63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ac8ebdbb2ff2ce57d9527b4917194e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20ac8ebdbb2ff2ce57d9527b4917194e"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a20ac8ebdbb2ff2ce57d9527b4917194e">is_nothrow_copy_assignable</a></td></tr>
<tr class="memdesc:a20ac8ebdbb2ff2ce57d9527b4917194e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad will never throw exceptions during copy assignment. <br/></td></tr>
<tr class="separator:a20ac8ebdbb2ff2ce57d9527b4917194e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6c3c6d03883ac95bc0160752f43095"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d6c3c6d03883ac95bc0160752f43095"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a7d6c3c6d03883ac95bc0160752f43095">is_nothrow_move_assignable</a></td></tr>
<tr class="memdesc:a7d6c3c6d03883ac95bc0160752f43095"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad will never throw exceptions during move assignment. <br/></td></tr>
<tr class="separator:a7d6c3c6d03883ac95bc0160752f43095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73875e12dc7a120a73529ccfae94b7ea"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a73875e12dc7a120a73529ccfae94b7ea"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a73875e12dc7a120a73529ccfae94b7ea">is_nothrow_destructible</a></td></tr>
<tr class="memdesc:a73875e12dc7a120a73529ccfae94b7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad will never throw exceptions during destruction. <br/></td></tr>
<tr class="separator:a73875e12dc7a120a73529ccfae94b7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6016982a331c03cd0e98c7097197109"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6016982a331c03cd0e98c7097197109"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ab6016982a331c03cd0e98c7097197109">is_trivially_destructible</a></td></tr>
<tr class="memdesc:ab6016982a331c03cd0e98c7097197109"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad does not implement a destructor. <br/></td></tr>
<tr class="separator:ab6016982a331c03cd0e98c7097197109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76263c865d70f2783cc64c528af2e98b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a76263c865d70f2783cc64c528af2e98b"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a76263c865d70f2783cc64c528af2e98b">is_constructible</a></td></tr>
<tr class="memdesc:a76263c865d70f2783cc64c528af2e98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad is constructible from the monad specified. <br/></td></tr>
<tr class="separator:a76263c865d70f2783cc64c528af2e98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6769b63365fbe576ef6523c5cdf36dd0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6769b63365fbe576ef6523c5cdf36dd0"></a>
static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a6769b63365fbe576ef6523c5cdf36dd0">is_comparable</a></td></tr>
<tr class="memdesc:a6769b63365fbe576ef6523c5cdf36dd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This monad is comparable to the monad specified. Note this is as if ThisMonad::operator==(OtherMonad), so without associativity i.e. is this monad comparable to the other monad which != the other monad is comparable to this monad. <br/></td></tr>
<tr class="separator:a6769b63365fbe576ef6523c5cdf36dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:af4b06d159ef7316a925cf02b83c47c3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4b06d159ef7316a925cf02b83c47c3f"></a>
typedef <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1value__storage.html">value_storage</a><br class="typebreak"/>
&lt; typename <br class="typebreak"/>
policy::result_policy_base<br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1policy_1_1basic__monad__storage.html">policy::basic_monad_storage</a><br class="typebreak"/>
&lt; policy::result_policy&lt; R &gt;<br class="typebreak"/>
 &gt;, R, <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> &gt;<br class="typebreak"/>
::<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#acf7a10f44f0f3321842176d2a58a1e87">value_type</a>, typename <br class="typebreak"/>
policy::result_policy_base<br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1policy_1_1basic__monad__storage.html">policy::basic_monad_storage</a><br class="typebreak"/>
&lt; policy::result_policy&lt; R &gt;<br class="typebreak"/>
 &gt;, R, <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> &gt;<br class="typebreak"/>
::<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#a42c5c45cf1f7726765680d47347bf461">error_type</a>, typename <br class="typebreak"/>
policy::result_policy_base<br class="typebreak"/>
&lt; <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1policy_1_1basic__monad__storage.html">policy::basic_monad_storage</a><br class="typebreak"/>
&lt; policy::result_policy&lt; R &gt;<br class="typebreak"/>
 &gt;, R, <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> &gt;<br class="typebreak"/>
::<a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html#ae8455835eb8adf36b70e50d1bc119686">exception_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>value_storage_type</b></td></tr>
<tr class="separator:af4b06d159ef7316a925cf02b83c47c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename R&gt;<br/>
class boost::outcome::v1_xxx::result&lt; R &gt;</h3>

<p><code>result&lt;R&gt;</code> can hold a fixed variant list of empty, a type <code>R</code> or a lightweight <code>std::error_code</code> at a space cost of <code>max(24, sizeof(R)+8)</code>. This corresponds to <code>tribool::unknown</code>, <code>tribool::true_</code> and <code>tribool::false_</code> respectively. This specialisation looks deliberately like Rust's <code>Result&lt;T&gt;</code>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a53108eba9c8978443fd0e41f9cdcc3de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">basic_monad</a>&lt;...&gt; <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1basic__monad.html">boost::outcome::v1_xxx::basic_monad</a>&lt; policy::result_policy_base&lt; <a class="el" href="structboost_1_1outcome_1_1v1__xxx_1_1policy_1_1basic__monad__storage.html">policy::basic_monad_storage</a>&lt; policy::result_policy&lt; R &gt; &gt;, R, <a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1error__code__extended.html">error_code_extended</a> &gt;  &gt;::next </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return basic_monad(F(*this)) or F(*this) if the latter returns a monad. </p>
<p>The callable F needs to consume a monad obviously enough, however if your callable takes a monad &amp;&amp;, you can move from the monad. Equally, you can avoid copies if your callable takes a reference argument. The callable F can be a generic lambda if desired.</p>
<p>If your callable does not return a monad, a monad will be constructed to hold the type it does return inheriting the same error_code, exception_type etc of the originating monad. If your callable returns a monad, that monad can be of any template parameter configuration and it will be returned from next(). This allows a very easy way of converting between different configurations of monad cost free. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/boost/outcome/v1.0/<a class="el" href="monad_8hpp_source.html">monad.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1outcome.html">outcome</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1outcome_1_1v1__xxx.html">v1_xxx</a></li><li class="navelem"><a class="el" href="classboost_1_1outcome_1_1v1__xxx_1_1result.html">result</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
