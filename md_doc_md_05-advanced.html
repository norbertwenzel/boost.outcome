<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>boost.outcome: Advanced usage: Outcome as a Monad</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_md_05-advanced.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Advanced usage: Outcome as a Monad </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="advanced"></a> 99% of Outcome users already have everything they will ever need - Outcome is a very simple library. However "full fat" monadic functional programming is also provided using a very clean and powerful API, albeit at a fair cost to compile times.</p>
<h1><a class="anchor" id="functional"></a>
Functional programming extensions (optional)</h1>
<dl class="section note"><dt>Note</dt><dd>All code in this section can be enabled by defining <code>BOOST_OUTCOME_ENABLE_ADVANCED</code>. By default is it off. This prevents you writing code which impacts build times.</dd></dl>
<p>It is assumed in this section that you already understand monadic functional programming. This section is simply to explain how these are implemented in Outcome.</p>
<p>Classic monadic programming consists of a sequence of nested functional operations: </p>
<dl>
<dt>JOIN (single): <code>outcome&lt;outcome&lt;T&gt;&gt;.<a class="el" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316" title="Variable of type value_t. ">value()</a></code> -&gt; <code>outcome&lt;T&gt;</code> </dt>
<dd></dd>
<dt>JOIN (maximum): <code>outcome&lt;outcome&lt;outcome&lt;outcome&lt;T&gt;&gt;&gt;&gt;.unwrap()</code> -&gt; <code>outcome&lt;T&gt;</code> </dt>
<dd>Whatever is the first monad containing a non-monad is returned. </dd>
<dt>MAP: <code>outcome&lt;T&gt;.map(R(T))</code> -&gt; <code>outcome&lt;R&gt;</code> </dt>
<dd>If callable maps <code>T</code> to <code>R</code>, <code>map()</code> maps an <code>outcome&lt;T&gt;</code> to an <code>outcome&lt;R&gt;</code> if <code>outcome&lt;T&gt;</code> contains a <code>T</code>. If it contains an error or is empty, that is passed through. </dd>
<dt>BIND: <code>outcome&lt;T&gt;.bind(outcome&lt;R&gt;(T))</code> -&gt; <code>outcome&lt;R&gt;</code> </dt>
<dd></dd>
<dt>BIND: <code>outcome&lt;T&gt;.bind(R(T))</code> -&gt; <code>outcome&lt;R&gt;</code> </dt>
<dd>If callable maps <code>T</code> to <code>outcome&lt;R&gt;</code> and if <code>outcome&lt;T&gt;</code> contains a <code>T</code>, then <code>bind()</code> maps an <code>outcome&lt;T&gt;</code> to an <code>outcome&lt;R&gt;</code> else if callable maps <code>T</code> to <code>R</code> and if <code>outcome&lt;T&gt;</code> contains a <code>T</code>, <code>bind()</code> maps an <code>outcome&lt;T&gt;</code> to an <code>outcome&lt;R&gt;</code>. In other words, returning a monad from the callable does not wrap it in another monad. If the originating monad did not contain a <code>T</code>, that is passed through. </dd>
</dl>
<p>We also support <code>outcome&lt;T&gt;.next(R(outcome&lt;T&gt;))</code> for semantic equivalence to futures where the callable is called with the originating monad. This acts somewhat like <code>bind()</code>, so if the callable returns a monad it is not wrapped in another monad. Unlike <code>map()</code> or <code>bind()</code>, <code>next()</code> always calls the callable no matter what the monad contains, so it is up to you to interrogate the monad. Note that the originating monad is passed by const lvalue ref unless the callable takes a rvalue ref to the monad. Note that due to being much simpler, the load on the compiler when you use <code>next()</code> is considerably less than when you use <code>map()</code> or <code>bind()</code>.</p>
<p>A quick use example: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; outcome&lt;T&gt; do_test(outcome&lt;T&gt; m)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The value of my input monad is &quot;</span>;</div>
<div class="line">  <span class="keywordflow">if</span>(m)</div>
<div class="line">    std::cout &lt;&lt; m.value() &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; (m.has_error() ? <span class="stringliteral">&quot;errored&quot;</span> : m.has_exception() ? <span class="stringliteral">&quot;excepted&quot;</span> : <span class="stringliteral">&quot;empty&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">  </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  or via bind(), my value is &quot;</span>;</div>
<div class="line">  <span class="keyword">auto</span> o(m &gt;&gt; [](T v) { std::cout &lt;&lt; v; <span class="keywordflow">return</span> v; }</div>
<div class="line">           &gt;&gt; [](error_code_extended e) { std::cout &lt;&lt; <span class="stringliteral">&quot;errored&quot;</span>; <span class="keywordflow">return</span> e; }</div>
<div class="line">           &gt;&gt; [](std::exception_ptr e) { std::cout &lt;&lt; <span class="stringliteral">&quot;excepted&quot;</span>; <span class="keywordflow">return</span> e; }</div>
<div class="line">           &gt;&gt; [](<span class="keyword">typename</span> decltype(m)::empty_type) { std::cout &lt;&lt; <span class="stringliteral">&quot;empty&quot;</span>; });</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> o;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">  <span class="keyword">struct </span>o_type</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> <a class="code" href="group__expected.html#ga7440167038cbd110405573cf2bd873ad">expected</a>;</div>
<div class="line">    <span class="comment">// monad.match() will call an overload for each possible content it might have</span></div>
<div class="line">    <span class="keywordtype">void</span> operator()(<span class="keywordtype">int</span> <span class="comment">/*unused*/</span>)<span class="keyword"> const </span>{ BOOST_CHECK(<a class="code" href="group__expected.html#ga7440167038cbd110405573cf2bd873ad">expected</a> == 1); }</div>
<div class="line">    <span class="keywordtype">void</span> operator()(error_code_extended <span class="comment">/*unused*/</span>)<span class="keyword"> const </span>{ BOOST_CHECK(<a class="code" href="group__expected.html#ga7440167038cbd110405573cf2bd873ad">expected</a> == 2); }</div>
<div class="line">    <span class="keywordtype">void</span> operator()(std::exception_ptr <span class="comment">/*unused*/</span>)<span class="keyword"> const </span>{ BOOST_CHECK(<a class="code" href="group__expected.html#ga7440167038cbd110405573cf2bd873ad">expected</a> == 3); }  <span class="comment">// NOLINT</span></div>
<div class="line">    <span class="keywordtype">void</span> operator()(outcome&lt;int&gt;::empty_type <span class="comment">/*unused*/</span>)<span class="keyword"> const </span>{ BOOST_CHECK(<a class="code" href="group__expected.html#ga7440167038cbd110405573cf2bd873ad">expected</a> == 4); }</div>
<div class="line">    o_type()</div>
<div class="line">        : <a class="code" href="group__expected.html#ga7440167038cbd110405573cf2bd873ad">expected</a>(0)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">  } o;</div>
<div class="line">  error_code_extended ec;</div>
<div class="line">  std::exception_ptr e;</div>
<div class="line">  outcome&lt;int&gt; a(5);</div>
<div class="line">  o.expected = 1;</div>
<div class="line">  (void) a.match(o);</div>
<div class="line">  o.expected = 2;</div>
<div class="line">  a = ec;</div>
<div class="line">  (void) a.match(o);</div>
<div class="line">  o.expected = 3;</div>
<div class="line">  a = e;</div>
<div class="line">  (void) a.match(o);</div>
<div class="line">  o.expected = 4;</div>
<div class="line">  a.clear();</div>
<div class="line">  (void) a.match(o);</div>
</div><!-- fragment --><div class="fragment"><div class="line">  {</div>
<div class="line">    error_code_extended ec;</div>
<div class="line">    outcome&lt;int&gt; a(5);</div>
<div class="line">    outcome&lt;int&gt; b(a &amp; 6);   <span class="comment">// a has a value, so become 6</span></div>
<div class="line">    outcome&lt;int&gt; c(b | 4);   <span class="comment">// b has a value, so remain at 6</span></div>
<div class="line">    outcome&lt;int&gt; d(a &amp; ec);  <span class="comment">// a has a value, so become errored</span></div>
<div class="line">    outcome&lt;int&gt; e(d &amp; 2);   <span class="comment">// d does not have a value, so remain errored</span></div>
<div class="line">    outcome&lt;int&gt; f(d | 2);   <span class="comment">// d does not have a value, so become 2</span></div>
<div class="line">    BOOST_CHECK(b.get() == 6);</div>
<div class="line">    BOOST_CHECK(c.get() == 6);</div>
<div class="line">    BOOST_CHECK(d.has_error());</div>
<div class="line">    BOOST_CHECK(e.has_error());</div>
<div class="line">    BOOST_CHECK(f.get() == 2);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  error_code_extended ec;</div>
<div class="line">  {</div>
<div class="line">    outcome&lt;std::string&gt; a(<span class="stringliteral">&quot;niall&quot;</span>);</div>
<div class="line">    <span class="comment">// Does bind work with chains of value, error, exception and empty?</span></div>
<div class="line">    <span class="keyword">auto</span> x(a &gt;&gt; [ec](std::string) { <span class="keywordflow">return</span> ec; }                              <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](error_code_extended) { <span class="keywordflow">return</span> std::make_exception_ptr(5); }  <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](std::exception_ptr) { <span class="keywordflow">return</span>; }                              <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](outcome&lt;std::string&gt;::empty_type) { <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;douglas&quot;</span>); });</div>
<div class="line">    BOOST_CHECK(x.get() == <span class="stringliteral">&quot;douglas&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> y(a &gt;&gt; [ec](std::string) -&gt; outcome&lt;int&gt; { <span class="keywordflow">return</span> ec; }                                        <span class="comment">//</span></div>
<div class="line">                                     &gt;&gt; [](error_code_extended) { <span class="keywordflow">return</span> std::make_exception_ptr(5); }  <span class="comment">//</span></div>
<div class="line">                                     &gt;&gt; [](std::exception_ptr) { <span class="keywordflow">return</span>; }                              <span class="comment">//</span></div>
<div class="line">                                     &gt;&gt; [](outcome&lt;int&gt;::empty_type) { <span class="keywordflow">return</span> 5; });</div>
<div class="line">    BOOST_CHECK(y.get() == 5);</div>
<div class="line">    <span class="keyword">auto</span> z(a &gt;&gt; [](std::string &amp;&amp;v) { <span class="keywordflow">return</span> std::move(v); }  <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](std::string &amp;&amp;v) { <span class="keywordflow">return</span> std::move(v); }    <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](std::string &amp;&amp;v) { <span class="keywordflow">return</span> std::move(v); }    <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](std::string &amp;&amp;v) { <span class="keywordflow">return</span> std::move(v); });</div>
<div class="line">    BOOST_CHECK(z.get() == <span class="stringliteral">&quot;niall&quot;</span>);</div>
<div class="line">    BOOST_CHECK(a.get().empty());</div>
<div class="line">  }</div>
</div><!-- fragment --><p> You will note in the code example that the type of the callable for <code>bind()</code> and <code>map()</code> determines what operation happens. Here are the rules:</p>
<ul>
<li>If the monad contains a <code>T</code> and the callable takes a <code>T</code> or an <code>auto</code>, then:<ul>
<li>If the callable takes a <code>T</code> or any reference to a <code>T</code> which isn't an rvalue reference, the <code>T</code> is passed by const lvalue reference (i.e. copy semantics).</li>
<li>If the callable takes a <code>T</code> by non-const rvalue reference, the <code>T</code> is passed by rvalue ref. This lets you move from the value held by the originating monad if so desired.</li>
<li>If the callable takes the originating monad or any reference to such which isn't a rvalue reference, then the originating monad is passed by const lvalue reference.</li>
<li>If the callable takes the originating monad by non-const rvalue reference, the originating monad is passed by rvalue reference. The ability to take the originating monad makes <code>bind()</code> identical to <code>next()</code> though much harder on build times. Note that these options let you rebind the type of the monad, so if your callable returns a different type from the originating monad then the resulting monad is based on that different return type. <dl class="section warning"><dt>Warning</dt><dd>The current implementation requires you to specify a non-dependent return type for all generic lambdas, else you'll get compile errors where the compiler tried to insert <code>error_type</code>, <code>exception_type</code> etc when it was trying to figure out if the return type is correct. A future implementation (once MSVC has Expression SFINAE) may remove this restriction, until then just hard specify your return types if your lambdas take an <code>auto</code>, or use lambdas not taking <code>auto</code>.</dd></dl>
</li>
</ul>
</li>
<li>If the monad contains an <code>error_type</code> and the callable takes an <code>error_type</code>, then call the callable, else pass through the monad. For this reason, any callable taking an <code>error_type</code> must always return the same monad type as the originating monad.</li>
<li>If the monad contains an <code>error_type</code> or an <code>exception_type</code> and the callable takes an <code>exception_type</code>, then call the callable, else pass through the monad. For this reason, any callable taking an <code>exception_type</code> must always return the same monad type as the originating monad.</li>
<li>If the monad is empty and the callable takes an <code>empty_type</code>, then call the callable, else pass through the monad. For this reason, any callable with an <code>empty_type</code> parameter must always return the same monad type as the originating monad.</li>
</ul>
<p>Note that for nested monads e.g. <code>outcome&lt;outcome&lt;int&gt;&gt;</code>, either or both of the inner or outer monads can be with value or with error or empty. You should have your binds and maps work appropriately.</p>
<p>For maximum build performance, try to avoid <code>bind()</code> and <code>map()</code> as these use some hefty metaprogramming to deduce what kind of bind and map you're doing based on the callables passed. <code>unwrap()</code> is implemented using a recursively expanded structure which is probably okay for low unwrap depths. <code>next()</code> is probably the least weighty of the monadic operators as it's relatively dumb and the only metaprogramming is to determine whether to wrap the return type with a monad or not. Because of this impact on compile times, by default all operations apart from <code>next()</code> are not compiled in without the <code>BOOST_OUTCOME_ENABLE_ADVANCED</code> macro being defined beforehand.</p>
<h3>Acknowledgements</h3>
<p>To T.C. on Stack Overflow for answering my question at <a href="https://stackoverflow.com/questions/30802404/how-to-detect-whether-some-callable-takes-a-rvalue-reference">https://stackoverflow.com/questions/30802404/how-to-detect-whether-some-callable-takes-a-rvalue-reference</a> and without whose excellent answer the intelligent <code>map()</code> and <code>bind()</code> above could not work. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
