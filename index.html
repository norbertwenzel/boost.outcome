<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>boost.outcome: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.99</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">boost.outcome Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#description">Description</a></li>
<li class="level1"><a href="#prerequisites">Prerequisites</a><ul><li class="level2"><a href="#support">Support</a></li>
</ul>
</li>
<li class="level1"><a href="#cpp_error_handling_history">Design Rationale: Quick history of error handling design patterns from C++ 98 to C++ 17</a><ul><li class="level2"><a href="#c-style">C style error handling: integer returns</a></li>
<li class="level2"><a href="#cpp98-style">C++ 98 style error handling: throwing exceptions</a></li>
<li class="level2"><a href="#cpp11-style">C++ 11 style error handling: error_code and noexcept</a></li>
<li class="level2"><a href="#cpp17-style">C++ 17/20 style error handling: optional<T> and expected<T, E></a><ul><li class="level3"><a href="#optional">Returning optional<T></a></li>
<li class="level3"><a href="#expected">Returning expected<T, E></a></li>
<li class="level3"><a href="#sea-of-noexcept">The "Islands of exception throw in a sea of noexcept" design pattern</a></li>
<li class="level3"><a href="#exceptions-are-exceptional">The "Exceptions are exceptional, errors are not failure" design pattern</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#introduction">Introducing Outcome</a><ul><li class="level2"><a href="#design_differences">Design differences between Expected and Outcomes</a></li>
<li class="level2"><a href="#synopsis">Synopsis of basic_monad<> and outcome<T>, result<T> and option<T></a></li>
<li class="level2"><a href="#examples">Examples of usage</a></li>
</ul>
</li>
<li class="level1"><a href="#when_use">When am I supposed to use what when?</a><ul><li class="level2"><a href="#outcome_vs_result">When should I use a result<T> instead of an outcome<T>?</a></li>
<li class="level2"><a href="#result_vs_outcome">When should I use an outcome<T> instead of a result<T>?</a></li>
</ul>
</li>
<li class="level1"><a href="#advanced">More advanced usage</a><ul><li class="level2"><a href="#functional">Functional programming extensions (optional)</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><center><table  border="0" cellpadding="4">
<tr>
<td align="center"><a href="https://dedi4.nedprod.com/static/files/boost.outcome-v1.0-source-latest.tar.xz">Source</a><br/>
<a href="https://dedi4.nedprod.com/static/files/boost.outcome-v1.0-source-latest.tar.xz">Tarball</a>  </td><td align="center"><a href="https://github.com/ned14/boost.outcome">Boost.Outcome</a><br/>
<a href="https://github.com/ned14/boost.outcome">on GitHub</a>  </td><td align="center"><a href="http://my.cdash.org/index.php?project=Boost.Outcome">CTest summary</a><br/>
<a href="http://my.cdash.org/index.php?project=Boost.Outcome">dashboard</a>  </td><td align="center"><a href="https://travis-ci.org/ned14/boost.outcome">Linux CI:</a><div class="image">
<img src="https://travis-ci.org/ned14/boost.outcome.svg?branch=master" />
</div>
  </td><td align="center"><a href="https://ci.appveyor.com/project/ned14/boost-outcome/branch/master">Windows CI:</a><div class="image">
<img src="https://ci.appveyor.com/api/projects/status/roe4dacos4gnlu66/branch/master?svg=true" />
</div>
  </td><td align="center"><a href="https://coveralls.io/r/ned14/boost.outcome?branch=master">Coverage:</a><div class="image">
<img src="https://coveralls.io/repos/ned14/boost.outcome/badge.svg?branch=master" />
</div>
   </td></tr>
</table>
</center><h1><a class="anchor" id="description"></a>
Description</h1>
<p>This is the proposed Boost.Outcome library, a Boost C++ 14 library providing a factory and family of policy driven lightweight monadic value-or-error transports with the convenience simple specialisations of <code>outcome&lt;T&gt;</code>, <code>result&lt;T&gt;</code> and <code>option&lt;T&gt;</code>. Its main intended usage is as an ultra light weight error handling framework, providing a more expressive and type safe alternative to error code integers or enums, yet much lower overhead than exception throws. Unlike alternatives such as <code>expected&lt;T, E&gt;</code>, it works perfectly with exceptions and RTTI disabled and thus is suitable for low-latency/games/finance/SG14 users. One could view Outcome as a "hard coded", less generic <code>expected&lt;T, E&gt;</code> intended mainly as a minimum overhead universal outcome handling framework for C++, hence being named "Outcome".</p>
<p>If you are familiar with Swift's error code throws or Rust's <code>Result&lt;T&gt;</code> and <code>Option&lt;T&gt;</code>, you will find almost identical semantics in the transports provided here. One can therefore write systems programming code using these transports in C++ in the same design pattern as when writing in Rust or Swift, and with a similarly low runtime overhead. Outcome even has a <code>try</code> macro doing the same thing as in Rust and Swift!</p>
<dl class="section note"><dt>Note</dt><dd>Boost.Outcome has not been peer reviewed and is not part of the Boost libraries (yet). It is hoped it will enter the peer review queue in Q1 2017.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>bo = <a class="code" href="group__config.html#gab113de43db2cd2a4cf1e33b54294944a" title="The namespace of this Boost.Outcome v1 which will be some unknown inline namespace starting with v1_ ...">BOOST_OUTCOME_V1_NAMESPACE</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Returns either an int, an error code or an exception ptr.</span></div>
<div class="line"><span class="comment">// One might model the error code as a programmer expected</span></div>
<div class="line"><span class="comment">// failure e.g. name not found, whereas the exception ptr</span></div>
<div class="line"><span class="comment">// might mean catastrophic unexpected failure e.g. storage</span></div>
<div class="line"><span class="comment">// is missing. Typically you abort on exception, but handle</span></div>
<div class="line"><span class="comment">// errors. Note the noexcept, this means that calling this</span></div>
<div class="line"><span class="comment">// function will NEVER invert execution flow unexpectedly.</span></div>
<div class="line">bo::outcome&lt;int&gt; getConfigParam(std::string name) noexcept;</div>
<div class="line"></div>
<div class="line"><span class="keyword">extern</span> <span class="keywordtype">void</span> runWithMax(<span class="keywordtype">int</span>);</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Get what the user has set for the MaxValue parameter</span></div>
<div class="line">  <span class="keyword">auto</span> oi = getConfigParam(<span class="stringliteral">&quot;MaxValue&quot;</span>);</div>
<div class="line">  <span class="comment">// Did it return a valid integer?</span></div>
<div class="line">  <span class="keywordflow">if</span>(oi)</div>
<div class="line">    runWithMax(*oi);</div>
<div class="line">  <span class="comment">// Did it return a catastrophic failure?</span></div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span>(oi.has_exception())</div>
<div class="line">    std::rethrow_exception(oi.exception());</div>
<div class="line">  <span class="comment">// Did it return an expected failure?</span></div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;getConfigParam reports error &quot;</span> &lt;&lt; oi.error() &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p> <br/>
</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="prerequisites"></a>
Prerequisites</h1>
<p>Boost.Outcome is a header only C++ 14 library known to work on these compilers or better:</p>
<ul>
<li>GCC 5.0</li>
<li>clang 3.7</li>
<li>VS2015 Update 2</li>
<li>clang 3.7 with Microsoft Codegen ("winclang")</li>
</ul>
<p><b>A copy of Boost is not required to use this library</b>. You can simply drop Outcome into your project and go.</p>
<dl class="section warning"><dt>Warning</dt><dd>VS2015 generates a lot of code bloat when using Outcome in large code bases. If you can use VS2017 which implements C++ 14 constexpr and has a better optimiser for modern C++, you will see much tigher executables. Execution speed is pretty similar between the two, and remains lower than GCC or clang which generate close to optimally minimum sized output with Outcome at all times.</dd></dl>
<p><a class="el" href="installation.html">Installing, building and testing Outcome</a></p>
<h2><a class="anchor" id="support"></a>
Support</h2>
<p><a href="https://stackoverflow.com/">StackOverflow</a> with the boost-outcome tag is the preferred place to ask questions on usage.</p>
<p>If you have a problem, please review the FAQ and the wiki. Searching <a href="https://github.com/ned14/boost.outcome/issues">the issues</a> for your problem is also a good idea. If you are encountering what you think is a bug, please open an issue.</p>
<p><br/>
</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="cpp_error_handling_history"></a>
Design Rationale: Quick history of error handling design patterns from C++ 98 to C++ 17</h1>
<h2><a class="anchor" id="c-style"></a>
C style error handling: integer returns</h2>
<p>Historically C++ 98 code has taken one of two design patterns when returning errors from functions. This pattern is taken from C, and indeed is pure C:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line"><span class="keyword">enum</span> errors</div>
<div class="line">{</div>
<div class="line">  SUCCESS=0,</div>
<div class="line">  NOMEM,</div>
<div class="line">  NOTFOUND,</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line">...</div>
<div class="line">int openfile(<span class="keyword">struct</span> handle **outh, <span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  *outh = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> handle));</div>
<div class="line">  <span class="keywordflow">if</span>(!*outh)</div>
<div class="line">    <span class="keywordflow">return</span> NOMEM;</div>
<div class="line">  (*outh)-&gt;fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>((*outh)-&gt;fd == -1)</div>
<div class="line">  {</div>
<div class="line">    free(*outh);</div>
<div class="line">    *outh = NULL;</div>
<div class="line">    <span class="keywordflow">return</span> NOTFOUND;</div>
<div class="line">  }</div>
<div class="line">  ...</div>
<div class="line">  <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Almost certainly anyone reading this has seen this error handling design umpteen times in their career. Variations on the same pattern are returning the enum type directly, returning a boolean and using a thread locally stored global variable such as <code>errno</code> and so on.</p>
<h2><a class="anchor" id="cpp98-style"></a>
C++ 98 style error handling: throwing exceptions</h2>
<p>The second C++ 98 design pattern ought to also be very familiar to readers: </p>
<div class="fragment"><div class="line"><span class="comment">// Abstract base class for some handle implementation</span></div>
<div class="line"><span class="keyword">struct </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  ...</div>
<div class="line">  <span class="keyword">virtual</span> ~handle()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(fd != -1)</div>
<div class="line">    {</div>
<div class="line">      close(fd);</div>
<div class="line">      fd = -1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>handle_ref;  <span class="comment">// Some sort of smart pointer managing a handle *</span></div>
<div class="line">handle_ref openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;File not found&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Could throw std::bad_alloc or any other kind of exception during construction</span></div>
<div class="line">    <span class="keywordflow">return</span> handle_ref(<span class="keyword">new</span> some_derived_handle_implementation(fd));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(...)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="keywordflow">throw</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Experts will quite correctly chafe at the use of <code>std::runtime_error</code> to report a file not found, but nevertheless such a design pattern is very common in the wild.</p>
<h2><a class="anchor" id="cpp11-style"></a>
C++ 11 style error handling: error_code and noexcept</h2>
<p>C++ 11 brought in two new features to help bridge the gap between the over use of exception throws to report routine failures and C error handling: (i) <code>noexcept</code> and (ii) the standardisation of <code>error_code</code> from Boost. <code>noexcept</code> lets you mark functions with the guarantee that they shall <b>never</b> throw exceptions. This is commonly described as a feature enabling the compiler and standard library to use faster algorithms which can assume that operations never need to undone part way through, however it also enables a whole new way of writing C++ which we shall call *"islands of exception throw in a sea
of noexcept"* which will be described later.</p>
<p>Both the Boost and C++ 11 <code>error_code</code> consists of an integer and a reference to an <code>error_category</code> instance. This allows one to set a <em>domain</em> for an integer error code such that <code>NOTFOUND</code> in library A can have a different integer value to <code>NOTFOUND</code> in library B. Because the reference to the domain of the error code is transported with the error code, integer error codes can be propagated <em>without losing information</em> into other code which need have no knowledge whatsover of libraries A nor B. <code>error_code</code> and the other machinery in <code>&lt;system_error&gt;</code> lets you handle errors from unknown libraries via <code>error_condition</code> which lets you inspect unknown third party <code>error_code</code>'s for whether they have semantic equivalence to the standard POSIX errors, and therefore handle a file-not-found situation based on semantic equivalence rather than losing information from the original source by doing an error code conversion. Therefore as with exception types deriving from <code>std::exception</code>, a central error handling routine can understand just enough of unknown third party error codes to act appropriately.</p>
<p>The C++ 11 standard library makes very limited use of <code>error_code</code> for reporting errors, however the Filesystem TS and Networking TS as indeed much of Boost uses this error handling design pattern extensively:</p>
<div class="fragment"><div class="line"><span class="comment">// Abstract base class for some handle implementation</span></div>
<div class="line"><span class="keyword">struct </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  ...</div>
<div class="line">  <span class="keyword">virtual</span> ~handle()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(fd != -1)</div>
<div class="line">    {</div>
<div class="line">      close(fd);</div>
<div class="line">      fd = -1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>handle_ref;  <span class="comment">// Some sort of smart pointer managing a handle *</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Non-throwing overload</span></div>
<div class="line">handle_ref openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, std::error_code &amp;ec) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Construct an error code in the OS errors domain</span></div>
<div class="line">    ec = std::error_code(errno, std::system_category());</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">auto</span> *p = <span class="keyword">new</span>(std::nothrow) some_derived_handle_implementation(fd, ec);</div>
<div class="line">  <span class="keywordflow">if</span>(p == <span class="keyword">nullptr</span>)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="comment">// Construct an error code matching the generic OS error equivalent</span></div>
<div class="line">    <span class="comment">// to the ENOMEM error condition</span></div>
<div class="line">    ec = <a class="code" href="group__monad.html#gab6204dd7620b0e495220e76988359589" title="ADL looked up by the STL to convert a monad_errc into an error_code.">std::make_error_code</a>(std::errc::not_enough_memory);</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">delete</span> p;</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> handle_ref(p);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Throwing overload</span></div>
<div class="line">handle_ref openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  std::error_code ec;</div>
<div class="line">  handle_ref ret(openfile(path, ec));</div>
<div class="line">  <span class="keywordflow">if</span>(ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">throw</span> std::system_error(ec);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This third error handling design pattern has two big advantages:</p>
<ol type="1">
<li>You only pay for what you use, so if you call the non-throwing overload you are guaranteed by the <code>noexcept</code> that execution flow will not unexpectedly invert. This makes writing correct exception safe code much easier, plus unpredictable execution times due to exception throws cannot occur. The compiler can also reduce executable bloat by not generating stack unwind tables around that call which is useful for some C++ users.</li>
<li>It allows one to segment truly exceptional events into exception throws with stack unwinds and to handle ordinary and common failures in normal forward execution program logic. This is exactly the error handling model used by the new systems languages Swift and Rust.</li>
</ol>
<h2><a class="anchor" id="cpp17-style"></a>
C++ 17/20 style error handling: optional&lt;T&gt; and expected&lt;T, E&gt;</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Relocate this entire discussion about Expected into a separate section outside the tutorial. Continue here with a purely Outcome based implementation of the toy open file function. There is too great a jump between the nice baby steps up until now and suddenly leaping into WG21 speak and future C++ 17 classes which tutorial users don't care about nor need to know about, they are here for Outcome, not Expected.</dd></dl>
<p>C++ 17 isn't finished at the time of writing, but we are very sure that at least <a href="http://en.cppreference.com/w/cpp/utility/optional"><code>std::optional&lt;T&gt;</code></a> will be in it. It remains to be seen if LEWG's <code>expected&lt;T, E&gt;</code> will make it, if not then most STL implementations will probably ship an implementation as an experimental and if your STL does not, there is always the reference implementation at <a href="https://github.com/viboes/std-make">https://github.com/viboes/std-make</a> which ought to work on any C++ 14 compiler.</p>
<dl class="section note"><dt>Note</dt><dd>LEWG is the C++ standard committee's Library Evolution Working Group. They work on improving the C++ standard runtime library which will gain <code>std::optional&lt;T&gt;</code> and <code>std::variant&lt;...&gt;</code> in C++ 17 and probably <code>std::expected&lt;T, E&gt;</code> in C++ 17 or C++ 20.</dd></dl>
<p>The following discussion is based on <code>expected&lt;T, E&gt;</code> as detailed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0323r1.pdf">P0323R1</a> which is the latest LEWG proposal paper at the time of writing (Nov 2016) and indeed one where <code>expected&lt;T, E&gt;</code> was pared down significantly from its original proposal. It should be noted that C++ may yet end up adopting something quite different, though given how long <code>expected&lt;T, E&gt;</code> has been around by now, and how well it fits nicely between <code>optional&lt;T&gt;</code> and <code>variant&lt;T, E&gt;</code>, it would seem unlikely. <code>expected&lt;T, E&gt;</code> is intended as a strict superset of <code>optional&lt;T&gt;</code> with aspects of <a href="http://en.cppreference.com/w/cpp/utility/variant"><code>std::variant&lt;T, E&gt;</code></a>, indeed much of LEWG's remaining work on the proposal is on reconciling the small remaining semantic differences between <code>expected&lt;T, nullopt_t&gt;</code> and <code>optional&lt;T&gt;</code>.</p>
<p>The original prototype Boost.Expected library was a large and very complex beastie - I was fortunate to be employed on a contract in 2015 where I saw it deployed at scale into a large C++ codebase. Indeed, much of what I witnessed there had a big impact in how Outcome ended up being designed. P0323R1 proposes an enormously simplified implementation which ought to fix all of the showstopper problems with the original that I am aware of, and P0323R1's reduced <code>expected&lt;T, E&gt;</code> has ended up having a huge resemblance to Outcome in every day usage. It is heartening that the committee have made most of the changes I also made in Outcome, as that suggests I am on the right track. Outcome's slightly different design still contributes a lot of value for the specific use of error handling in my opinion, as we shall hopefully see next.</p>
<h3><a class="anchor" id="optional"></a>
Returning optional&lt;T&gt;</h3>
<p>In some programming contexts we don't need to know why an operation failed, only that it did. Throwing an exception after failing to find a file is a good example of the kind of failure which is very common and where throwing an exception to handle that event is excessive and inappropriate. One might therefore design a routine expected to frequently fail in C++ as:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns true for success and fills \em out with the opened file, else false</span></div>
<div class="line"><span class="keywordtype">bool</span> openfile(handle_ref &amp;out, <span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept;</div>
</div><!-- fragment --><p>Wouldn't it be much nicer though if you didn't force the caller to have to instantiate a copy of <code>handle_ref</code> before each call, not least because such a requirement messes badly with using <code>openfile()</code> in generic template code and moreover it could be the case that constructing a <code>handle_ref</code> is an atomic operation, and is thus wasted work if the failure to open is very common? This is where <code>optional&lt;T&gt;</code> comes in:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns the opened handle on success, else an empty optional</span></div>
<div class="line">std::optional&lt;handle_ref&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept;</div>
<div class="line">...</div>
<div class="line">auto fh_ = openfile(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(fh_)</div>
<div class="line">{</div>
<div class="line">  handle_ref fh = std::move(fh_.value());</div>
<div class="line">  fh-&gt;read(... etc</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>optional&lt;T&gt;</code> is pretty boring and unsurprising like any good primitive. It's also fairly intuitive, almost any C++ programmer will immediately understand what the code above does from inspection.</p>
<h3><a class="anchor" id="expected"></a>
Returning expected&lt;T, E&gt;</h3>
<p>Many familiar with the filesystem will find the above use case of <code>optional&lt;T&gt;</code> unsettling because there are many reasons why one couldn't open a file rather than merely it was not found. Imagine, for example, that a program is attempting to open a few thousand files on a networked drive which has broken its connection - in this case every single failure will take considerable time to return and there is zero chance <em>any</em> file open will ever succeed, so what the user sees is an apparently hanged program. Far better would be if the <code>openfile()</code> function could return the cause of its failure, and we could then treat all errors which are different to file-not-found as reason to <b>abort</b>.</p>
<p>Enter LEWG's proposed <code>expected&lt;T, E&gt;</code> which can hold either an expected value of type <code>T</code> or an unexpected value of type <code>E</code>. Like <code>variant&lt;T, E&gt;</code>, <code>expected&lt;T, E&gt;</code> is a discriminated union storing either <code>T</code> or <code>E</code> in the same storage space, but unlike the variant, expected treats the <code>T</code> as a positive thing (fetchable via a <code>.<a class="el" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316" title="Variable of type value_t.">value()</a></code>) and <code>E</code> as a negative thing (fetchable via an <code>.<a class="el" href="group__monad.html#ga1a1a8470c4efc3a52412f3ecc79a0060" title="Variable of type error_t.">error()</a></code>). Because <code>expected&lt;T, E&gt;</code> provides a "almost never empty" guarantee similar to variant, it currently requires type <code>E</code> to be nothrow copy and move constructible and assignable. Expected is a bit less intuitive to use than optional, but its rules are straightforward: <code>expected&lt;T, E&gt;</code> will greedily and implicitly construct from any type from which a <code>T</code> can be constructed, after which it will hold an instance of <code>T</code>. If you wish to construct an <code>expected&lt;T, E&gt;</code> holding an instance of unexpected <code>E</code>, you need to feed it an <code>unexpected&lt;E&gt;</code> which is type sugar to indicate you want an instance of <code>E</code> implicitly converted into an <code>expected&lt;T, E&gt;</code>. As with everything else in C++ 11 onwards, there is a <code>make_expected(T)</code> and a <code>make_unexpected(E)</code> which do any type deduction and conversion for you into the right contents of <code>expected&lt;T, E&gt;</code>.</p>
<p>All this sounds a bit complex, but really it's much easier to use. Here is a non-throwing implementation based on <code>expected&lt;T, E&gt;</code></p>
<div class="fragment"><div class="line"><span class="comment">// Returns the expected opened handle on success, or an unexpected cause of failure</span></div>
<div class="line">std::expected&lt;handle_ref, std::error_code&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unexpected(std::error_code(errno, std::system_category());</div>
<div class="line">  }</div>
<div class="line">  std::error_code ec;</div>
<div class="line">  <span class="keyword">auto</span> *p = <span class="keyword">new</span>(std::nothrow) some_derived_handle_implementation(fd, ec);</div>
<div class="line">  <span class="keywordflow">if</span>(p == <span class="keyword">nullptr</span>)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unexpected(<a class="code" href="group__monad.html#gab6204dd7620b0e495220e76988359589" title="ADL looked up by the STL to convert a monad_errc into an error_code.">std::make_error_code</a>(std::errc::not_enough_memory));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">delete</span> p;</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unexpected(std::move(ec));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> handle_ref(p);  <span class="comment">// expected&lt;&gt; takes implicit conversion from type T</span></div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">auto fh_ = openfile(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(!fh_ &amp;&amp; fh_.error() != std::errc::no_such_file_or_directory)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// This is serious, abort</span></div>
<div class="line">  <span class="keywordflow">throw</span> std::system_error(std::move(fh_.error()));</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>(fh_)</div>
<div class="line">{</div>
<div class="line">  handle_ref fh = std::move(fh_.value());</div>
<div class="line">  fh-&gt;read(... etc</div>
<div class="line">}</div>
</div><!-- fragment --><p>The prototype Boost.Expected library and the P0323R1 reference library actually declares <code>expected&lt;T, E = std::exception_ptr&gt;</code> as the default despite that P0323R1 specifies <code>expected&lt;T, E = std::error_condition&gt;</code> as the default (note: I have no idea why LEWG would use error condition as a default, such a default would lose information for users so I have assumed they'll change it to error code soon), so for completeness let's rewrite the above to match an <code>E = std::exception_ptr</code> design instead:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns the expected opened handle on success, or an unexpected cause of failure</span></div>
<div class="line">std::expected&lt;handle_ref, std::exception_ptr&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = -1;</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    fd = open(path, O_RDONLY);</div>
<div class="line">    <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">throw</span> std::system_error(std::error_code(errno, std::system_category()));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> make_handle_ref&lt;some_derived_handle_implementation&gt;(fd);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(...)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(fd != -1)</div>
<div class="line">      close(fd);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unexpected(std::current_exception());</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">auto fh_ = openfile(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(!fh_)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    std::rethrow_exception(fh_.error());</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::system_error &amp;e)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(e.code() != std::errc::no_such_file_or_directory)</div>
<div class="line">      <span class="keywordflow">throw</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// All other exception types were rethrown</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  handle_ref fh = std::move(fh_.value());</div>
<div class="line">  fh-&gt;read(... etc</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is the very first time in this tutorial that we have seen the design pattern around which Outcome was specifically designed to make easy: <em>islands of exception throw in a sea of noexcept</em>.</p>
<h3><a class="anchor" id="sea-of-noexcept"></a>
The "Islands of exception throw in a sea of noexcept" design pattern</h3>
<p>This design pattern was intended by the committee in C++ 11 to be the method by which that large minority of C++ users who disable RTTI and exceptions entirely could be brought back into ISO standard C++. The pattern is easy:</p>
<ol type="1">
<li>Every <code>extern</code> API in your translation unit is marked <code>noexcept</code> and uses a non-throwing mechanism such as <code>std::error_code</code> or <code>std::expected&lt;T, E&gt;</code> or Outcomes or even a C-style integer to return errors.</li>
<li>Code within a translation unit is generally not marked <code>noexcept</code>, or indeed may throw and catch exceptions before returning out of an extern <code>noexcept</code> API.</li>
<li>Because all <code>extern</code> function calls are <code>noexcept</code> throughout the entire codebase, from any given translation unit it is never the case that implementation code will ever call a potentially throwing function (C APIs are assumed to never throw on most C++ compilers). Because no calls to unknown code will ever throw, the compiler's optimiser <em>ought</em> to elide emission of stack unwind code and all other exception throw handling overhead in any sequence of code inside the translation unit <em>as if</em> exceptions had been globally disabled at the command line.</li>
<li>Where code inside a translation unit does call something which could throw e.g. much of the STL, exception handling overhead <em>ought</em> to be confined to the containing <code>try</code> ... <code>catch</code> <b>island</b> at best, at worst to that given translation unit.</li>
<li>Consumers of your <code>extern</code> API need not care how that API is internally implemented as they shall never see an exception thrown out of that API, and the compiler will optimise your code which uses that <code>extern</code> API in its <b>sea</b> of <code>noexcept</code> accordingly.</li>
</ol>
<h3><a class="anchor" id="exceptions-are-exceptional"></a>
The "Exceptions are exceptional, errors are not failure" design pattern</h3>
<p>In addition to the pure "sea of noexcept" for low latency users, there is one other new error handling design pattern to mention made possible by <code>expected&lt;T, E&gt;</code> or especially Outcomes which combines "sea of noexcept" with exception throws. The idea is that ordinarily speaking code never throws an exception, and returns all failures anticipated by the programmer through <code>expected&lt;T, E&gt;</code> as an <code>E</code>. If however something very unexpected occurs, an <em>exceptional</em> event, we exclusively use exception throws to abort the current operation entirely. For anyone familiar with Rust, this is <b>exactly</b> the Rust error handling model: <code>Result&lt;T&gt;</code> and <code>Option&lt;T&gt;</code> return errors expected by the programmer whereas a stack unwinding panic of the current thread is how exceptional, programmer unanticipated events are handled.</p>
<p>As you will see later, Outcome makes implementing this error handling design pattern easier than in Expected, but let's merge our two code examples using Expected above into one treating expected failures are unexceptional and exceptional failures as thrown exceptions:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns the expected opened handle on success, an error code if an anticipated error,</span></div>
<div class="line"><span class="comment">// throws a system error if an unanticipated exceptional failure</span></div>
<div class="line">std::expected&lt;handle_ref, std::error_code&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> code = errno;</div>
<div class="line">    <span class="comment">// If a temporary failure, this is an expected unexpected outcome</span></div>
<div class="line">    <span class="keywordflow">if</span>(EINTR==code || EBUSY==code || EISDIR==code || ELOOP==code || ENOENT==code || ENOTDIR==code || EPERM==code || EACCES==code)</div>
<div class="line">      <span class="keywordflow">return</span> std::make_unexpected(std::error_code(code, std::system_category());</div>
<div class="line">    <span class="comment">// If anything else, it&#39;s serious and we should abort</span></div>
<div class="line">    <span class="keywordflow">throw</span> std::system_error(std::error_code(code, std::system_category()));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> make_handle_ref&lt;some_derived_handle_implementation&gt;(fd);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(...)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="keywordflow">throw</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">auto fh_ = openfile(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="comment">// If !fh_, it&#39;s an expected failure we ignored</span></div>
<div class="line"><span class="keywordflow">if</span>(fh_)</div>
<div class="line">{</div>
<div class="line">  handle_ref fh = std::move(fh_.value());</div>
<div class="line">  fh-&gt;read(... etc</div>
<div class="line">}</div>
</div><!-- fragment --><p>This "separation of concerns" pattern has a great aesthetic appeal to most, including myself. This is likely why Rust adopted it.</p>
<p>However I must admit that after more than a year of using Outcome I haven't found myself using this design a great deal. It fits well for some codebases, but very much a minority. The problem in my opinion is that the cost of writing and maintaining correct and fully tested code which can invert control flow at any moment is high and typically very much underestimated. Therefore, it is only in some code bases that it is worth placing that high burden on the code, and in most code bases it is not. Hence in most code bases I write forwards only execution code where there is no possible way of inverting control flow at all i.e. no exceptions can be thrown, despite that exceptions are available.</p>
<p><br/>
</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="introduction"></a>
Introducing Outcome</h1>
<p>After that literature review of how C++ has implemented error handling and how code might implement error handling from C++ 17/20 onwards, one might think that Outcome and Expected are interchangeable. They do cover substantially similar ground and in the semantic sense they are the same thing, however where Expected is intended as a generic fundamental type useful for many things, Outcome is specifically intended as a universal error handling framework capable of lossless propagation of all possible kinds of C++ error with the least possible runtime and compile time overhead. It could be considered as a "fixed feature" Expected specialised for the use case of handling errors only.</p>
<h2><a class="anchor" id="design_differences"></a>
Design differences between Expected and Outcomes</h2>
<ol type="1">
<li>Outcome is designed specifically for returning output from function calls in low latency/very high performance C++ of the kind <a href="https://groups.google.com/a/isocpp.org/forum/#!forum/sg14">WG21 SG14</a> is working upon. It therefore works perfectly with exceptions and RTTI disabled and its CI compiles per commit typical use cases of Outcomes and counts the assembler operations emitted by GCC, clang and MSVC to ensure code bloat is kept optimally minimal. On all recent GCCs and clangs, if the compiler's optimiser can infer the state of an outcome, <b>all runtime overhead due to the outcome ought to be completely eliminated</b> (sans optimiser bugs which appear from time to time). This means for inlined code if you return a <code>result&lt;T&gt;(T(...))</code>, the compiler will generate identical code as if you had returned a <code>T(...)</code> directly.</li>
<li>Outcome's actual core implementation is <code>boost::outcome::basic_monad&lt;Policy&lt;T, EC, E&gt;&gt;</code> with these convenience typedefs: <div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> <a class="code" href="group__monad.html#gaab2ff6220205017226794529c863b336" title="outcome&lt;R&gt; can hold a fixed variant list of empty, a type R, a lightweight std::error_code or a heavi...">outcome</a> = basic_monad&lt; monad_policy&lt;T, std::error_code, std::exception_ptr&gt;&gt;;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> <a class="code" href="group__monad.html#ga91e1fe11dbebea15458d882d078d6eb5" title="result&lt;R&gt; can hold a fixed variant list of empty, a type R or a lightweight std::error_code at a space ...">result</a>  = basic_monad&lt;result_policy&lt;T, std::error_code, void&gt;&gt;;</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="keyword">using</span> <a class="code" href="group__monad.html#ga0d0fd5ca15cb339df9aa8e829a8ea5e0" title="option&lt;R&gt; can hold a fixed variant list of empty or a type R at a space cost of sizeof(value_storage&lt;R&gt;) ...">option</a>  = basic_monad&lt;option_policy&lt;T, void, void&gt;&gt;;</div>
</div><!-- fragment --> You can use any type <code>EC</code> or <code>E</code> you like so long as they act as if a <code>std::error_code</code> and a <code>std::exception_ptr</code> respectively e.g. <code>boost::error_code</code> and <code>boost::exception_ptr</code>. <b>Unlike</b> the <code>E</code> in <code>expected&lt;T, E&gt;</code>, Outcome hard codes the model of <code>EC</code> and <code>E</code> in stone, so they <em>must</em> provide at least the same APIs and behaviours as an error code and an exception pointer or be <code>void</code>, in which case the specialisation doesn't provide the ability to store an instance of that type.</li>
<li>As suggested by the presence of an <code>option&lt;T&gt;</code> convenience typedef, all <code>basic_monad&lt;&gt;</code> instances have a formal empty state. There is no <a href="http://en.cppreference.com/w/cpp/utility/variant/valueless_by_exception">"almost never empty" guarantee</a> which enables sane semantics when exceptions are disabled and also to not confuse the compiler's optimiser with complex potential branches in move construction (which can cause the optimiser to give up prematurely). It sidesteps handling the problem of move assignment throwing an exception, in which case Outcomes are left in an empty state. It ensures all <code>basic_monad&lt;&gt;</code> are constexpr default constructible. If you attempt to get a value from an empty Outcome, the compiler will throw an <code>outcome::monad_error</code> if exceptions are available, else it calls the macro <code><a class="el" href="config_8hpp.html#a10f1ea9f0f1205c24e106fb77cee19c3" title="Predefine to have something else occur when Outcome throws a monad_error due to being asked to do som...">BOOST_OUTCOME_THROW_MONAD_ERROR()</a></code> which by default dumps a stack trace and terminates the process.</li>
<li><p class="startli">Like <code>expected&lt;T, E&gt;</code>, <b>explicit</b> conversion exists from any <code>basic_monad&lt;Policy&lt;T1, EC1, E1&gt;&gt;</code> to any <code>basic_monad&lt;Policy&lt;T2, EC2, E2&gt;&gt;</code> if all of <code>T2</code>, <code>EC2</code> and <code>E2</code> are constructible from <code>T1</code>, <code>EC1</code> and <code>E1</code> respectively. <code>basic_monad&lt;Policy&lt;void&gt;&gt;</code> has special significance: you can always <b>implicitly</b> safely construct any arbitrary <code>basic_monad&lt;Policy&lt;T&gt;&gt;</code> from any <code>basic_monad&lt;Policy&lt;void&gt;&gt;</code> which is always a lossless operation. The rules are as follows:</p>
<ol type="a">
<li>If input <code>basic_monad&lt;Policy&lt;void&gt;&gt;</code> is empty, <code>basic_monad&lt;Policy&lt;T&gt;&gt;</code> is empty.</li>
<li>If input <code>basic_monad&lt;Policy&lt;void&gt;&gt;</code> has value, <code>basic_monad&lt;Policy&lt;T&gt;&gt;</code> is a default constructed <code>T</code>.</li>
<li>If input <code>basic_monad&lt;Policy&lt;void&gt;&gt;</code> has an error, <code>basic_monad&lt;Policy&lt;T&gt;&gt;</code> has the same error either copy or move constructed as appropriate.</li>
<li>If input <code>basic_monad&lt;Policy&lt;void&gt;&gt;</code> has an exception, <code>basic_monad&lt;Policy&lt;T&gt;&gt;</code> has the same exception either copy or move constructed as appropriate.</li>
</ol>
<p class="startli">This is Outcome's implementation of the <code>unexpected&lt;E&gt;</code> type sugar used by Expected to initialise an <code>expected&lt;T, E&gt;</code> with an <code>E</code>. In Outcome, returning a void Outcome with the error or exception you want (or better, use the <code>make_errored_result&lt;&gt;</code>, <code>make_errored_outcome&lt;&gt;</code> or <code>make_exceptional_outcome&lt;&gt;</code> free functions) will be implicitly converted into whatever type of Outcome you wish with the errored or excepted state.</p>
</li>
<li>Types <code>T</code>, <code>EC</code> and <code>E</code> cannot be the same nor be constructible from one another, and this is enforced by static assertion at compile time. This prevents pointless confusion and maintenance difficulty (if you really, really need to return error codes or exception pointers as <code>T</code>, wrap them in a thin type wrapper).</li>
<li>You can explicitly convert from any less representative <code>basic_monad&lt;&gt;</code> to any more representative form because that is always a loss free, non-throwing operation (and usually entirely eliminated by the compiler at runtime, if it can it will simply treat the same storage differently as if by <code>static_cast&lt;&gt;</code>). This is because it is expected that lowest level code will return <code>option&lt;T&gt;</code> and <code>result&lt;T&gt;</code> and higher level code will return <code>outcome&lt;T&gt;</code>, so this makes for seamless up-conversion as you move further away from low level code. This also lets you return a <code>result&lt;void&gt;</code> with an error code and it'll auto upconvert to any <code>outcome&lt;T&gt;</code>.</li>
<li>For the most part, <code>expected&lt;T, std::error_code&gt;</code> and <code>outcome::result&lt;T&gt;</code> ought to be close to interchangeable in most use cases, and could be configurably template alias swappable in most code. There is one glaring exception however, and that is that a default constructed Outcome is <b>empty</b>, not to a default constructed <code>T</code> which makes sense given the formal empty state.</li>
<li>Outcomes implement equality/non-equality operators, but not ordering comparison nor hash operations. This is due to <a href="https://akrzemi1.wordpress.com/2014/12/02/a-gotcha-with-optional/">https://akrzemi1.wordpress.com/2014/12/02/a-gotcha-with-optional/</a> where you either choose implicit construction OR comparison operations or else risk surprising behaviours. That means you can only place Outcomes in non-mapped STL containers. It is trivial for users to supply custom comparison and hashing operations to the STL associative map if they ever really needed to store Outcomes in associative maps.</li>
<li><p class="startli">Finally, Outcome goes out of its way to be as cheap on compile time as possible by having the compiler do as little work as possible if not optimising. A lot of the hard coded rigidity above stems from systematically avoiding, whenever possible, metaprogramming, SFINAE, instantiation of helper types during deduction, or doing anything which would cause the compiler to not use <code>O(1)</code> constant time operations during non-optimising compilation. I have also found empirically that there is also a useful side effect of this simplicity of implementation on helping the compiler's optimiser "to do the right thing" by eliminating assembler generated when facing real world use cases.</p>
<p class="startli">The reason for this minimum compile time load approach was due to my work experience with original prototype Boost.Expected in 2015 where we saw large increases in compile times once Expected was deployed at scale - remember <em>every single function</em> is returning an instance of one of these and much branch logic is working with them in every function, potentially instantiating lots of shim and helper deduction and introspection types each time. P0323R1 Expected removes a large chunk of metaprogrammed functionality, specifically the monadic operations which should help a great deal. Nevertheless, from my best reading, P0323R1 Expected still demands more from the compiler than Outcome does. Deploying Outcome into a large C++ codebase ought to have as minimal a compile time impact as possible for a variant implementation, something which matters on code bases heading into the tens of millions of lines like many potential low latency/high performance users will have.</p>
</li>
</ol>
<h2><a class="anchor" id="synopsis"></a>
Synopsis of basic_monad&lt;&gt; and outcome&lt;T&gt;, result&lt;T&gt; and option&lt;T&gt;</h2>
<p>It should be stressed that <code>basic_monad&lt;&gt;</code> is a policy driven class where the policy class has the ability to arbitrarily extend and/or replace member functions listed in this synopsis. Indeed originally a non-allocating high performance <code>promise&lt;T&gt;...future&lt;T&gt;</code> implementation simply supplied a policy class implementing the additional features of promise-future to <code>basic_monad&lt;&gt;</code> whereby C++ 17 future continuations were modelled as monadic binds (it can be still found in the attic directory for anyone interested, though note how stale it likely is by now). That level of flexibility remains in the design for anyone interested in adding more <code>basic_monad&lt;&gt;</code> specialisations e.g. packed storage.</p>
<p>The following is a synopsis for <code>outcome&lt;T&gt;</code> which is configured with <code>value_type = T</code>, <code>error_type = std::error_code</code> and <code>exception_type = std::exception_ptr</code>. If it were a <code>result&lt;T&gt;</code>, only <code>value_type</code> and <code>error_type</code> functions would be present, similarly if it were an <code>option&lt;T&gt;</code> only <code>value_type</code> functions would be present.</p>
<div class="fragment"><div class="line"><a class="code" href="group__config.html#ga40359992ba8aab1355cb97bf889d1929" title="Expands into the appropriate namespace markup to enter the Outcome v1 namespace.">BOOST_OUTCOME_V1_NAMESPACE_BEGIN</a></div>
<div class="line"></div>
<div class="line"><span class="comment">// Tag types for creating empty, valued, errored and excepted basic_monad&#39;s</span></div>
<div class="line"><span class="keyword">struct </span>empty_t; constexpr empty_t <a class="code" href="group__monad.html#ga68770961e182715930ad64ca244b645e" title="Variable of type empty_t.">empty</a>;</div>
<div class="line"><span class="keyword">struct </span>value_t; constexpr value_t <a class="code" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316" title="Variable of type value_t.">value</a>;</div>
<div class="line"><span class="keyword">struct </span>error_t; constexpr error_t <a class="code" href="group__monad.html#ga1a1a8470c4efc3a52412f3ecc79a0060" title="Variable of type error_t.">error</a>;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="group__monad.html#ga93fd76af06145e1e6544d9c27bd080d0" title="Variable of type exception_t.">exception_t</a>; constexpr <a class="code" href="group__monad.html#ga93fd76af06145e1e6544d9c27bd080d0" title="Variable of type exception_t.">exception_t</a> exception;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Specialise to std::true_type for types you wish to store in a packed single byte</span></div>
<div class="line"><span class="comment">// (void and bool are done for you unless you define BOOST_OUTCOME_DISABLE_DEFAULT_SINGLE_BYTE_VALUE_STORAGE)</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> _value_type&gt; <span class="keyword">struct </span>enable_single_byte_value_storage;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Remember basic_monad&lt;Policy&lt;...&gt;&gt; is aliased to outcome&lt;T&gt;, result&lt;T&gt; and option&lt;T&gt;</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> EC = std::error_code, <span class="keyword">class</span> E = std::exception_ptr&gt;</div>
<div class="line"><span class="keyword">class </span>basic_monad&lt;monad_policy&lt;T, EC, E&gt;&gt;</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// true if configured to hold a value_type, an error_type or an exception_type</span></div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> has_value_type;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> has_error_type;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> has_exception_type;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If configured with void, set to a helpfully named unusable type </span></div>
<div class="line">  <span class="keyword">using</span> value_type = T | unusable;                                             <span class="comment">// similar in expected&lt;&gt; [3]</span></div>
<div class="line">  <span class="keyword">using</span> error_type = EC | unusable;                                            <span class="comment">// similar in expected&lt;&gt; [3]</span></div>
<div class="line">  <span class="keyword">using</span> exception_type = E | unusable;                                         <span class="comment">// [3]</span></div>
<div class="line">  <span class="keyword">struct </span>empty_type;                                                           <span class="comment">// empty tag for this monad, unlike empty_t which is for all monads</span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// The actual types configured</span></div>
<div class="line">  <span class="keyword">using</span> raw_value_type = T | void;                                             <span class="comment">// The actual type configured</span></div>
<div class="line">  <span class="keyword">using</span> raw_error_type = EC | void;                                            <span class="comment">// ditto</span></div>
<div class="line">  <span class="keyword">using</span> raw_exception_type = E | void;                                         <span class="comment">// ditto</span></div>
<div class="line"></div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt; <span class="keyword">using</span> rebind = basic_monad&lt;U&gt;;                            <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// The properties of this monad, and relative to other monads</span></div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> is_nothrow_copy_constructible;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> is_nothrow_move_constructible;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> is_nothrow_copy_assignable;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> is_nothrow_move_assignable;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> is_nothrow_destructible;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> is_trivially_destructible;</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> OtherMonad&gt; <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> is_constructible;</div>
<div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> OtherMonad&gt; <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> is_comparable;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Default implicit construction and copy and move construction</span></div>
<div class="line">  constexpr basic_monad() noexcept([1]);                                       <span class="comment">// also in expected&lt;&gt;, use make_empty_monad&lt;T&gt;() instead</span></div>
<div class="line">  constexpr basic_monad(const basic_monad&amp;) noexcept([1]);                     <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  constexpr basic_monad(basic_monad&amp;&amp;) noexcept([1]);                          <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Implicit constructing empty or with a value_type</span></div>
<div class="line">  constexpr basic_monad(empty_t) noexcept;                                     <span class="comment">// use make_empty_XXX&lt;T&gt;() instead</span></div>
<div class="line">  constexpr basic_monad(value_t) noexcept(T);                                  <span class="comment">// use make_ready_XXX&lt;T&gt;() instead</span></div>
<div class="line">  constexpr basic_monad(const value_type&amp;) noexcept(T);                        <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  constexpr basic_monad(value_type&amp;&amp;) noexcept(T);                             <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Explicit emplacement of a value_type</span></div>
<div class="line">  template &lt;class... Args&gt;</div>
<div class="line">    constexpr explicit basic_monad(in_place_t, Args&amp;&amp;...) noexcept(T);         <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  template &lt;class U&gt;</div>
<div class="line">    constexpr basic_monad(in_place_t, std::initializer_list&lt;U&gt;) noexcept(T);   <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Implicit construction from emptiness, error or excepted state of a void basic_monad</span></div>
<div class="line">  constexpr basic_monad(const rebind&lt;<span class="keywordtype">void</span>&gt;&amp;) noexcept([1]);                    <span class="comment">// use as_void() to create a void monad</span></div>
<div class="line">  constexpr basic_monad(rebind&lt;<span class="keywordtype">void</span>&gt;&amp;&amp;) noexcept([1]);                         <span class="comment">// use as_void() to create a void monad</span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Implicit construction with error_type or exception_type</span></div>
<div class="line">  constexpr basic_monad(const error_type&amp;) noexcept(EC);                       <span class="comment">// use make_errored_XXX() instead</span></div>
<div class="line">  constexpr basic_monad(error_type&amp;&amp;) noexcept(EC);                            <span class="comment">// use make_errored_XXX() instead</span></div>
<div class="line">  constexpr basic_monad(const exception_type&amp;) noexcept(E);                    <span class="comment">// use make_exceptional_XXX() instead</span></div>
<div class="line">  constexpr basic_monad(exception_type&amp;&amp;) noexcept(E);                         <span class="comment">// use make_exceptional_XXX() instead</span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Explicit up converting move and copy constructors, only</span></div>
<div class="line">  <span class="comment">// available if T, EC and E are constructible from T2, EC2 and E2</span></div>
<div class="line">  <span class="comment">// and no information can ever be lost</span></div>
<div class="line">  template &lt;class T2, class EC2, class E2&gt;</div>
<div class="line">    constexpr explicit basic_monad(basic_monad&lt;monad_policy&lt;T2, EC2, E2&gt;&gt; &amp;&amp;) noexcept([1]);</div>
<div class="line">  template &lt;class T2, class EC2, class E2&gt;</div>
<div class="line">    constexpr explicit basic_monad(const basic_monad&lt;monad_policy&lt;T2, EC2, E2&gt;&gt; &amp;) noexcept([1]);</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Not implemented if value_type, error_type and exception_type are all trivially destructible</span></div>
<div class="line">  <span class="comment">// thus making basic_monad a LiteralType (i.e. constexpr usable)</span></div>
<div class="line">  ~basic_monad() noexcept([1]);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Assignment. Note exception throws during assignment leave the monad empty</span></div>
<div class="line">  constexpr basic_monad&amp; operator=(const basic_monad&amp;) noexcept([1]);          <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  constexpr basic_monad&amp; operator=(basic_monad&amp;&amp;) noexcept([1]);               <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Observers</span></div>
<div class="line">  constexpr explicit operator <span class="keywordtype">bool</span>() const noexcept;                           <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  constexpr explicit operator boost_lite::tribool::tribool() const noexcept;   <span class="comment">// other if monad empty, false if monad errored/excepted</span></div>
<div class="line">  constexpr <span class="keywordtype">bool</span> is_ready() const noexcept;                                    <span class="comment">// i.e. not empty</span></div>
<div class="line">  constexpr <span class="keywordtype">bool</span> empty() const noexcept;</div>
<div class="line">  constexpr <span class="keywordtype">bool</span> has_value() const noexcept;                                   <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  constexpr <span class="keywordtype">bool</span> has_error() const noexcept;</div>
<div class="line">  constexpr <span class="keywordtype">bool</span> has_exception(<span class="keywordtype">bool</span> only_exception = false) const noexcept;    <span class="comment">// NOTE defaults to true also if has_error()</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// For compatibility with expected&lt;T, E&gt; and optional&lt;T&gt;</span></div>
<div class="line">  constexpr const value_type* operator -&gt;() const;                             <span class="comment">// also in expected&lt;&gt;, missing if [2]</span></div>
<div class="line">  constexpr value_type* operator -&gt;();                                         <span class="comment">// also in expected&lt;&gt;, missing if [2]</span></div>
<div class="line">  constexpr const value_type&amp; operator *() const&amp;;                             <span class="comment">// also in expected&lt;&gt;, returns by value if [2]</span></div>
<div class="line">  constexpr value_type&amp; operator *() &amp;;                                        <span class="comment">// also in expected&lt;&gt;, returns by value if [2]</span></div>
<div class="line">  constexpr const value_type&amp;&amp; operator *() const&amp;&amp;;                           <span class="comment">// also in expected&lt;&gt;, returns by value if [2]</span></div>
<div class="line">  constexpr value_type&amp;&amp; operator *() &amp;&amp;;                                      <span class="comment">// also in expected&lt;&gt;, returns by value if [2]</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Retrieving value_type</span></div>
<div class="line">  constexpr const value_type&amp; value() const&amp;;                                  <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  constexpr value_type&amp; value() &amp;;                                             <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  constexpr const value_type&amp;&amp; value() const&amp;&amp;;                                <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  constexpr value_type&amp;&amp; value() &amp;&amp;;                                           <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  constexpr const value_type &amp;value_or(const value_type &amp;) noexcept const&amp;;    <span class="comment">// similar in expected&lt;&gt;</span></div>
<div class="line">  constexpr value_type&amp; value_or(value_type&amp;) noexcept &amp;;                      <span class="comment">// similar in expected&lt;&gt;</span></div>
<div class="line">  constexpr const value_type&amp;&amp; value_or(const value_type&amp;&amp;) noexcept const&amp;&amp;;  <span class="comment">// similar in expected&lt;&gt;</span></div>
<div class="line">  constexpr value_type&amp;&amp; value_or(value_type&amp;&amp;) noexcept &amp;&amp;;                   <span class="comment">// similar in expected&lt;&gt;</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Setting value_type, disposes any previous state</span></div>
<div class="line">  constexpr <span class="keywordtype">void</span> set_value(const value_type&amp;);</div>
<div class="line">  constexpr <span class="keywordtype">void</span> set_value(value_type&amp;&amp;);</div>
<div class="line">  constexpr <span class="keywordtype">void</span> set_value();</div>
<div class="line">  template &lt;class... Args&gt;</div>
<div class="line">    constexpr <span class="keywordtype">void</span> emplace(Args&amp;&amp;...) noexcept([1]);                           <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  </div>
<div class="line">  <span class="comment">// Retrieving and setting error_type and exception_type</span></div>
<div class="line">  constexpr error_type error() const;                                          <span class="comment">// similar in expected&lt;&gt;</span></div>
<div class="line">  constexpr error_type error_or(error_type) noexcept const;</div>
<div class="line">  constexpr <span class="keywordtype">void</span> set_error(error_type);</div>
<div class="line">  constexpr exception_type exception() const;</div>
<div class="line">  constexpr exception_type exception_or(exception_type) noexcept const;</div>
<div class="line">  constexpr <span class="keywordtype">void</span> set_exception(exception_type);</div>
<div class="line">  template&lt;class E&gt; <span class="keywordtype">void</span> set_exception(E&amp;&amp;);                                   <span class="comment">// via std::make_exception_ptr</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Swap and clear to empty</span></div>
<div class="line">  <span class="keywordtype">void</span> <a class="code" href="group__monad.html#ga2ffab91838224f042fe7ed1b108e5ad7" title="Specialise swap for basic_monad.">swap</a>(basic_monad&amp;) noexcept([1]);                                       <span class="comment">// also in expected&lt;&gt;</span></div>
<div class="line">  <span class="keywordtype">void</span> clear() noexcept([1]);</div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#ifdef BOOST_OUTCOME_ENABLE_OPERATORS                                          // defaults to disabled (documented below)</span></div>
<div class="line"><span class="preprocessor"></span>  basic_monad&lt;...&gt; unwrap() const &amp;;</div>
<div class="line">  basic_monad&lt;...&gt; unwrap() &amp;&amp;;</div>
<div class="line">  template&lt;class F&gt; basic_monad&lt;...&gt; bind(F &amp;&amp;f);</div>
<div class="line">  template&lt;class F&gt; basic_monad&lt;...&gt; operator&gt;&gt;(F &amp;&amp;f);</div>
<div class="line">  template&lt;class F&gt; basic_monad&lt;...&gt; map(F &amp;&amp;f);</div>
<div class="line">  template&lt;class F&gt; basic_monad(F(contents)).unwrap() match(F &amp;&amp;f);</div>
<div class="line">  template&lt;class... Args&gt; decltype(value_type(Args...)) operator()(Args &amp;&amp;...);</div>
<div class="line">  </div>
<div class="line">  template&lt;class U&gt; constexpr basic_monad operator|(U &amp;&amp;) &amp;;</div>
<div class="line">  template&lt;class U&gt; constexpr basic_monad operator|(U &amp;&amp;) const&amp;;</div>
<div class="line">  template&lt;class U&gt; constexpr basic_monad operator|(U &amp;&amp;) &amp;&amp;;</div>
<div class="line">  template&lt;class U&gt; constexpr basic_monad operator&amp;(U &amp;&amp;) &amp;;</div>
<div class="line">  template&lt;class U&gt; constexpr basic_monad operator&amp;(U &amp;&amp;) const&amp;;</div>
<div class="line">  template&lt;class U&gt; constexpr basic_monad operator&amp;(U &amp;&amp;) &amp;&amp;;</div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>};</div>
<div class="line"></div>
<div class="line"><span class="comment">// NOTE requires state to be set to valued beforehand (and can only deserialise a value)</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Policy&gt; <span class="keyword">inline</span> std::istream &amp;<a class="code" href="group__monad.html#ga70474a7831a5c7c7f045043ba554ff5a" title="Deserialise a value_storage value_type (only value_type)">operator&gt;&gt;</a>(std::istream &amp;s, basic_monad&lt;Policy&gt; &amp;v);</div>
<div class="line"><span class="comment">// Intended for printing rather than serialisation to storage</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Policy&gt; <span class="keyword">inline</span> std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, const basic_monad&lt;Policy&gt; &amp;v);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Equality operators</span></div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Policy1, <span class="keyword">class</span> Policy2&gt; constexpr <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a63db4c206ada0cb03a5a1fbe0d626ba7" title="True if this monad exactly equals the other monad.">operator==</a>(<span class="keyword">const</span> basic_monad&lt;Policy1&gt; &amp;, <span class="keyword">const</span> basic_monad&lt;Policy2&gt; &amp;);</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Policy1, <span class="keyword">class</span> Policy2&gt; constexpr <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="namespaceboost_1_1outcome_1_1v1__xxx.html#a45313fa17aa4be05a21363191dacab93" title="True if this monad does not exactly equal the other monad.">operator!=</a>(<span class="keyword">const</span> basic_monad&lt;Policy1&gt; &amp;, <span class="keyword">const</span> basic_monad&lt;Policy2&gt; &amp;);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Outcome makers</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#ga6965ad141b9cf5cc08f26684ea54967d" title="Makes an outcome from the type passed.">make_outcome</a>(T &amp;&amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#ga6965ad141b9cf5cc08f26684ea54967d" title="Makes an outcome from the type passed.">make_outcome</a>(<span class="keyword">const</span> T &amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#ga6965ad141b9cf5cc08f26684ea54967d" title="Makes an outcome from the type passed.">make_outcome</a>(error_code_extended v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#ga6965ad141b9cf5cc08f26684ea54967d" title="Makes an outcome from the type passed.">make_outcome</a>(std::exception_ptr v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; constexpr <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#ga6965ad141b9cf5cc08f26684ea54967d" title="Makes an outcome from the type passed.">make_outcome</a>();</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; constexpr <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#gadfda8cccf3a09f8ee574f3eee65db59e" title="Makes an empty outcome of type T.">make_empty_outcome</a>();</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#gaddfb03f7b310708ac4e529c5fe24da57" title="Make a ready outcome from the type passed.">make_ready_outcome</a>(T &amp;&amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#gaddfb03f7b310708ac4e529c5fe24da57" title="Make a ready outcome from the type passed.">make_ready_outcome</a>(<span class="keyword">const</span> T &amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; constexpr <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#gaddfb03f7b310708ac4e529c5fe24da57" title="Make a ready outcome from the type passed.">make_ready_outcome</a>();  <span class="comment">// can be specialised for some type T, defaults to refusing to compile except for void</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">inline</span> outcome&lt;void&gt; make_ready_outcome&lt;void&gt;();</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#ga32c259d35a71b8a671e062519c2a0465" title="Make an errored outcome from the type passed.">make_errored_outcome</a>(error_code_extended v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#ga32c259d35a71b8a671e062519c2a0465" title="Make an errored outcome from the type passed.">make_errored_outcome</a>(<span class="keywordtype">int</span> e, <span class="keyword">const</span> <span class="keywordtype">char</span> *extended = <span class="keyword">nullptr</span>);                      <span class="comment">// errno consumer</span></div>
<div class="line"><span class="preprocessor">#if defined(_WIN32)</span></div>
<div class="line"><span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; constexpr <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#ga32c259d35a71b8a671e062519c2a0465" title="Make an errored outcome from the type passed.">make_errored_outcome</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> e, <span class="keyword">const</span> <span class="keywordtype">char</span> *extended = <span class="keyword">nullptr</span>);  <span class="comment">// GetLastError() consumer</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#ga0fefb54f3aeb9fd6340a5ecff3ec5931" title="Make an excepted outcome from the type passed.">make_exceptional_outcome</a>(std::exception_ptr v);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Result makers</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#ga559b5e8efc12ededdc3aeecce0d304de" title="Makes a result from the type passed.">make_result</a>(T &amp;&amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#ga559b5e8efc12ededdc3aeecce0d304de" title="Makes a result from the type passed.">make_result</a>(<span class="keyword">const</span> T &amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#ga559b5e8efc12ededdc3aeecce0d304de" title="Makes a result from the type passed.">make_result</a>(error_code_extended v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; constexpr <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#ga559b5e8efc12ededdc3aeecce0d304de" title="Makes a result from the type passed.">make_result</a>();</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; constexpr <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#ga4bff5754b64adeb2708ab9bec52aff57" title="Makes an empty result of type T.">make_empty_result</a>();</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#ga8a14014596a489c7b9741c4194f1a06f" title="Makes a result from the type passed.">make_ready_result</a>(T &amp;&amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#ga8a14014596a489c7b9741c4194f1a06f" title="Makes a result from the type passed.">make_ready_result</a>(<span class="keyword">const</span> T &amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; constexpr <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#ga8a14014596a489c7b9741c4194f1a06f" title="Makes a result from the type passed.">make_ready_result</a>();    <span class="comment">// can be specialised for some type T, defaults to refusing to compile except for void</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt; <span class="keyword">inline</span> result&lt;void&gt; make_ready_result&lt;void&gt;();</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#ga6175fc3a5c4bb5ab9f782654e96bb354" title="Make an errored result from the type passed.">make_errored_result</a>(error_code_extended v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; constexpr <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#ga6175fc3a5c4bb5ab9f782654e96bb354" title="Make an errored result from the type passed.">make_errored_result</a>(<span class="keywordtype">int</span> e, <span class="keyword">const</span> <span class="keywordtype">char</span> *extended = <span class="keyword">nullptr</span>);              <span class="comment">// errno consumer</span></div>
<div class="line"><span class="preprocessor">#if defined(_WIN32)</span></div>
<div class="line"><span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; constexpr <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#ga6175fc3a5c4bb5ab9f782654e96bb354" title="Make an errored result from the type passed.">make_errored_result</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> e, <span class="keyword">const</span> <span class="keywordtype">char</span> *extended = <span class="keyword">nullptr</span>);    <span class="comment">// GetLastError() consumer</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Option makers</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> option&lt;T&gt; <a class="code" href="group__monad.html#ga7729448d32a8fd9ee4a34fc84152e165" title="Makes a option from the type passed.">make_option</a>(T &amp;&amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> option&lt;T&gt; <a class="code" href="group__monad.html#ga7729448d32a8fd9ee4a34fc84152e165" title="Makes a option from the type passed.">make_option</a>(<span class="keyword">const</span> T &amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; constexpr <span class="keyword">inline</span> option&lt;T&gt; <a class="code" href="group__monad.html#ga7729448d32a8fd9ee4a34fc84152e165" title="Makes a option from the type passed.">make_option</a>();</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; constexpr <span class="keyword">inline</span> option&lt;T&gt; <a class="code" href="group__monad.html#ga85a0d8107c763a68a4705ed56d0d5fdf" title="Makes an empty option of type T.">make_empty_option</a>();</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> option&lt;T&gt; <a class="code" href="group__monad.html#ga770b7101b357cfdaae3929559c70b627" title="Makes a option from the type passed.">make_ready_option</a>(T &amp;&amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> option&lt;T&gt; <a class="code" href="group__monad.html#ga770b7101b357cfdaae3929559c70b627" title="Makes a option from the type passed.">make_ready_option</a>(<span class="keyword">const</span> T &amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T = <span class="keywordtype">void</span>&gt; constexpr <span class="keyword">inline</span> option&lt;T&gt; <a class="code" href="group__monad.html#ga770b7101b357cfdaae3929559c70b627" title="Makes a option from the type passed.">make_ready_option</a>();    <span class="comment">// can be specialised for some type T, defaults to refusing to compile except for void</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt; constexpr <span class="keyword">inline</span> option&lt;void&gt; make_ready_option&lt;void&gt;();</div>
<div class="line"></div>
<div class="line"><span class="comment">// Upconverters</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#gae530c39aba6722190036aaeb7bf411f7" title="Makes an outcome from a result.">as_outcome</a>(result&lt;T&gt; &amp;&amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#gae530c39aba6722190036aaeb7bf411f7" title="Makes an outcome from a result.">as_outcome</a>(<span class="keyword">const</span> result&lt;T&gt; &amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#gae530c39aba6722190036aaeb7bf411f7" title="Makes an outcome from a result.">as_outcome</a>(option&lt;T&gt; &amp;&amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> outcome&lt;T&gt; <a class="code" href="group__monad.html#gae530c39aba6722190036aaeb7bf411f7" title="Makes an outcome from a result.">as_outcome</a>(<span class="keyword">const</span> option&lt;T&gt; &amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#gac0eff505d8bb5f39bd701be19fbdaac5" title="Makes a result from an option.">as_result</a>(option&lt;T&gt; &amp;&amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> result&lt;T&gt; <a class="code" href="group__monad.html#gac0eff505d8bb5f39bd701be19fbdaac5" title="Makes a result from an option.">as_result</a>(<span class="keyword">const</span> option&lt;T&gt; &amp;v);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Emptiness, errored and excepted state extractors</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> outcome&lt;void&gt; <a class="code" href="group__monad.html#ga31623e855d816d8be8b796107e29d4f7" title="Makes a void outcome from an input outcome, forwarding any emptiness, error or exception.">as_void</a>(<span class="keyword">const</span> outcome&lt;T&gt; &amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">inline</span> result&lt;void&gt; <a class="code" href="group__monad.html#ga31623e855d816d8be8b796107e29d4f7" title="Makes a void outcome from an input outcome, forwarding any emptiness, error or exception.">as_void</a>(<span class="keyword">const</span> result&lt;T&gt; &amp;v);</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; constexpr <span class="keyword">inline</span> option&lt;void&gt; <a class="code" href="group__monad.html#ga31623e855d816d8be8b796107e29d4f7" title="Makes a void outcome from an input outcome, forwarding any emptiness, error or exception.">as_void</a>(<span class="keyword">const</span> option&lt;T&gt; &amp;v);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Equivalent to try! in Rust and Swift (see below for docs)</span></div>
<div class="line"><span class="preprocessor">#define BOOST_OUTCOME_TRY(variable_to_initialise, monad)</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><span class="comment">// Boilerplate catching all the STL exceptions, returning an equivalent result&lt;void&gt; (see below for docs)</span></div>
<div class="line"><span class="preprocessor">#define BOOST_OUTCOME_CATCH_EXCEPTION_TO_RESULT</span></div>
<div class="line"><span class="preprocessor"></span></div>
<div class="line"><a class="code" href="group__config.html#gab3e267fb24a8ce5fe29ddf36f4f3c10b" title="Expands into the appropriate namespace markup to exit the Outcome v1 namespace.">BOOST_OUTCOME_V1_NAMESPACE_END</a></div>
</div><!-- fragment --><p>[1]: The <code>noexcept</code> for each of these is determined by calculating the <code>noexcept</code> for the same operation in each of <code>T</code>, <code>EC</code> and <code>E</code>. If the same operation on any of those types can throw, so can the basic_monad's operation.</p>
<p>[2]: The trait <code>boost::outcome::enable_single_byte_value_storage&lt;T&gt;</code> determines if a single byte is used to store <code>T</code>, in which case you will not be returned a pointer nor reference to <code>T</code>. It is enabled for <code>bool</code> and <code>void</code> unless the macro <code>BOOST_OUTCOME_DISABLE_DEFAULT_SINGLE_BYTE_VALUE_STORAGE</code> is defined.</p>
<p>[3]: If the monad was configured with <code>void</code> in this place, this is configured with an internal non-accessible type usefully named to indicate you are trying to use something not possible which will generate a very obvious descriptive compiler error.</p>
<h2><a class="anchor" id="examples"></a>
Examples of usage</h2>
<p>The above synopsis of Outcome looks lengthy and complex, but almost all of it is convenience overloads of one form or other. In usage Outcome is generally "stupid easy" to program with, especially if you're already used to <code>std::optional</code>. Here is a real world use case distilled from AFIO v2's source code:</p>
<div class="fragment"><div class="line">  <span class="keyword">using namespace </span>minimal_afio;</div>
<div class="line">  <span class="keyword">using</span> boost_lite::ringbuffer_log::last190;</div>
<div class="line">  <span class="keyword">extern</span> BOOST_SYMBOL_EXPORT result&lt;file_handle&gt; file_create(              <span class="comment">//</span></div>
<div class="line">  file_handle::path_type _path,                                            <span class="comment">//</span></div>
<div class="line">  file_handle::mode _mode = file_handle::mode::read,                       <span class="comment">//</span></div>
<div class="line">  file_handle::creation _creation = file_handle::creation::open_existing,  <span class="comment">//</span></div>
<div class="line">  file_handle::caching _caching = file_handle::caching::all,               <span class="comment">//</span></div>
<div class="line">  file_handle::flag flags = file_handle::flag::none) noexcept              <span class="comment">//</span></div>
<div class="line">  {</div>
<div class="line"><span class="preprocessor">#ifdef __cpp_exceptions</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// If exceptions are turned on (the above is the C++ 17 feature detection</span></div>
<div class="line">    <span class="comment">// macro, Boost-lite provides a consistent set of these on all platforms)</span></div>
<div class="line">    <span class="comment">// noexcept functions should always wrap their innards in a try...catch,</span></div>
<div class="line">    <span class="comment">// if you don&#39;t ever call a potentially throwing piece of code the compiler</span></div>
<div class="line">    <span class="comment">// will completely elide the runtime try...catch overhead.</span></div>
<div class="line">    <span class="keywordflow">try</span></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>    {</div>
<div class="line">      result&lt;file_handle&gt; ret(file_handle(std::move(_path), _caching, flags));</div>
<div class="line">      native_handle_type &amp;nativeh = ret.value()._v;</div>
<div class="line"></div>
<div class="line">      <span class="comment">// access_mask_from_handle_mode() returns a result&lt;ACCESS_MASK&gt;,</span></div>
<div class="line">      <span class="comment">// if it is signalled then propagate it immediately by returning it,</span></div>
<div class="line">      <span class="comment">// else unwrap the return value into the variable access</span></div>
<div class="line">      <a class="code" href="monad_8hpp.html#aa977bf0b7aded30c781c35f956edc1d7" title="If the monad returned by expression m is empty, erroneous or excepted, propagate that by immediately ...">BOOST_OUTCOME_TRY</a>(access, access_mask_from_handle_mode(_mode));</div>
<div class="line">      DWORD creation = OPEN_EXISTING;</div>
<div class="line">      <span class="keywordflow">switch</span>(_creation)</div>
<div class="line">      {</div>
<div class="line">      <span class="keywordflow">case</span> file_handle::creation::open_existing:</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> file_handle::creation::only_if_not_exist:</div>
<div class="line">        creation = CREATE_NEW;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> file_handle::creation::if_needed:</div>
<div class="line">        creation = OPEN_ALWAYS;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      <span class="keywordflow">case</span> file_handle::creation::truncate:</div>
<div class="line">        creation = TRUNCATE_EXISTING;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">      }</div>
<div class="line"></div>
<div class="line">      <span class="comment">// attributes_from_handle_caching_and_flags() returns a result&lt;DWORD&gt;,</span></div>
<div class="line">      <span class="comment">// so if it errors the propagate immediately, else unpack DWORD into</span></div>
<div class="line">      <span class="comment">// the variable attribs</span></div>
<div class="line">      <a class="code" href="monad_8hpp.html#aa977bf0b7aded30c781c35f956edc1d7" title="If the monad returned by expression m is empty, erroneous or excepted, propagate that by immediately ...">BOOST_OUTCOME_TRY</a>(attribs, attributes_from_handle_caching_and_flags(_caching, flags));</div>
<div class="line">      <span class="keywordflow">if</span>(INVALID_HANDLE_VALUE == (nativeh.h = CreateFile(ret.value()._path.c_str(), access, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, creation, attribs, NULL)))</div>
<div class="line">      {</div>
<div class="line">        DWORD errcode = GetLastError();</div>
<div class="line"></div>
<div class="line">        <span class="comment">// make_errored_result() understands DWORDs on Windows. It also understands</span></div>
<div class="line">        <span class="comment">// int for automatic errno conversion.</span></div>
<div class="line">        <span class="keywordflow">return</span> make_errored_result&lt;file_handle&gt;(errcode, last190(ret.value()._path.u8string()));</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">if</span>(flags &amp; file_handle::flag::unlink_on_close)</div>
<div class="line">      {</div>
<div class="line">        <span class="comment">// Hide this item</span></div>
<div class="line">        SetFileAttributes(ret.value()._path.c_str(), FILE_ATTRIBUTE_HIDDEN);</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> ret;</div>
<div class="line">    }</div>
<div class="line"><span class="preprocessor">#ifdef __cpp_exceptions</span></div>
<div class="line"><span class="preprocessor"></span>    <span class="comment">// Catch all the STL exceptions, converting them to an equivalent result&lt;&gt;</span></div>
<div class="line">    <span class="comment">// containing a system_error with the appropriate error_code.</span></div>
<div class="line">    <a class="code" href="group__macro__helpers.html#gaacf14d3429ad0bc72a6ba40e7f283b43" title="A boilerplate sequence of catch(exceptions...) returning those exceptions as their equivalent result&lt;...">BOOST_OUTCOME_CATCH_EXCEPTION_TO_RESULT</a></div>
<div class="line"><span class="preprocessor">#endif</span></div>
<div class="line"><span class="preprocessor"></span>  }</div>
</div><!-- fragment --> <dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Add link to whole source code in an online compiler explorer so end users can play with the use case</dd></dl>
<p>Unlike the earlier example functions opening a file, the above is not a toy use case and it covers almost all of the permutations of creating or opening a file which are common to POSIX and Windows. We make use of the fact that <code>basic_monad&lt;&gt;</code><code>::</code><code><a class="el" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316" title="Variable of type value_t.">value()</a></code> returns a non-const lvalue ref when the monad instance is a non-const stack allocated instance, binding it to the convenience lvalue ref <code>nativeh</code> which points at a union containing the <code>HANDLE</code> later filled with the opened handle.</p>
<p>We make use of <code><a class="el" href="monad_8hpp.html#aa977bf0b7aded30c781c35f956edc1d7" title="If the monad returned by expression m is empty, erroneous or excepted, propagate that by immediately ...">BOOST_OUTCOME_TRY(var, expr)</a></code> which is a macro expanding to:</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> &amp;&amp;unique = (expr);                                  <span class="comment">// &quot;unique&quot; is a preprocessor generated unique temporary identifier</span></div>
<div class="line"><span class="keywordflow">if</span>(!unique.has_value())</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code" href="group__monad.html#ga31623e855d816d8be8b796107e29d4f7" title="Makes a void outcome from an input outcome, forwarding any emptiness, error or exception.">BOOST_OUTCOME_V1_NAMESPACE::as_void</a>(unique);</div>
<div class="line"><span class="keyword">auto</span> var(std::move(std::move(unique).<a class="code" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316" title="Variable of type value_t.">value</a>()))</div>
</div><!-- fragment --><p>This gets as close as is possible in C++ to the <code>try!</code> facility in Rust or Swift without using exception throws, and you'll find yourself using it a very great deal when writing code using Outcome. Like <code>try!</code>, the monad returning expression is executed and its returned monad checked to see if it has a value. If it does, the value is extracted out of the monad and placed in the variable you asked for. If it did not contain a value, the emptiness/errored/exceptioned state is converted into a void form monad and returned immediately from the calling function, thus propagating the empty/errored/exceptioned state up the stack. You'll note we cast the stack allocated monad instance into a rvalue ref before asking for its value, this returns a rvalue ref to the value. We then pass that rvalue ref through to the variable instance constructor so the value is moved and not copied when possible. I have disassembled this sequence on the main compilers and found that where the compiler knows for a fact that a value is being returned, all runtime overhead over a straight return of a value is usually eliminated.</p>
<p>We also make use of a convenience overload of the <code>make_errored_XXX()</code> functions where a single <code>int</code> is assumed to be a POSIX code in the <code>errno</code> domain and a single <code>DWORD</code> is assumed to be a Win32 code in the <code>GetLastError()</code> domain. This allows very easy conversion of system error codes into the appropriate <code>std::error_code</code> thusly returned wrapped in a monad.</p>
<p>Finally we also make use of the <code>BOOST_OUTCOME_CATCH_EXCEPTION_TO_RESULT</code> macro which is a long sequence of STL exception type catch clauses converting STL exception types into their equivalent error codes:</p>
<div class="fragment"><div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::invalid_argument &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EINVAL, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::domain_error &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EDOM, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::length_error &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(E2BIG, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::out_of_range &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(ERANGE, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::logic_error &amp;e) <span class="comment">/* base class for this group */</span></div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EINVAL, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::system_error &amp;e) <span class="comment">/* also catches ios::failure */</span></div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(BOOST_OUTCOME_V1_NAMESPACE::error_code_extended(e.code(), e.what()));</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::overflow_error &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EOVERFLOW, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::range_error &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(ERANGE, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::runtime_error &amp;e) <span class="comment">/* base class for this group */</span></div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EAGAIN, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::bad_alloc &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(ENOMEM, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(<span class="keyword">const</span> std::exception &amp;e)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EINVAL, e.what());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">catch</span>(...)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">return</span> BOOST_OUTCOME_V1_NAMESPACE::make_errored_result&lt;void&gt;(EAGAIN, <span class="stringliteral">&quot;unknown exception&quot;</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>You will surely note that the <code>make_errored_XXX()</code> functions actually take an <code>int</code> and an optional <code>const char *</code>. This is the purpose of <code>error_code_extended</code> which extends <code>std::error_code</code> with the following synposis:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>error_code_extended : <span class="keyword">public</span> std::error_code</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">  error_code_extended();</div>
<div class="line">  error_code_extended(<span class="keywordtype">int</span> ec, <span class="keyword">const</span> std::error_category &amp;cat, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>, <span class="keywordtype">unsigned</span> code1 = 0, <span class="keywordtype">unsigned</span> code2 = 0, <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <a class="code" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316" title="Variable of type value_t.">template &lt;class ErrorCodeEnum, typename = typename std::enable_if&lt;std::is_error_code_enum&lt;ErrorCodeEnum&gt;::value</a>&gt;::type&gt;</div>
<div class="line">    error_code_extended(ErrorCodeEnum e);</div>
<div class="line">  <span class="keyword">explicit</span> error_code_extended(<span class="keyword">const</span> std::error_code &amp;e, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>, <span class="keywordtype">unsigned</span> code1 = 0, <span class="keywordtype">unsigned</span> code2 = 0, <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <span class="keyword">explicit</span> error_code_extended(std::error_code &amp;&amp;e, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>, <span class="keywordtype">unsigned</span> code1 = 0, <span class="keywordtype">unsigned</span> code2 = 0, <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <span class="keywordtype">void</span> assign(<span class="keywordtype">int</span> ec, <span class="keyword">const</span> std::error_category &amp;cat, <span class="keyword">const</span> <span class="keywordtype">char</span> *msg = <span class="keyword">nullptr</span>, <span class="keywordtype">unsigned</span> code1 = 0, <span class="keywordtype">unsigned</span> code2 = 0, <span class="keywordtype">bool</span> backtrace = <span class="keyword">false</span>);</div>
<div class="line">  <span class="keywordtype">void</span> clear();</div>
<div class="line">  </div>
<div class="line">  <span class="comment">// New member functions</span></div>
<div class="line">  <span class="comment">// Fill a char buffer with the extended message, retrieving the two extended unsigned integer codes</span></div>
<div class="line">  <span class="keywordtype">size_t</span> extended_message(<span class="keywordtype">char</span> *buffer, <span class="keywordtype">size_t</span> len, <span class="keywordtype">unsigned</span> &amp;code1, <span class="keywordtype">unsigned</span> &amp;code2) <span class="keyword">const</span> noexcept;</div>
<div class="line">  <span class="comment">// Return an array of strings describing the stack at the time of construction. MUST call free() on this returned pointer.</span></div>
<div class="line">  <span class="keywordtype">char</span> **backtrace() const noexcept;</div>
<div class="line">};</div>
<div class="line"><span class="comment">// Prints the extended error code, including any extended information if available</span></div>
<div class="line">inline std::ostream &amp;operator&lt;&lt;(std::ostream &amp;s, const error_code_extended &amp;ec);</div>
</div><!-- fragment --><p><code>error_code_extended</code> is completely API compatible with <code>std::error_code</code> and all its member functions can be used the same way. You can supply a <code>std::error_code</code> to an extended error code, or else construct an extended error code the same way you would a STL error code. You should note that it is <b>always safe</b> to slice <code>error_code_extended</code> into an <code>std::error_code</code>, so you can safely feed <code>error_code_extended</code> to anything consuming a <code>std::error_code</code>.</p>
<p>The main big additions are obviously the ability to add a custom string message to an extended error code, this allows the preservation of the original <code>what()</code> message when converting a thrown exception into an extended error code. You can also add two arbitrary unsigned integer codes and most interestingly, a backtrace of the stack at the point of construction. The extended message and backtrace can be later fetched using the new member functions, though note that the storage for these is kept in a statically allocated threadsafe ring buffer and so may vanish at some arbitrary later point when the storage gets recycled. If this happens, <code>extended_message()</code> will return zero characters written and <code>backtrace()</code> will return a null pointer.</p>
<p>If you are throwing your own custom types with custom information, you should note that you can create your own custom extended error code type using the same reusable microsecond fast threadsafe logging framework that Outcome uses. This won't be documented here as that framework (<code>ringbuffer_log</code>) lives in Boost-lite, but it's fairly easy to study Outcome's and Boost-lite's source code all of which is on github.</p>
<p><br/>
</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="when_use"></a>
When am I supposed to use what when?</h1>
<p>The total available permutations may seem overwhelming at this point, because as with any fundamental primitive the possibilities are endless. However, here are some quick notes to help you decide what design pattern to use for your particular code base:</p>
<h2><a class="anchor" id="outcome_vs_result"></a>
When should I use a result&lt;T&gt; instead of an outcome&lt;T&gt;?</h2>
<p><code>outcome&lt;T&gt;</code> has the potential to carry a <code>std::exception_ptr</code> which is implemented by any STL I can think of as something very similar to a <code>std::shared_ptr</code> i.e. it uses atomics to manage the reference count. Atomics are unavoidably a <em>compiler fence</em> i.e. the compiler <b>must</b> emit code at the point of the fence. Outcome has been very carefully written to let the compiler's optimiser <em>not</em> emit code thus leading to its stellar low runtime overhead. Whilst recent versions of GCC and clang seem reasonably good at eliding compiler fences caused by use of atomics in <code>std::exception_ptr</code> when the compiler is absolutely sure that no <code>std::exception_ptr</code> can be transported, where there is doubt the compiler has no choice but to generate a lot more assembler to cover all the possible outcomes. <code>result&lt;T&gt;</code> cannot transport a <code>std::exception_ptr</code> and therefore doesn't force the compiler to generate output (except unfortunately on the Dinkumware STL where fetching a STL error category e.g. <code>std::generic_category()</code> uses atomics).</p>
<p>So in short, always use <code>result&lt;T&gt;</code> instead of <code>outcome&lt;T&gt;</code> where doing so does not impact negatively on your codebase, and remember one bit of your code can use <code>result&lt;T&gt;</code> and another <code>outcome&lt;T&gt;</code> just fine.</p>
<h2><a class="anchor" id="result_vs_outcome"></a>
When should I use an outcome&lt;T&gt; instead of a result&lt;T&gt;?</h2>
<p>The main reason to use an <code>outcome&lt;T&gt;</code> is in the "sea of noexcept" design pattern where implementations may throw exceptions internally, but all public extern APIs are always noexcept. <code>outcome&lt;T&gt;</code> provides a lossless method of exporting the thrown exception but without loading the programmer with dealing with unexpected control flow reversal, thus helping the programmer write correct exception safe code faster.</p>
<p>One can implement the "exceptions are exceptional" design pattern easily with Expected: expected errors are returned via <code>expected&lt;T, E&gt; = E</code> and aborting errors are returned via an exception throw. However the role where using <code>outcome&lt;T&gt;</code> really shines is in the "exceptions
are exceptional" combined with "sea of noexcept" design pattern where the errored state means an expected error which was handled inline, but the exceptioned state means an operation was aborted, yet the programmer still can easily write exception safe forward-only-execution code not having to worry about unexpected control flow inversion. This is where using Outcome adds significant value over using Expected.</p>
<p>Finally, there is a third big reason to use Outcome. The main reason I designed and wrote Outcome was to implement a universal error handling framework which could express <em>in the minimum possible overhead</em>, and without losing information, the many C++ error handling design patterns possible, and even more importantly that individual libraries could use the design pattern which best suited them whilst seamlessly interoperating with other libraries using different error handling designs. To go into a bit more detail:</p>
<ul>
<li>Proposed <a href="https://ned14.github.io/boost.afio/">Boost.AFIO v2</a> is a very low level very thin file i/o and filesystem library which sits just above the raw kernel syscalls. Throwing exceptions in such a library is overkill, so AFIO v2 uses the "sea of noexcept" design pattern both in its public API and in its internal implementation (i.e. it doesn't use C++ exceptions at all).</li>
<li>Proposed <a href="https://github.com/ned14/boost.kerneltest">Boost.KernelTest</a> is a kernel based testing infrastructure which uses Outcomes as the storage for each kernel permutation run in its permutation tables of preconditions, postconditions, parameters and outcomes. KernelTest itself is written using the "exceptions are exceptional" design pattern where expected errors are returned via outcomes but unexpected errors which abort the test use thrown exceptions which are collected into <code>outcome&lt;T&gt;</code>'s. AFIO v2's test suite is written using KernelTest.</li>
<li>Planned Boost.BLOBStore will be a versioned, ACID transactional key to BLOB store written using AFIO v2 which will use both the "sea of noexcept" and the "exceptions are exceptional" design patterns together. This allows user supplied callbacks to throw exceptions which aborts the current transaction and for those exceptions to be propagated, if desired, out of BLOBStore whilst the internal implementation of BLOBStore and indeed its public API is all noexcept and never throws exceptions (writing correct filesystem code is hard enough without dealing with unexpected control flow reversal). BLOBStore will also use KernelTest for its test suite.</li>
</ul>
<p><br/>
</p>
<hr/>
<p><br/>
</p>
<h1><a class="anchor" id="advanced"></a>
More advanced usage</h1>
<p>99% of Outcome users already have everything they will ever need - Outcome is a very simple library. However "full fat" monadic functional programming is also provided using a very clean and powerful API, albeit at a fair cost to compile times.</p>
<h2><a class="anchor" id="functional"></a>
Functional programming extensions (optional)</h2>
<dl class="section note"><dt>Note</dt><dd>All code in this section can be enabled by defining <code>BOOST_OUTCOME_ENABLE_OPERATORS</code>. By default only <code>next()</code> is available. This prevents you writing code which impacts build times.</dd></dl>
<p>It is assumed in this section that you already understand monadic functional programming. This section is simply to explain how these are implemented in Outcome.</p>
<p>Classic monadic programming consists of a sequence of nested functional operations: </p>
<dl>
<dt>JOIN (single): <code>outcome&lt;outcome&lt;T&gt;&gt;.<a class="el" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316" title="Variable of type value_t.">value()</a></code> -&gt; <code>outcome&lt;T&gt;</code> </dt>
<dd></dd>
<dt>JOIN (maximum): <code>outcome&lt;outcome&lt;outcome&lt;outcome&lt;T&gt;&gt;&gt;&gt;.unwrap()</code> -&gt; <code>outcome&lt;T&gt;</code> </dt>
<dd>Whatever is the first monad containing a non-monad is returned. </dd>
<dt>MAP: <code>outcome&lt;T&gt;.map(R(T))</code> -&gt; <code>outcome&lt;R&gt;</code> </dt>
<dd>If callable maps <code>T</code> to <code>R</code>, <code>map()</code> maps an <code>outcome&lt;T&gt;</code> to an <code>outcome&lt;R&gt;</code> if <code>outcome&lt;T&gt;</code> contains a <code>T</code>. If it contains an error or is empty, that is passed through. </dd>
<dt>BIND: <code>outcome&lt;T&gt;.bind(outcome&lt;R&gt;(T))</code> -&gt; <code>outcome&lt;R&gt;</code> </dt>
<dd></dd>
<dt>BIND: <code>outcome&lt;T&gt;.bind(R(T))</code> -&gt; <code>outcome&lt;R&gt;</code> </dt>
<dd>If callable maps <code>T</code> to <code>outcome&lt;R&gt;</code> and if <code>outcome&lt;T&gt;</code> contains a <code>T</code>, then <code>bind()</code> maps an <code>outcome&lt;T&gt;</code> to an <code>outcome&lt;R&gt;</code> else if callable maps <code>T</code> to <code>R</code> and if <code>outcome&lt;T&gt;</code> contains a <code>T</code>, <code>bind()</code> maps an <code>outcome&lt;T&gt;</code> to an <code>outcome&lt;R&gt;</code>. In other words, returning a monad from the callable does not wrap it in another monad. If the originating monad did not contain a <code>T</code>, that is passed through. </dd>
</dl>
<p>We also support <code>outcome&lt;T&gt;.next(R(outcome&lt;T&gt;))</code> for semantic equivalence to futures where the callable is called with the originating monad. This acts like <code>bind()</code>, so if the callable returns a monad it is not wrapped in another monad. Unlike <code>map()</code> or <code>bind()</code>, <code>next()</code> always calls the callable no matter what the monad contains, so it is up to you to interrogate the monad. Note that the originating monad is passed by const lvalue ref unless the callable takes a rvalue ref to the monad.</p>
<p>A quick use example: </p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; outcome&lt;T&gt; do_test(outcome&lt;T&gt; m)</div>
<div class="line">{</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The value of my input monad is &quot;</span>;</div>
<div class="line">  <span class="keywordflow">if</span>(m)</div>
<div class="line">    std::cout &lt;&lt; m.value() &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">else</span></div>
<div class="line">    std::cout &lt;&lt; (m.has_error() ? <span class="stringliteral">&quot;errored&quot;</span> : m.has_exception() ? <span class="stringliteral">&quot;excepted&quot;</span> : <span class="stringliteral">&quot;empty&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">  </div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;  or via bind(), my value is &quot;</span>;</div>
<div class="line">  <span class="keyword">auto</span> o(m &gt;&gt; [](T v) { std::cout &lt;&lt; v; <span class="keywordflow">return</span> v; }</div>
<div class="line">           &gt;&gt; [](error_code_extended e) { std::cout &lt;&lt; <span class="stringliteral">&quot;errored&quot;</span>; <span class="keywordflow">return</span> e; }</div>
<div class="line">           &gt;&gt; [](std::exception_ptr e) { std::cout &lt;&lt; <span class="stringliteral">&quot;excepted&quot;</span>; <span class="keywordflow">return</span> e; }</div>
<div class="line">           &gt;&gt; [](<span class="keyword">typename</span> decltype(m)::empty_type) { std::cout &lt;&lt; <span class="stringliteral">&quot;empty&quot;</span>; });</div>
<div class="line">  std::cout &lt;&lt; std::endl;</div>
<div class="line">  <span class="keywordflow">return</span> o;</div>
<div class="line">}</div>
</div><!-- fragment --><div class="fragment"><div class="line">  <span class="keyword">struct </span>o_type</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordtype">int</span> expected;</div>
<div class="line">    <span class="comment">// monad.match() will call an overload for each possible content it might have</span></div>
<div class="line">    <span class="keywordtype">void</span> operator()(<span class="keywordtype">int</span> <span class="comment">/*unused*/</span>)<span class="keyword"> const </span>{ BOOST_CHECK(expected == 1); }</div>
<div class="line">    <span class="keywordtype">void</span> operator()(error_code_extended <span class="comment">/*unused*/</span>)<span class="keyword"> const </span>{ BOOST_CHECK(expected == 2); }</div>
<div class="line">    <span class="keywordtype">void</span> operator()(std::exception_ptr <span class="comment">/*unused*/</span>)<span class="keyword"> const </span>{ BOOST_CHECK(expected == 3); }  <span class="comment">// NOLINT</span></div>
<div class="line">    <span class="keywordtype">void</span> operator()(outcome&lt;int&gt;::empty_type <span class="comment">/*unused*/</span>)<span class="keyword"> const </span>{ BOOST_CHECK(expected == 4); }</div>
<div class="line">    o_type()</div>
<div class="line">        : expected(0)</div>
<div class="line">    {</div>
<div class="line">    }</div>
<div class="line">  } o;</div>
<div class="line">  error_code_extended ec;</div>
<div class="line">  std::exception_ptr e;</div>
<div class="line">  outcome&lt;int&gt; a(5);</div>
<div class="line">  o.expected = 1;</div>
<div class="line">  (void) a.match(o);</div>
<div class="line">  o.expected = 2;</div>
<div class="line">  a = ec;</div>
<div class="line">  (void) a.match(o);</div>
<div class="line">  o.expected = 3;</div>
<div class="line">  a = e;</div>
<div class="line">  (void) a.match(o);</div>
<div class="line">  o.expected = 4;</div>
<div class="line">  a.clear();</div>
<div class="line">  (void) a.match(o);</div>
</div><!-- fragment --><div class="fragment"><div class="line">  {</div>
<div class="line">    error_code_extended ec;</div>
<div class="line">    outcome&lt;int&gt; a(5);</div>
<div class="line">    outcome&lt;int&gt; b(a &amp; 6);   <span class="comment">// a has a value, so become 6</span></div>
<div class="line">    outcome&lt;int&gt; c(b | 4);   <span class="comment">// b has a value, so remain at 6</span></div>
<div class="line">    outcome&lt;int&gt; d(a &amp; ec);  <span class="comment">// a has a value, so become errored</span></div>
<div class="line">    outcome&lt;int&gt; e(d &amp; 2);   <span class="comment">// d does not have a value, so remain errored</span></div>
<div class="line">    outcome&lt;int&gt; f(d | 2);   <span class="comment">// d does not have a value, so become 2</span></div>
<div class="line">    BOOST_CHECK(b.get() == 6);</div>
<div class="line">    BOOST_CHECK(c.get() == 6);</div>
<div class="line">    BOOST_CHECK(d.has_error());</div>
<div class="line">    BOOST_CHECK(e.has_error());</div>
<div class="line">    BOOST_CHECK(f.get() == 2);</div>
<div class="line">  }</div>
<div class="line"></div>
<div class="line">  error_code_extended ec;</div>
<div class="line">  {</div>
<div class="line">    outcome&lt;std::string&gt; a(<span class="stringliteral">&quot;niall&quot;</span>);</div>
<div class="line">    <span class="comment">// Does bind work with chains of value, error, exception and empty?</span></div>
<div class="line">    <span class="keyword">auto</span> x(a &gt;&gt; [ec](std::string) { <span class="keywordflow">return</span> ec; }                              <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](error_code_extended) { <span class="keywordflow">return</span> std::make_exception_ptr(5); }  <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](std::exception_ptr) { <span class="keywordflow">return</span>; }                              <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](outcome&lt;std::string&gt;::empty_type) { <span class="keywordflow">return</span> std::string(<span class="stringliteral">&quot;douglas&quot;</span>); });</div>
<div class="line">    BOOST_CHECK(x.get() == <span class="stringliteral">&quot;douglas&quot;</span>);</div>
<div class="line">    <span class="keyword">auto</span> y(a &gt;&gt; [ec](std::string) -&gt; outcome&lt;int&gt; { <span class="keywordflow">return</span> ec; }                                        <span class="comment">//</span></div>
<div class="line">                                     &gt;&gt; [](error_code_extended) { <span class="keywordflow">return</span> std::make_exception_ptr(5); }  <span class="comment">//</span></div>
<div class="line">                                     &gt;&gt; [](std::exception_ptr) { <span class="keywordflow">return</span>; }                              <span class="comment">//</span></div>
<div class="line">                                     &gt;&gt; [](outcome&lt;int&gt;::empty_type) { <span class="keywordflow">return</span> 5; });</div>
<div class="line">    BOOST_CHECK(y.get() == 5);</div>
<div class="line">    <span class="keyword">auto</span> z(a &gt;&gt; [](std::string &amp;&amp;v) { <span class="keywordflow">return</span> std::move(v); }  <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](std::string &amp;&amp;v) { <span class="keywordflow">return</span> std::move(v); }    <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](std::string &amp;&amp;v) { <span class="keywordflow">return</span> std::move(v); }    <span class="comment">//</span></div>
<div class="line">           &gt;&gt; [](std::string &amp;&amp;v) { <span class="keywordflow">return</span> std::move(v); });</div>
<div class="line">    BOOST_CHECK(z.get() == <span class="stringliteral">&quot;niall&quot;</span>);</div>
<div class="line">    BOOST_CHECK(a.get().empty());</div>
<div class="line">  }</div>
</div><!-- fragment --><p> You will note in the code example that the type of the callable for <code>bind()</code> and <code>map()</code> determines what operation happens. Here are the rules:</p>
<ul>
<li>If the monad contains a <code>T</code> and the callable takes a <code>T</code> or an <code>auto</code>, then:<ul>
<li>If the callable takes a <code>T</code> or any reference to a <code>T</code> which isn't an rvalue reference, the <code>T</code> is passed by const lvalue reference (i.e. copy semantics).</li>
<li>If the callable takes a <code>T</code> by non-const rvalue reference, the <code>T</code> is passed by rvalue ref. This lets you move from the value held by the originating monad if so desired.</li>
<li>If the callable takes the originating monad or any reference to such which isn't a rvalue reference, then the originating monad is passed by const lvalue reference.</li>
<li>If the callable takes the originating monad by non-const rvalue reference, the originating monad is passed by rvalue reference. The ability to take the originating monad makes <code>bind()</code> identical to <code>next()</code> though much harder on build times. Note that these options let you rebind the type of the monad, so if your callable returns a different type from the originating monad then the resulting monad is based on that different return type. <dl class="section warning"><dt>Warning</dt><dd>The current implementation requires you to specify a non-dependent return type for all generic lambdas, else you'll get compile errors where the compiler tried to insert <code>error_type</code>, <code>exception_type</code> etc when it was trying to figure out if the return type is correct. A future implementation (once MSVC has Expression SFINAE) may remove this restriction, until then just hard specify your return types if your lambdas take an <code>auto</code>, or use lambdas not taking <code>auto</code>.</dd></dl>
</li>
</ul>
</li>
<li>If the monad contains an <code>error_type</code> and the callable takes an <code>error_type</code>, then call the callable, else pass through the monad. For this reason, any callable taking an <code>error_type</code> must always return the same monad type as the originating monad.</li>
<li>If the monad contains an <code>error_type</code> or an <code>exception_type</code> and the callable takes an <code>exception_type</code>, then call the callable, else pass through the monad. For this reason, any callable taking an <code>exception_type</code> must always return the same monad type as the originating monad.</li>
<li>If the monad is empty and the callable takes an <code>empty_type</code>, then call the callable, else pass through the monad. For this reason, any callable with an <code>empty_type</code> parameter must always return the same monad type as the originating monad.</li>
</ul>
<p>Note that for nested monads e.g. <code>outcome&lt;outcome&lt;int&gt;&gt;</code>, either or both of the inner or outer monads can be with value or with error or empty. You should have your binds and maps work appropriately.</p>
<p>For maximum build performance, try to avoid <code>bind()</code> and <code>map()</code> as these use some hefty metaprogramming to deduce what kind of bind and map you're doing based on the callables passed. <code>unwrap()</code> is implemented using a recursively expanded structure which is probably okay for low unwrap depths. <code>next()</code> is probably the least weighty of the monadic operators as it's relatively dumb and the only metaprogramming is to determine whether to wrap the return type with a monad or not. Because of this impact on compile times, by default all operations apart from <code>next()</code> are not compiled in without the <code>BOOST_OUTCOME_ENABLE_OPERATORS</code> macro being defined beforehand.</p>
<h3>Acknowledgements</h3>
<p>To T.C. on Stack Overflow for answering my question at <a href="https://stackoverflow.com/questions/30802404/how-to-detect-whether-some-callable-takes-a-rvalue-reference">https://stackoverflow.com/questions/30802404/how-to-detect-whether-some-callable-takes-a-rvalue-reference</a> and without whose excellent answer the intelligent <code>map()</code> and <code>bind()</code> above could not work. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
