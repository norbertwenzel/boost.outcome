<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>boost.outcome: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">boost.outcome
   &#160;<span id="projectnumber">0.01</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">boost.outcome Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#description">Description</a></li>
<li class="level1"><a href="#prerequisites">Prerequisites and Installation</a><ul><li class="level2"><a href="#windows">Installing on Windows</a></li>
<li class="level2"><a href="#linux">Installing on Ubuntu/Debian</a></li>
<li class="level2"><a href="#osx">Installing on OS X</a></li>
<li class="level2"><a href="#source">Installing via source archive</a></li>
<li class="level2"><a href="#repo">Installing via git subrepository</a></li>
</ul>
</li>
<li class="level1"><a href="#support">Support</a></li>
<li class="level1"><a href="#introduction">Introduction and Design Rationale</a><ul><li class="level2"><a href="#c-style">C style error handling: integer returns</a></li>
<li class="level2"><a href="#cpp98-style">C++ 98 style error handling: throwing exceptions</a></li>
<li class="level2"><a href="#cpp11-style">C++ 11 style error handling: error_code and noexcept</a></li>
<li class="level2"><a href="#cpp17-style">C++ 17/20 style error handling: optional<T> and expected<T, E></a><ul><li class="level3"><a href="#optional">Returning optional<T></a></li>
<li class="level3"><a href="#expected">Returning expected<T, E></a></li>
</ul>
</li>
<li class="level2"><a href="#sea-of-noexcept">"Islands of exception throw in a sea of noexcept"</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><center><table  border="0">
<tr>
<td align="center"><a href="http://my.cdash.org/index.php?project=Boost.Outcome">CTest summary</a><br/>
<a href="http://my.cdash.org/index.php?project=Boost.Outcome">dashboard</a>  </td><td align="center"><a href="https://travis-ci.org/ned14/boost.outcome">Linux CI:</a><div class="image">
<img src="https://travis-ci.org/ned14/boost.outcome.svg?branch=master" />
</div>
  </td><td align="center"><a href="https://ci.appveyor.com/project/ned14/boost-outcome/branch/master">Windows CI:</a><div class="image">
<img src="https://ci.appveyor.com/api/projects/status/roe4dacos4gnlu66/branch/master?svg=true" />
</div>
  </td><td align="center"><a href="https://coveralls.io/r/ned14/boost.outcome?branch=master">Coverage:</a><div class="image">
<img src="https://coveralls.io/repos/ned14/boost.outcome/badge.svg?branch=master" />
</div>
   </td></tr>
</table>
</center><h1><a class="anchor" id="description"></a>
Description</h1>
<p>This is the proposed Boost.Outcome library, a Boost C++ 14 library providing a factory and family of policy driven lightweight monadic value-or-error transports with the convenience specialisations of <code>outcome&lt;T&gt;</code>, <code>result&lt;T&gt;</code> and <code>option&lt;T&gt;</code>. Its main intended usage is as an ultra light weight error handling framework, providing a more expressive and type safe alternative to error code integers or enums, yet much lower overhead than exception throws, and unlike alternatives it works perfectly with exceptions and RTTI disabled. It may be lower overhead than the <code>expected&lt;T, E&gt;</code> heading for standardisation, if not then it is certainly more convenient to program with for error handling than using <code>expected&lt;T, E&gt;</code> as it was specifically designed and tailored for this purpose.</p>
<p>If you are familiar with Swift's error code throws or Rust's <code>Result&lt;T&gt;</code> and <code>Option&lt;T&gt;</code>, you will find almost identical semantics in the transports provided here. One can therefore write systems programming code using these transports in C++ in the same design pattern as when writing in Rust or Swift, and with a similarly low runtime overhead.</p>
<h1><a class="anchor" id="prerequisites"></a>
Prerequisites and Installation</h1>
<p>Boost.Outcome is a header only library known to work on these compilers or better:</p>
<ul>
<li>GCC 5.0</li>
<li>clang 3.7</li>
<li>VS2015 Update 2</li>
<li>clang 3.7 with Microsoft Codegen ("winclang")</li>
</ul>
<p>Its sole mandatory dependency is on <a href="https://github.com/ned14/boost-lite,">https://github.com/ned14/boost-lite,</a> a minimal emulation of Boost for C++ 14. A copy is embedded internally so a copy of Boost is <b>not</b> required to use this library. You can simply drop Outcome into your project and go, including Outcome using one of these depending on how you install Outcome:</p>
<ul>
<li><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;boost/outcome.hpp&gt;</span> </div>
</div><!-- fragment --></li>
<li><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;boost.outcome/include/boost/outcome.hpp&quot;</span> </div>
</div><!-- fragment --></li>
</ul>
<p>Each commit is tested by Travis and Appveyor. A nightly cronjob figures out which latest commit all tests passed for and pushes a distribution to the following package repositories:</p>
<h2><a class="anchor" id="windows"></a>
Installing on Windows</h2>
<p>If you are using VS15 or better it comes with VCPkg, a package manager. Open a Developer Tools prompt and type:</p>
<p><code>vcpkg install <a class="el" href="namespaceboost_1_1outcome.html" title="The Outcome namespace.">boost.outcome</a></code></p>
<p>Once installed it is available for usage in any Visual Studio project.</p>
<h2><a class="anchor" id="linux"></a>
Installing on Ubuntu/Debian</h2>
<pre>add-apt-repository ppa:ned14/boost.outcome
apt-get install <a class="el" href="namespaceboost_1_1outcome.html" title="The Outcome namespace.">boost.outcome</a></pre><h2><a class="anchor" id="osx"></a>
Installing on OS X</h2>
<p>Assuming you have <a href="http://brew.sh/">homebrew</a> installed, then:</p>
<pre>brew tap ned14/tap
brew install <a class="el" href="namespaceboost_1_1outcome.html" title="The Outcome namespace.">boost.outcome</a></pre><h2><a class="anchor" id="source"></a>
Installing via source archive</h2>
<p>Visit <a href="https://dedi4.nedprod.com/static/files/">https://dedi4.nedprod.com/static/files/</a> and download the latest <a class="el" href="namespaceboost_1_1outcome.html" title="The Outcome namespace.">boost.outcome</a> tarball. Tarballs are only uploaded if everything built and all tests passed.</p>
<h2><a class="anchor" id="repo"></a>
Installing via git subrepository</h2>
<p><code>git submodule add <a href="https://github.com/ned14/boost.outcome">https://github.com/ned14/boost.outcome</a></code></p>
<p>The master branch is automatically set to whichever was the last commit on develop branch to pass all unit tests.</p>
<h1><a class="anchor" id="support"></a>
Support</h1>
<p><a href="https://stackoverflow.com/">StackOverflow</a> with the boost-outcome tag is the preferred place to ask questions on usage.</p>
<p>If you have a problem, please review the FAQ and the wiki. Searching <a href="https://github.com/ned14/boost.outcome/issues">the issues</a> for your problem is also a good idea. If you are encountering what you think is a bug, please open an issue.</p>
<h1><a class="anchor" id="introduction"></a>
Introduction and Design Rationale</h1>
<h2><a class="anchor" id="c-style"></a>
C style error handling: integer returns</h2>
<p>Historically C++ 98 code has taken one of two design patterns when returning errors from functions. This pattern is taken from C, and indeed is pure C:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line"><span class="keyword">enum</span> errors</div>
<div class="line">{</div>
<div class="line">  SUCCESS=0,</div>
<div class="line">  NOMEM,</div>
<div class="line">  NOTFOUND,</div>
<div class="line">  ...</div>
<div class="line">};</div>
<div class="line">...</div>
<div class="line">int openfile(<span class="keyword">struct</span> handle **outh, <span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  *outh = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> handle));</div>
<div class="line">  <span class="keywordflow">if</span>(!*outh)</div>
<div class="line">    <span class="keywordflow">return</span> NOMEM;</div>
<div class="line">  (*outh)-&gt;fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>((*outh)-&gt;fd == -1)</div>
<div class="line">  {</div>
<div class="line">    free(*outh);</div>
<div class="line">    *outh = NULL;</div>
<div class="line">    <span class="keywordflow">return</span> NOTFOUND;</div>
<div class="line">  }</div>
<div class="line">  ...</div>
<div class="line">  <span class="keywordflow">return</span> SUCCESS;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Almost certainly anyone reading this has seen this error handling design umpteen times in their career. Variations on the same pattern are returning the enum type directly, returning a boolean and using a thread locally stored global variable such as <code>errno</code> and so on.</p>
<h2><a class="anchor" id="cpp98-style"></a>
C++ 98 style error handling: throwing exceptions</h2>
<p>The second C++ 98 design pattern ought to also be very familiar to readers: </p>
<div class="fragment"><div class="line"><span class="comment">// Abstract base class for some handle implementation</span></div>
<div class="line"><span class="keyword">struct </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  ...</div>
<div class="line">  <span class="keyword">virtual</span> ~handle()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(fd != -1)</div>
<div class="line">    {</div>
<div class="line">      close(fd);</div>
<div class="line">      fd = -1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>handle_ref;  <span class="comment">// Some sort of smart pointer managing a handle *</span></div>
<div class="line">handle_ref openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;File not found&quot;</span>);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Could throw std::bad_alloc or any other kind of exception during construction</span></div>
<div class="line">    <span class="keywordflow">return</span> handle_ref(<span class="keyword">new</span> some_derived_handle_implementation(fd));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(...)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="keywordflow">throw</span>;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Experts will quite correctly chafe at the use of <code>std::runtime_error</code> to report a file not found, but nevertheless such a design pattern is very common in the wild.</p>
<h2><a class="anchor" id="cpp11-style"></a>
C++ 11 style error handling: error_code and noexcept</h2>
<p>C++ 11 brought in two new features to help bridge the gap between the over use of exception throws to report routine failures and C error handling: (i) <code>noexcept</code> and (ii) the standardisation of <code>error_code</code> from Boost. <code>noexcept</code> lets you mark functions with the guarantee that they shall <b>never</b> throw exceptions. This is commonly described as a feature enabling the compiler and standard library to use faster algorithms which can assume that operations never need to undone part way through, however it also enables a whole new way of writing C++ which we shall call *"islands of exception throw in a sea
of noexcept"* which will be described later.</p>
<p>Both the Boost and C++ 11 <code>error_code</code> consists of an integer and a reference to an <code>error_category</code> instance. This allows one to set a <em>domain</em> for an integer error code such that <code>NOTFOUND</code> in library A can have a different integer value to <code>NOTFOUND</code> in library B. Because the reference to the domain of the error code is transported with the error code, integer error codes can be propagated <em>without losing information</em> into other code which need have no knowledge whatsover of libraries A nor B. <code>error_code</code> and the other machinery in <code>&lt;system_error&gt;</code> lets you handle errors from unknown libraries via <code>error_condition</code> which lets you inspect unknown third party <code>error_code</code>'s for whether they have semantic equivalence to the standard POSIX errors, and therefore handle a file-not-found situation based on semantic equivalence rather than losing information from the original source by doing an error code conversion. Therefore as with exception types deriving from <code>std::exception</code>, a central error handling routine can understand just enough of unknown third party error codes to act appropriately.</p>
<p>The C++ 11 standard library makes very limited use of <code>error_code</code> for reporting errors, however the Filesystem TS and Networking TS as indeed much of Boost uses this error handling design pattern extensively:</p>
<div class="fragment"><div class="line"><span class="comment">// Abstract base class for some handle implementation</span></div>
<div class="line"><span class="keyword">struct </span>handle</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd;</div>
<div class="line">  ...</div>
<div class="line">  <span class="keyword">virtual</span> ~handle()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(fd != -1)</div>
<div class="line">    {</div>
<div class="line">      close(fd);</div>
<div class="line">      fd = -1;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line"><span class="keyword">class </span>handle_ref;  <span class="comment">// Some sort of smart pointer managing a handle *</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Non-throwing overload</span></div>
<div class="line">handle_ref openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, std::error_code &amp;ec) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// Construct an error code in the OS errors domain</span></div>
<div class="line">    ec = std::error_code(errno, std::system_category());</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">  <span class="keyword">auto</span> *p = <span class="keyword">new</span>(std::nothrow) some_derived_handle_implementation(fd, ec);</div>
<div class="line">  <span class="keywordflow">if</span>(p == <span class="keyword">nullptr</span>)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="comment">// Construct an error code matching the generic OS error equivalent</span></div>
<div class="line">    <span class="comment">// to the ENOMEM error condition</span></div>
<div class="line">    ec = <a class="code" href="group__monad.html#gab6204dd7620b0e495220e76988359589" title="ADL looked up by the STL to convert a monad_errc into an error_code.">std::make_error_code</a>(std::errc::not_enough_memory);</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">delete</span> p;</div>
<div class="line">    <span class="keywordflow">return</span> {};</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> handle_ref(p);</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// Throwing overload</span></div>
<div class="line">handle_ref openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path)</div>
<div class="line">{</div>
<div class="line">  std::error_code ec;</div>
<div class="line">  handle_ref ret(openfile(path, ec));</div>
<div class="line">  <span class="keywordflow">if</span>(ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">throw</span> std::system_error(ec);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> ret;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This third error handling design pattern has two big advantages:</p>
<ol type="1">
<li>You only pay for what you use, so if you call the non-throwing overload you are guaranteed by the <code>noexcept</code> that execution flow will not unexpectedly invert. This makes writing correct exception safe code much easier, plus unpredictable execution times due to exception throws cannot occur. The compiler can also reduce executable bloat by not generating stack unwind tables around that call which is useful for some C++ users.</li>
<li>It allows one to segment truly exceptional events into exception throws with stack unwinds and to handle ordinary and common failures in normal forward execution program logic. This is exactly the error handling model used by the new systems languages Swift and Rust.</li>
</ol>
<h2><a class="anchor" id="cpp17-style"></a>
C++ 17/20 style error handling: optional&lt;T&gt; and expected&lt;T, E&gt;</h2>
<p>C++ 17 isn't finished at the time of writing, but we are very sure that at least <a href="http://en.cppreference.com/w/cpp/utility/optional"><code>std::optional&lt;T&gt;</code></a> will be in it. It remains to be seen if LEWG's <code>expected&lt;T, E&gt;</code> will make it, if not then most STL implementations will probably ship an implementation as an experimental and if your STL does not, there is always the reference implementation at <a href="https://github.com/viboes/std-make">https://github.com/viboes/std-make</a> which ought to work on any C++ 14 compiler.</p>
<p>The following discussion is based on <code>expected&lt;T, E&gt;</code> as detailed by <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0323r1.pdf">P0323R1</a> which is the latest LEWG proposal paper at the time of writing (Nov 2016) and indeed one where <code>expected&lt;T, E&gt;</code> was pared down significantly from its original proposal. It should be noted that C++ may yet end up adopting something quite different, though given how long <code>expected&lt;T, E&gt;</code> has been around by now, and how it is getting to fitting nicely between <code>optional&lt;T&gt;</code> and <code>variant&lt;T, E&gt;</code>, it would seem unlikely. <code>expected&lt;T, E&gt;</code> is intended as a strict superset of <code>optional&lt;T&gt;</code> with aspects of <a href="http://en.cppreference.com/w/cpp/utility/variant"><code>std::variant&lt;T, E&gt;</code></a>, indeed much of LEWG's remaining work on the proposal is on reconciling the small remaining semantic differences between <code>expected&lt;T, nullopt_t&gt;</code> and <code>optional&lt;T&gt;</code>.</p>
<p>The original prototype Boost.Expected library was a large and very complex beastie - I was fortunate to be employed on a contract in 2015 where I saw it deployed at scale into a large C++ codebase. Indeed, much of what I witnessed there had a big impact in how Outcome ended up being designed. P0323R1 proposes an enormously simplified implementation which ought to fix all of the showstopper problems with the original that I am aware of, and P0323R1's <code>expected&lt;T, E&gt;</code> has a huge resemblance to Outcome in every day usage, which is unintentionally deliberate as the committee have made most of the changes I also made in Outcome. Outcome still contributes significant value for low-latency users, as we shall see later.</p>
<h3><a class="anchor" id="optional"></a>
Returning optional&lt;T&gt;</h3>
<p>In some programming contexts we don't need to know why an operation failed, only that it did. Throwing an exception after failing to find a file is a good example of the kind of failure which is very common and where throwing an exception to handle that event is excessive and inappropriate. One might therefore design a routine expected to frequently fail in C++ as:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns true for success and fills \em out with the opened file, else false</span></div>
<div class="line"><span class="keywordtype">bool</span> openfile(handle_ref &amp;out, <span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept;</div>
</div><!-- fragment --><p>Wouldn't it be much nicer though if you didn't force the caller to have to instantiate a copy of <code>handle_ref</code> before each call, not least because such a requirement messes badly with using <code>openfile()</code> in generic template code and moreover it could be the case that constructing a <code>handle_ref</code> is an atomic operation, and is thus wasted work if the failure to open is very common? This is where <code>optional&lt;T&gt;</code> comes in:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns the opened handle on success, else an empty optional</span></div>
<div class="line">std::optional&lt;handle_ref&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept;</div>
<div class="line">...</div>
<div class="line">auto fh_ = openfile(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(fh_)</div>
<div class="line">{</div>
<div class="line">  handle_ref fh = std::move(fh_.value());</div>
<div class="line">  fh-&gt;read(... etc</div>
<div class="line">}</div>
</div><!-- fragment --><p><code>optional&lt;T&gt;</code> is pretty boring and unsurprising like any good primitive. It's also fairly intuitive, almost any C++ programmer will immediately understand what the code above does from inspection.</p>
<h3><a class="anchor" id="expected"></a>
Returning expected&lt;T, E&gt;</h3>
<p>Many familiar with the filesystem will find the above use case of <code>optional&lt;T&gt;</code> unsettling because there are many reasons why one couldn't open a file rather than merely it was not found. Imagine, for example, that a program is attempting to open a few thousand files on a networked drive which has broken its connection - in this case every single failure will take considerable time to return and there is zero chance <em>any</em> file open will ever succeed, so what the user sees is an apparently hanged program. Far better would be if the <code>openfile()</code> function could return the cause of its failure, and we could then treat all errors which are different to file-not-found as reason to abort.</p>
<p>Enter LEWG's proposed <code>expected&lt;T, E&gt;</code> which can hold either an expected value of type <code>T</code> or an unexpected value of type <code>E</code>. Like <code>variant&lt;T, E&gt;</code>, <code>expected&lt;T, E&gt;</code> is a discrimated union storing either <code>T</code> or <code>E</code> in the same storage space, but unlike the variant, expected treats the <code>T</code> as a positive thing (fetchable via a <code>.<a class="el" href="group__monad.html#gab1740f6220ea9c91b5fd5a9263c6b316" title="Variable of type value_t.">value()</a></code>) and <code>E</code> as a negative thing (fetchable via a <code>.<a class="el" href="group__monad.html#ga1a1a8470c4efc3a52412f3ecc79a0060" title="Variable of type error_t.">error()</a></code>). Because <code>expected&lt;T, E&gt;</code> provides a "never empty" guarantee similar to variant, it currently requires type <code>E</code> to be nothrow copy and move constructible and assignable. Expected is a bit less intuitive to use than optional, but its rules are straightforward: <code>expected&lt;T, E&gt;</code> will greedily and implicitly construct from any type from which a <code>T</code> can be constructed, after which it will hold an instance of <code>T</code>. If you wish to construct an <code>expected&lt;T, E&gt;</code> holding an instance of unexpected <code>E</code>, you need to feed it an <code>unexpected&lt;E&gt;</code> which is type sugar to indicate you want an instance of <code>E</code> implicitly converted into an <code>expected&lt;T, E&gt;</code>. As with everything else in C++ 11 onwards, there is a <code>make_expected(T)</code> and a <code>make_unexpected(E)</code> which do any type deduction and conversion for you into the right contents of <code>expected&lt;T, E&gt;</code>.</p>
<p>All this sounds a bit complex, but really it's much easier to use. Here is a non-throwing implementation based on <code>expected&lt;T, E&gt;</code></p>
<div class="fragment"><div class="line"><span class="comment">// Returns the expected opened handle on success, or an unexpected cause of failure</span></div>
<div class="line">std::expected&lt;handle_ref, std::error_code&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = open(path, O_RDONLY);</div>
<div class="line">  <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unexpected(std::error_code(errno, std::system_category());</div>
<div class="line">  }</div>
<div class="line">  std::error_code ec;</div>
<div class="line">  <span class="keyword">auto</span> *p = <span class="keyword">new</span>(std::nothrow) some_derived_handle_implementation(fd, ec);</div>
<div class="line">  <span class="keywordflow">if</span>(p == <span class="keyword">nullptr</span>)</div>
<div class="line">  {</div>
<div class="line">    close(fd);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unexpected(<a class="code" href="group__monad.html#gab6204dd7620b0e495220e76988359589" title="ADL looked up by the STL to convert a monad_errc into an error_code.">std::make_error_code</a>(std::errc::not_enough_memory));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span>(ec)</div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">delete</span> p;</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unexpected(std::move(ec));</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> handle_ref(p);  <span class="comment">// expected&lt;&gt; takes implicit conversion from type T</span></div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">auto fh_ = openfile(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(!fh_ &amp;&amp; fh_.error() != std::errc::no_such_file_or_directory)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// This is serious, abort</span></div>
<div class="line">  <span class="keywordflow">throw</span> std::system_error(std::move(fh_.error()));</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span>(fh_)</div>
<div class="line">{</div>
<div class="line">  handle_ref fh = std::move(fh_.value());</div>
<div class="line">  fh-&gt;read(... etc</div>
<div class="line">}</div>
</div><!-- fragment --><p>The prototype Boost.Expected library and the P0323R1 reference library actually declares <code>expected&lt;T, E = std::exception_ptr&gt;</code> as the default despite that P0323R1 no longer makes any mention of type <code>E</code> being defaulted, so for completeness let's rewrite the above to match that design instead:</p>
<div class="fragment"><div class="line"><span class="comment">// Returns the expected opened handle on success, or an unexpected cause of failure</span></div>
<div class="line">std::expected&lt;handle_ref, std::exception_ptr&gt; openfile(<span class="keyword">const</span> <span class="keywordtype">char</span> *path) noexcept</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">int</span> fd = -1;</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    fd = open(path, O_RDONLY);</div>
<div class="line">    <span class="keywordflow">if</span>(fd == -1)</div>
<div class="line">    {</div>
<div class="line">      <span class="keywordflow">throw</span> std::system_error(std::error_code(errno, std::system_category()));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> make_handle_ref&lt;some_derived_handle_implementation&gt;(fd);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(...)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(fd != -1)</div>
<div class="line">      close(fd);</div>
<div class="line">    <span class="keywordflow">return</span> std::make_unexpected(std::current_exception());</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">...</div>
<div class="line">auto fh_ = openfile(<span class="stringliteral">&quot;foo&quot;</span>);</div>
<div class="line"><span class="keywordflow">if</span>(!fh_)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">try</span></div>
<div class="line">  {</div>
<div class="line">    std::rethrow_exception(fh_.error());</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">catch</span>(<span class="keyword">const</span> std::system_error &amp;e)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">if</span>(e.code() != std::errc::no_such_file_or_directory)</div>
<div class="line">      rethrow;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// All other exception types are rethrown</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">else</span></div>
<div class="line">{</div>
<div class="line">  handle_ref fh = std::move(fh_.value());</div>
<div class="line">  fh-&gt;read(... etc</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is the very first time in this tutorial that we have seen the design pattern around which Outcome was specifically designed to make easy: <em>islands of exception throw in a sea of noexcept</em>.</p>
<h2><a class="anchor" id="sea-of-noexcept"></a>
"Islands of exception throw in a sea of noexcept"</h2>
<p>To be continued ... </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
